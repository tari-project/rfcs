<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0201: TariScript - The Tari Network: RFC library</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Tari network RFC library and documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
            }
          });
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0Q69T0B1T4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-0Q69T0B1T4');
        </script>

    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = 'light';
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <img src="theme/images/tari-splash.png" class="tlu">

            <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About the Tari RFC documents</a></li><li class="chapter-item expanded "><a href="RFC-0001_overview.html"><strong aria-hidden="true">1.</strong> RFC-0001: An overview of the Tari network</a></li><li class="chapter-item expanded "><a href="base_layer.html"><strong aria-hidden="true">2.</strong> The Tari Base Layer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0110_BaseNodes.html"><strong aria-hidden="true">2.1.</strong> RFC-0110: Base nodes</a></li><li class="chapter-item expanded "><a href="RFC-0111_BaseNodeArchitecture.html"><strong aria-hidden="true">2.2.</strong> RFC-0111: Base node architecture</a></li><li class="chapter-item expanded "><a href="RFC-0120_Consensus.html"><strong aria-hidden="true">2.3.</strong> RFC-0120: Consensus rules</a></li><li class="chapter-item expanded "><a href="RFC-0131_Mining.html"><strong aria-hidden="true">2.4.</strong> RFC-0131: Mining</a></li><li class="chapter-item expanded "><a href="RFC-0132_Merge_Mining_Monero.html"><strong aria-hidden="true">2.5.</strong> RFC-0132: Merge Mining Monero</a></li><li class="chapter-item expanded "><a href="RFC-0140_Syncing_and_seeding.html"><strong aria-hidden="true">2.6.</strong> RFC-0140: Synchronizing the Blockchain: Archival and Pruned modes</a></li><li class="chapter-item expanded "><a href="RFC-0150_Wallets.html"><strong aria-hidden="true">2.7.</strong> RFC-0150: Wallets</a></li><li class="chapter-item expanded "><a href="RFC-0155_TariAddress.html"><strong aria-hidden="true">2.8.</strong> RFC-0155: TariAddress</a></li><li class="chapter-item expanded "><a href="RFC-0160_BlockSerialization.html"><strong aria-hidden="true">2.9.</strong> RFC-0160: Block Binary Serialization</a></li><li class="chapter-item expanded "><a href="RFC-0170_NetworkCommunicationProtocol.html"><strong aria-hidden="true">2.10.</strong> RFC-0170: Network Communication Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0171_MessageSerialisation.html"><strong aria-hidden="true">2.10.1.</strong> RFC-0171: Message Serialisation</a></li><li class="chapter-item expanded "><a href="RFC-0172_PeerToPeerMessagingProtocol.html"><strong aria-hidden="true">2.10.2.</strong> RFC-0172: Peer to Peer Messaging Protocol</a></li><li class="chapter-item expanded "><a href="RFC-0173_Versioning.html"><strong aria-hidden="true">2.10.3.</strong> RFC-0173: Versioning</a></li><li class="chapter-item expanded "><a href="RFC-0174_Chat_Metadata.html"><strong aria-hidden="true">2.10.4.</strong> RFC-0174: Chat Metadata</a></li></ol></li><li class="chapter-item expanded "><a href="RFC-0181_BulletproofsPlus.html"><strong aria-hidden="true">2.11.</strong> RFC-0181: Bulletproofs+ range proving</a></li><li class="chapter-item expanded "><a href="RFC-0182_CommitmentSignatures.html"><strong aria-hidden="true">2.12.</strong> RFC-0182: Commitment signatures</a></li><li class="chapter-item expanded "><a href="RFC-0190_Mempool.html"><strong aria-hidden="true">2.13.</strong> RFC-0190: Mempool</a></li><li class="chapter-item expanded "><a href="BaseLayerExtensions.html"><strong aria-hidden="true">2.14.</strong> Tari-specific extensions to Mimblewimble</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0201_TariScript.html" class="active"><strong aria-hidden="true">2.14.1.</strong> RFC-0201: TariScript</a></li><li class="chapter-item expanded "><a href="RFC-0202_TariScriptOpcodes.html"><strong aria-hidden="true">2.14.2.</strong> RFC-0202: TariScript Opcodes</a></li><li class="chapter-item expanded "><a href="RFC-0204_TariScriptExamples.html"><strong aria-hidden="true">2.14.3.</strong> RFC-0204: TariScript Examples</a></li><li class="chapter-item expanded "><a href="RFC-0203_StealthAddresses.html"><strong aria-hidden="true">2.14.4.</strong> RFC-0203: Stealth Addresses</a></li><li class="chapter-item expanded "><a href="RFC-0205_HardwareTransactions.html"><strong aria-hidden="true">2.14.5.</strong> RFC-0205: Hardware Transactions</a></li><li class="chapter-item expanded "><a href="RFC-0250_Covenants.html"><strong aria-hidden="true">2.14.6.</strong> RFC-0250: Covenants</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="RFC-0303_DanOverview.html"><strong aria-hidden="true">3.</strong> RFC-0303: The Tari Digital Assets Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0313_VNRegistration.html"><strong aria-hidden="true">3.1.</strong> RFC-0313: Validator Node Registration</a></li><li class="chapter-item expanded "><a href="RFC-0320_TurbineModel.html"><strong aria-hidden="true">3.2.</strong> RFC-0320: The turbine model</a></li><li class="chapter-item expanded "><a href="RFC-0350_TariVM.html"><strong aria-hidden="true">3.3.</strong> RFC-0350: The Tari Virtual Machine</a></li></ol></li><li class="chapter-item expanded "><a href="RFC-0305_Consensus.html"><strong aria-hidden="true">4.</strong> RFC-0305: The Tari Network Consensus Layer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0314_VNCSelection.html"><strong aria-hidden="true">4.1.</strong> RFC-0314: Validator node committee selection</a></li><li class="chapter-item expanded "><a href="RFC-0321_ProcessingForeignProposals.html"><strong aria-hidden="true">4.2.</strong> RFC-0321: Processing foreign proposals</a></li><li class="chapter-item expanded "><a href="RFC-0325_DanTimeManagement.html"><strong aria-hidden="true">4.3.</strong> RFC-0325: Epochs and time management</a></li><li class="chapter-item expanded "><a href="RFC-0330_Cerberus.html"><strong aria-hidden="true">4.4.</strong> RFC-0330: The Cerberus-Hotstuff consensus algorithm</a></li><li class="chapter-item expanded "><a href="RFC-0331_Indexers.html"><strong aria-hidden="true">4.5.</strong> RFC-0331: Indexers</a></li></ol></li><li class="chapter-item expanded "><a href="proposals.html"><strong aria-hidden="true">5.</strong> Proposals and Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0123_One_sided_replay_attacks.html"><strong aria-hidden="true">5.1.</strong> RFC-0123: Mitigating One-sided payment replay attacks</a></li><li class="chapter-item expanded "><a href="RFC-0141_Sparse_Merkle_Trees.html"><strong aria-hidden="true">5.2.</strong> RFC-0141: Sparse Merkle Tees</a></li><li class="chapter-item expanded "><a href="RFC-0153_StagedWalletSecurity.html"><strong aria-hidden="true">5.3.</strong> RFC-0153: Staged Wallet Security</a></li><li class="chapter-item expanded "><a href="RFC-0154_DeepLinksConvencion.html"><strong aria-hidden="true">5.4.</strong> RFC-0154: Deep links structure convention</a></li><li class="chapter-item expanded "><a href="RFC-0230_HTLC.html"><strong aria-hidden="true">5.5.</strong> RFC-0230: Hash time locked contracts</a></li><li class="chapter-item expanded "><a href="RFC-0240_AtomicSwap.html"><strong aria-hidden="true">5.6.</strong> RFC-0240: Atomic swap</a></li><li class="chapter-item expanded "><a href="RFC-0241_AtomicSwapXMR.html"><strong aria-hidden="true">5.7.</strong> RFC-0241: XMR Atomic swap</a></li><li class="chapter-item expanded "><a href="RFC-0310_SubmarineSwaps.html"><strong aria-hidden="true">5.8.</strong> RFC-0310: Submarine swaps</a></li><li class="chapter-item expanded "><a href="RFC-0388_BearerTokens.html"><strong aria-hidden="true">5.9.</strong> RFC-0388: Bearer tokens</a></li><li class="chapter-item expanded "><a href="RFC-8001_MultiPartyTransactions.html"><strong aria-hidden="true">5.10.</strong> RFC-8001: Multi-party transactions</a></li><li class="chapter-item expanded "><a href="RFC-8002_TransactionProtocol.html"><strong aria-hidden="true">5.11.</strong> RFC-8002: Transaction protocol</a></li><li class="chapter-item expanded "><a href="RFC-8003_TariUseCases.html"><strong aria-hidden="true">5.12.</strong> RFC-8003: Tari Use Cases</a></li><li class="chapter-item expanded "><a href="RFC-0385_StableCoins.html"><strong aria-hidden="true">5.13.</strong> RFC-0385: Privacy-enabled Stablecoin contract design</a></li><li class="chapter-item expanded "><a href="RFC-0323_TariThrottle.html"><strong aria-hidden="true">5.14.</strong> RFC-0323: Tari throttle exploratory analysis</a></li></ol></li><li class="chapter-item expanded "><a href="deprecated.html"><strong aria-hidden="true">6.</strong> Deprecated RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFCD-0010_CodeStructure.html"><strong aria-hidden="true">6.1.</strong> RFC-0010: Tari code structure and organization</a></li><li class="chapter-item expanded "><a href="RFCD-0121_ConsensusEncoding.html"><strong aria-hidden="true">6.2.</strong> RFC-0121: Consensus encoding</a></li><li class="chapter-item expanded "><a href="RFCD-0130_Mining.html"><strong aria-hidden="true">6.3.</strong> RFC-0130: Mining</a></li><li class="chapter-item expanded "><a href="RFCD-0152_EmojiId.html"><strong aria-hidden="true">6.4.</strong> RFCD-0152: Emoji ID</a></li><li class="chapter-item expanded "><a href="RFCD-0180_BulletproofRewinding.html"><strong aria-hidden="true">6.5.</strong> RFC-0180: Bulletproof range proof rewinding</a></li><li class="chapter-item expanded "><a href="RFCD-0300_DAN.html"><strong aria-hidden="true">6.6.</strong> RFC-0300: The Digital Assets Network</a></li><li class="chapter-item expanded "><a href="RFCD-0301_NamespaceRegistration.html"><strong aria-hidden="true">6.7.</strong> RFC-0301: Namespace Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0302_ValidatorNodes.html"><strong aria-hidden="true">6.8.</strong> RFC-0302: Validator Nodes</a></li><li class="chapter-item expanded "><a href="RFCD-0304_VNCommittees.html"><strong aria-hidden="true">6.9.</strong> RFC-0304: Validator Node committee selection</a></li><li class="chapter-item expanded "><a href="RFCD-0306_DANTemplateRegistration.html"><strong aria-hidden="true">6.10.</strong> RFC-0306: DAN Template Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0311_AssetTemplates.html"><strong aria-hidden="true">6.11.</strong> RFC-0311: Digital Asset templates</a></li><li class="chapter-item expanded "><a href="RFCD-0312_DANHighLevelSpecification.html"><strong aria-hidden="true">6.12.</strong> RFC-0312: High level Digital Asset Network Specification</a></li><li class="chapter-item expanded "><a href="RFCD-0322_VNRegistration.html"><strong aria-hidden="true">6.13.</strong> RFC-0322: Validator Node Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0340_VNConsensusOverview.html"><strong aria-hidden="true">6.14.</strong> RFC-0340: Validator Node Consensus</a></li><li class="chapter-item expanded "><a href="RFCD-0341_AssetRegistration.html"><strong aria-hidden="true">6.15.</strong> RFC-0341: Asset registration</a></li><li class="chapter-item expanded "><a href="RFCD-0345_AssetLifeCycle.html"><strong aria-hidden="true">6.16.</strong> RFC-0345: Asset Life cycle</a></li><li class="chapter-item expanded "><a href="RFCD-0360_NFTInvoices.html"><strong aria-hidden="true">6.17.</strong> RFC-0360: NFT sale using MimbleWimble Invoice</a></li><li class="chapter-item expanded "><a href="RFCD-0500_PaymentChannels.html"><strong aria-hidden="true">6.18.</strong> RFC-0500: Tari payment channels</a></li></ol></li><li class="chapter-item expanded "><a href="RFC_template.html"><strong aria-hidden="true">7.</strong> RFC template</a></li><li class="chapter-item expanded "><a href="Glossary.html"><strong aria-hidden="true">8.</strong> Glossary</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                        </div>

                        <h1 class="menu-title"><img src="theme/images/tari-horizontal-logo.png"/> </h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rfc-0201tariscript"><a class="header" href="#rfc-0201tariscript">RFC-0201/TariScript</a></h1>
<h2 id="tariscript"><a class="header" href="#tariscript">TariScript</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>, <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence"><a class="header" href="#licence">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2020 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language"><a class="header" href="#language">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>This Request for Comment (RFC) presents a proposal for introducing <a href="Glossary.html#tariscript">TariScript</a> into the Tari base layer protocol. Tari
Script aims to provide a general mechanism for enabling further extensions such as side-chains, the DAN, one-sided
payments and atomic swaps.</p>
<h2 id="related-requests-for-comment"><a class="header" href="#related-requests-for-comment">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0182_CommitmentSignatures.html">RFC-0182: Commitment and public key signatures</a></li>
<li><a href="BaseLayerExtensions.html">RFC-0200: Base Layer Extensions</a></li>
<li><a href="RFC-0202_TariScriptOpcodes.html">RFC-0202: TariScript Opcodes</a></li>
<li><a href="RFC-0204_TariScriptExamples.html">RFC-0204: TariScript Examples</a></li>
<li><a href="RFC-0250_Covenants.html">RFC-0250: Covenants</a></li>
</ul>
<p>$$
\newcommand{\script}{\alpha} % utxo script
\newcommand{\input}{ \theta }
\newcommand{\cat}{\Vert}
\newcommand{\so}{\gamma} % script offset
\newcommand{\hash}[1]{\mathrm{H}\bigl({#1}\bigr)}
$$</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>It is hopefully clear to anyone reading these RFCs that the ambitions of the Tari project extend beyond a
Mimblewimble-clone-coin.
It should also be fairly clear that vanilla Mimblewimble does not have the feature set to provide functionality such as:</p>
<ul>
<li>One-sided payments</li>
<li>Multiparty side-chain peg-outs and peg-ins</li>
<li>Generalised smart contracts</li>
</ul>
<p>Extensions to <a href="Glossary.html#mimblewimble">Mimblewimble</a> have been proposed for most of these features, for example, David Burkett's one-sided payment
proposal for LiteCoin (<a href="https://github.com/DavidBurkett/lips/blob/master/lip-0004.mediawiki">LIP-004</a>) and this project's <a href="RFC-0230_HTLC.html">HTLC RFC</a>.</p>
<p>Some smart contract features are possible, or partly possible in vanilla <a href="Glossary.html#mimblewimble">Mimblewimble</a> using <a href="https://tlu.tarilabs.com/cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html">Scriptless script</a>, such as</p>
<ul>
<li>Atomic swaps </li>
<li>Hash time-locked contracts</li>
</ul>
<p>Tari implemented a scripting language similar to Bitcoin script, called <a href="Glossary.html#tariscript">TariScript</a>, under a single set of (relatively 
minor) modifications and additions to the Mimblewimble protocol, which achieved collapsing all of these use cases.</p>
<h2 id="scripting-on-mimblewimble"><a class="header" href="#scripting-on-mimblewimble">Scripting on Mimblewimble</a></h2>
<p>Other than Beam, none of the existing <a href="Glossary.html#mimblewimble">Mimblewimble</a> projects have employed a scripting language. </p>
<p><a href="https://github.com/mimblewimble/grin">Grin</a> styles itself as a &quot;Minimal implementation of the Mimblewimble protocol&quot;,
so one might infer that this status is unlikely to change soon.</p>
<p>Beam <a href="https://github.com/BeamMW/beam/wiki/Beam-Smart-Contracts">does have a smart contract</a>
protocol, which allows users to execute arbitrary code (shaders) in a sandboxed Beam VM and have the results of that 
code interact with transactions.</p>
<p><a href="https://github.com/mwcproject/mwc-node/blob/master/doc/roadmap.md">Mimblewimble coin</a> is a fork of Grin and &quot;considers
the protocol ossified&quot;.</p>
<p>Litecoin has included Mimblewimble as a
<a href="https://github.com/litecoin-project/lips/blob/master/lip-0003.mediawiki">side-chain through MWEB</a>. As of 2022, there 
appears to be no plans to include general scripting into the protocol.</p>
<h3 id="scriptless-scripts"><a class="header" href="#scriptless-scripts">Scriptless scripts</a></h3>
<p><a href="https://tlu.tarilabs.com/cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html">Scriptless script</a> is a wonderfully elegant technology and the inclusion of <a href="Glossary.html#tariscript">TariScript</a> does not preclude the use of
Scriptless scripts in Tari. However, scriptless scripts have some disadvantages:</p>
<ul>
<li>They are often difficult to reason about, with the result that the development of features based on scriptless scripts
is essentially in the hands of a very select group of cryptographers and developers.</li>
<li>The use case set is impressive considering that the &quot;scripts&quot; are essentially signature wrangling, but is still 
somewhat limited.</li>
<li>Every feature must be written and implemented separately using the specific and specialised protocol designed for that
feature. That is, it cannot be used as a dynamic scripting framework on a running blockchain.</li>
</ul>
<h2 id="tariscript---a-brief-motivation"><a class="header" href="#tariscript---a-brief-motivation">TariScript - a brief motivation</a></h2>
<p>The essential idea of <a href="Glossary.html#tariscript">TariScript</a> is as follows:</p>
<p>Given a standard Tari UTXO, we add <em>additional restrictions</em> on whether that UTXO can be included as a valid input in a
transaction.</p>
<p>As long as those conditions are suitably committed to, are not malleable throughout the existence of the UTXO, and one
can prove that the script came from the UTXO owner, then these conditions are not that different to the 
requirement of having range proofs attached to UTXOs, which require that the value of Tari commitments is non-negative.</p>
<p>This argument is independent of the nature of the additional restrictions. Specifically, if these restrictions are
manifested as a script that provides additional constraints over whether a UTXO may be spent, the same arguments apply.</p>
<p>This means that in a very hand-wavy sort of way, there ought to be no reason that TariScript is not workable.</p>
<p>Note that range proofs can be discarded after a UTXO is spent. This entails that the global security guarantees of
Mimblewimble is not that every transaction in history was valid from an inflation perspective, but that the net effect
of all transactions leads to zero spurious inflation. This sounds worse than it is, since locally, every individual
transaction is checked for validity at the time of inclusion in the blockchain.</p>
<p>If it somehow happened that two illegal transactions made it into the blockchain (perhaps due to a bug), and the two
cancelled each other out such that the global coin supply was still correct, one would never know this when doing a
chain synchronisation in pruned mode.</p>
<p>But if there was a steady inflation bug due to invalid range proofs making it into the blockchain, a pruned mode sync
would still detect that <em>something</em> was awry, because the global coin supply balance acts as another check.</p>
<p>With TariScript, once the script has been pruned away, and then there is a re-org to an earlier point on the chain,
then there's no way to ensure that the script was honoured unless you run an archival node.</p>
<p>This is broadly in keeping with the Mimblewimble security guarantees that, in pruned-mode synchronisation, individual 
transactions are not necessarily verified during chain synchronisation.</p>
<p>However, the guarantee that no additional coins are created or destroyed remains intact.</p>
<p>Put another way, the blockchain relies on the network <em>at the time</em> to enforce the TariScript spending rules. 
This means that the scheme may be susceptible to certain <em>horizon attacks</em>.</p>
<p>Incidentally, a single honest archival node would be able to detect any fraud on the same chain and provide a simple 
proof that a transaction did not honour the redeem script.</p>
<h3 id="additional-requirements"><a class="header" href="#additional-requirements">Additional requirements</a></h3>
<p>The assumptions that broadly equate scripting with range proofs in the above argument are:</p>
<ul>
<li>The script must be committed to the blockchain.</li>
<li>The script must not be malleable in any way without invalidating the transaction. This restriction extends to all 
participants, including the UTXO owner.</li>
<li>We must be able to prove that the UTXO originator provides the script and no one else.</li>
<li>The scripts and their redeeming inputs must be stored on the blockchain. In particular, the input data must not be
malleable.</li>
</ul>
<h3 id="preventing-cut-through"><a class="header" href="#preventing-cut-through">Preventing Cut-through</a></h3>
<p>A major issue with many Mimblewimble extension schemes is that miners are able to cut-through UTXOs if an output is 
spent in the same block it was created. This makes it so that the intervening UTXO never existed; along with any checks 
and balances carried in that UTXO. It's also impossible to prove without additional information that cut-through even 
occurred (though one may suspect, since the &quot;one&quot; transaction would contribute two kernels to the block).</p>
<p>In particular, cut-through is devastating for an idea like TariScript which relies on conditions present in the UTXO 
being enforced. For example, say there is a UTXO in the mempool that everyone knows the blinding factor to, but is 
restricted to a single public key via the TariScript. A malicious user can spend the UTXO in a zero-conf transaction, 
and send the cut-through transaction to the mempool. Since the miner only sees the resulting aggregate transaction, it 
cannot know that there was a TariScript on the removed UTXO. The solution to this problem is described later in this RFC.</p>
<p>In contrast, range proofs are still valid if they are cut-through, because the resulting UTXOs must have 
valid range proofs. </p>
<h2 id="protocol-additions"><a class="header" href="#protocol-additions">Protocol additions</a></h2>
<p>Please refer to <a href="#notation">Notation</a>, which provides important pre-knowledge for the remainder of the report.</p>
<p>At a high level, TariScript works as follows:</p>
<ul>
<li>The spending <em>script</em> \((\script)\) is recorded in the transaction UTXO.</li>
<li>Although scripts are included on the UTXO, they are only executed when the UTXO is <strong>spent</strong>, and in most cases, will 
require additional input data to be provided at this time. </li>
<li>The <em>script input data</em> is recorded in the transaction inputs.</li>
<li>When validating a transaction, the <em>script</em> is executed using the <em>script input data</em>.</li>
<li>After the <em>script</em> \((\script)\) is executed, the execution stack must contain exactly one value that will be 
interpreted as the <em><a href="Glossary.html#script-keypair">script public key</a></em> \((K_{S})\). </li>
<li>The <em><a href="Glossary.html#script-keypair">script public key</a></em> and commitment must match the <em>script signature</em> on the input, which prevents malleability 
of the data in the input.</li>
<li>To prevent a script from being removed from a UTXO, a new field  <em><a href="Glossary.html#sender-offset-keypair">sender offset</a> public key</em> \((K_{O})\) has been 
added.</li>
<li>The <em>sender offset private keys</em> \((k_{O})\) and <em>script private keys</em> \((k_{S})\) are used in conjunction to 
create a <em>script offset</em> \((\so)\), which are used in the consensus balance to prevent a number of attacks.</li>
</ul>
<blockquote>
<p>NOTE: One can prove ownership of a UTXO by demonstrating knowledge of both the commitment <em>blinding factor</em> \((k\)), 
<em>and</em> the <em><a href="Glossary.html#script-keypair">script private key</a></em> \((k_{S})\) for a valid script input.</p>
</blockquote>
<h3 id="utxo-data-commitments"><a class="header" href="#utxo-data-commitments">UTXO data commitments</a></h3>
<p>The script, as well as other UTXO metadata, such as the output features are signed for with the <a href="Glossary.html#sender-offset-keypair">sender offset</a> private 
key to prevent malleability. As we will describe later, the notion of a <a href="Glossary.html#script-offset">script offset</a> is introduced to prevent 
cut-through and forces the preservation of these commitments until they are recorded into the blockchain.</p>
<h3 id="transaction-output"><a class="header" href="#transaction-output">Transaction output</a></h3>
<p>The definition of a Tari transaction output is:</p>
<pre><code class="language-rust ignore">pub struct TransactionOutput {
    /// The transaction output version
    version: TransactionOutputVersion,
    /// Options for an output's structure or use
    features: OutputFeatures,
    /// The homomorphic commitment representing the output amount
    commitment: Commitment,
    /// A proof that the commitment is in the right range
    proof: RangeProof,
    /// The serialised script
    script: Vec&lt;u8&gt;,
    /// The sender offset pubkey, K_O
    sender_offset_public_key: PublicKey
    /// UTXO signature signing the transaction output data and the homomorphic commitment with a combination 
    /// of the homomorphic commitment private values (amount and blinding factor) and the sender offset private key.
    metadata_signature: CommitmentAndPublicKeySignature,
    /// The covenant that will be executed when spending this output
    covenant: Covenant,
    /// The encrypted commitment value.
    encrypted_value: EncryptedValue,
    /// The minimum value of the commitment that is proven by the range proof
    minimum_value_promise: MicroTari,
}</code></pre>
<p>The <a href="Glossary.html#metadata-signature">metadata signature</a> is a <a href="Glossary.html#commitment-and-public-key-signature">CAPK signature</a> (as described in <a href="./RFC-0182_CommitmentSignatures.html">RFC-0182</a>) signed with 
the commitment value, \( v_i \), known by the sender and receiver, the spending key, \( k_i \), known by the 
receiver and the sender offset private key, \(k_{Oi}\), known by the sender. (<em>Note that \( k_{Oi} \) should be 
treated as a nonce.</em>) The CAPK signature is effectively an aggregated CAPK signature between the sender and receiver, 
and the challenge consists of all the transaction output metadata, effectively forming a contract between the sender and 
receiver, making all those values non-malleable and ensuring only the sender and receiver can enter into this contract.</p>
<p>For purposes of this RFC, we denote the metadata signature terms as follows:</p>
<ul>
<li>\( R_{MRi} \) is the ephemeral commitment, </li>
<li>\( R_{MSi} \) is the ephemeral public key, </li>
<li>\( a_{MRi} \) and \( b_{MRi} \) are the first and second commitment signature scalars,</li>
<li>\( b_{MSi} \) is the public key signature scalar. </li>
</ul>
<p><u>Sender:</u></p>
<p>The sender's ephemeral public key is:</p>
<p>$$
\begin{aligned}
R_{MSi} &amp;= r_{MSi_b} \cdot G
\end{aligned}
\tag{3}
$$</p>
<p>The sender sends \( (K_{Oi}, R_{MSi}) \) along with the other partial transaction information 
\( (\script_i, F_i) \) to the receiver, who now has all the required information to calculate the final challenge.</p>
<p><u>Reciver:</u></p>
<p>The commitment definition is unchanged:</p>
<p>$$
\begin{aligned}
C_i = v_i \cdot H  + k_i \cdot G
\end{aligned}
\tag{4}
$$</p>
<p>The receiver's ephemeral commitment is:</p>
<p>$$
\begin{aligned}
R_{MRi} &amp;= r_{MRi_a} \cdot H + r_{MRi_b} \cdot G
\end{aligned}
\tag{5}
$$</p>
<p>The final challenge is:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{ R_{MSi} \cat R_{MRi} \cat \script_i \cat F_i \cat K_{Oi} \cat C_i \cat \pi_i \cat \varphi_i \cat \vartheta_i } \\
\end{aligned}
\tag{6}
$$</p>
<p>The receiver can now calculate their portion of the aggregated CAPK signature as:</p>
<p>$$
\begin{aligned}
a_{MRi} &amp;= r_{MRi_a} + e \cdot v_{i} \\
b_{MRi} &amp;= r_{MRi_b} + e \cdot k_i
\end{aligned}
\tag{7}
$$</p>
<p>The receiver sends \( s_{MRi} = (a_{MRi}, b_{MRi}, R_{MRi} ) \) along with the other partial transaction information
\( (C_i) \) to the sender.</p>
<p><u>Sender:</u></p>
<p>The sender starts by calculating the final challenge \( e \) (6) and then completes their part of the aggregated CAPK 
signature.</p>
<p>$$
\begin{aligned}
b_{MSi} &amp;= r_{MSi_b} + e \cdot k_{Oi}
\end{aligned}
\tag{8}
$$</p>
<p>The final CAPK signature is combined as follows:</p>
<p>$$
\begin{aligned}
s_{Mi} = (a_{MRi}, b_{MRi}, R_{MRi}, b_{MSi}, R_{MSi} )
\end{aligned}
\tag{9}
$$</p>
<p><u>Verifier:</u></p>
<p>This is verified by the following:</p>
<p>$$
\begin{aligned}
a_{MRi} \cdot H + b_{MRi} \cdot G &amp;\overset{?}{=} R_{MRi} + e \cdot C \\
b_{MSi} \cdot G &amp;\overset{?}{=} R_{MSi} + e \cdot K_{Oi}
\end{aligned}
\tag{10}
$$</p>
<p>Note that:</p>
<ul>
<li>The UTXO has a positive value \( v \) like any normal UTXO.</li>
<li>The script and the output features can no longer be changed by the miner or any other party. This includes the sender 
and receiver; they would need to cooperate to enter into a new contract to change any metadata, otherwise, the 
metadata signature will be invalidated.</li>
<li>We provide the complete script on the output.</li>
</ul>
<h3 id="transaction-input"><a class="header" href="#transaction-input">Transaction input</a></h3>
<p>In standard Mimblewimble, an input is the same as an output <em>sans</em> range proof. The range proof doesn't need to be 
checked again when spending inputs, so it is dropped. </p>
<p>The definition of a Tari transaction input is:</p>
<pre><code class="language-rust ignore">pub struct TransactionInput {
    /// The transaction input version
    version: TransactionInputVersion,
    /// The output that will be spent that this input is referencing 
    spent_output: SpentOutput {
        /// The transaction output version
        version: TransactionOutputVersion,
        /// Options for an output's structure or use
        features: OutputFeatures,
        /// The homomorphic Pedersen commitment representing the output amount
        commitment: Commitment,
        /// The serialised script
        script: Vec&lt;u8&gt;,
        /// The sender offset pubkey, K_O
        sender_offset_public_key: PublicKey
        /// The covenant that will be executed when spending this output
        covenant: Covenant,
        /// The encrypted commitment value.
        encrypted_value: EncryptedValue,
        /// The minimum value of the commitment that is proven by the range proof
        minimum_value_promise: MicroTari,
    }
    /// The script input data, if any
    input_data: Vec&lt;u8&gt;,
    /// Signature signing the script, input data, [script public key], and the homomorphic commitment with a combination 
    /// of the homomorphic commitment private values (amount and blinding factor) and the [script private key].
    script_signature: CommitmentAndPubKeySignature,
}</code></pre>
<p>The <a href="Glossary.html#script-signature">script signature</a> is a <a href="Glossary.html#commitment-and-public-key-signature">CAPK signature</a>  using a combination of the output commitment private values 
\( (v_i \, , \, k_i )\) and <a href="Glossary.html#script-keypair">script private key</a> \(k_{Si}\) to prove ownership thereof. It signs the script, 
the script input, <a href="Glossary.html#script-keypair">script public key</a>, and the commitment.</p>
<p>For purposes of this RFC, we denote the script signature terms as follows:</p>
<ul>
<li>\( R_{SCi} \) is the ephemeral commitment,</li>
<li>\( R_{SPi} \) is the ephemeral public key,</li>
<li>\( a_{SCi} \) and \( b_{SCi} \) are the first and second commitment signature scalars,</li>
<li>\( b_{SPi} \) is the public key signature scalar.</li>
</ul>
<p><u>Sender:</u></p>
<p>The script signature is given by</p>
<p>$$
\begin{aligned}
s_{Si} = (a_{SCi}, b_{SCi}, R_{SCi}, b_{SPi}, R_{SPi} )
\end{aligned}
\tag{11}
$$</p>
<p>where</p>
<p>$$
\begin{aligned}
R_{SCi} &amp;= r_{SCi_a} \cdot H + r_{SCi_b} \cdot G \\
a_{SCi}  &amp;= r_{SCi_a} +  e \cdot v_i \\
b_{SCi} &amp;= r_{SCi_b} +  e \cdot k_i \\
R_{SPi} &amp;= r_{SPi_b} \cdot G \\
b_{SPi} &amp;= r_{SPi_b} +  e \cdot k_{Si} \\
\end{aligned}
\tag{12}
$$</p>
<p>with the challenge being</p>
<p>$$
\begin{aligned}
e &amp;= \hash{ R_{SCi} \cat R_{SPi} \cat \alpha_i \cat \input_i \cat K_{Si} \cat C_i} \\
\end{aligned}
\tag{13}
$$</p>
<p><u>Verifier:</u></p>
<p>This is verified by the following:</p>
<p>$$
\begin{aligned}
a_{SCi} \cdot H + b_{SCi} \cdot G &amp;\overset{?}{=} R_{SCi} + e \cdot C \\
b_{SPi} \cdot G &amp;\overset{?}{=} R_{SPi} + e \cdot K_{Si}
\end{aligned}
\tag{14}
$$</p>
<p>The script public key \(K_{Si}\) needed for the script signature verification is not stored with the 
TransactionInput, but obtained by executing the script with the provided input data. Because this signature is signed 
with the script private key \(k_{Si}\), it ensures that only the owner can provide the input data \(\input_i\) to 
the TransactionInput. </p>
<h3 id="script-offset"><a class="header" href="#script-offset">Script Offset</a></h3>
<p>For every transaction, an accompanying <a href="Glossary.html#script-offset">script offset</a> \( \so \) needs to be provided. This is there to prove that every<br />
script public key \( K_{Sj} \) and every sender offset public key \( K_{Oi} \) supplied with the UTXOs are the 
correct ones. The sender will know and provide sender offset private keys \(k_{Oi} \) and script private keys 
\(k_{Si} \); these are combined to create the script offset \( \so \), which is calculated as follows:</p>
<p>$$
\begin{aligned}
\so = \sum_j\mathrm{k_{Sj}} - \sum_i\mathrm{k_{Oi}} \; \text{for each input}, j,\, \text{and each output}, i
\end{aligned}
\tag{15}
$$</p>
<p>Verification of (15) will entail:</p>
<p>$$
\begin{aligned}
\so \cdot G = \sum_j\mathrm{K_{Sj}} - \sum_i\mathrm{K_{Oi}} \; \text{for each input}, j,\, \text{and each output}, i
\end{aligned}
\tag{16}
$$</p>
<p>We modify the transactions to be:</p>
<pre><code class="language-rust ignore">pub struct Transaction {
    
    ...
    
    /// A scalar offset that links outputs and inputs to prevent cut-through, enforcing the correct application of
    /// the output script.
    pub script_offset: BlindingFactor,
}</code></pre>
<p>All script offsets (\(\so\)) from (15) contained in a block are summed together to create a total <a href="Glossary.html#script-offset">script offset</a> (17) 
so that algorithm (15) still holds for a block.</p>
<p>$$
\begin{aligned}
\so_{total} = \sum_k\mathrm{\so_{k}}\; \text{for every transaction}, k
\end{aligned}
\tag{17}
$$</p>
<p>Verification of (17) will entail:</p>
<p>$$
\begin{aligned}
\so_{total} \cdot G = \sum_j\mathrm{K_{Sj}} - \sum_i\mathrm{K_{Oi}} \; \text{for each input}, j,\, \text{and each output}, i
\end{aligned}
\tag{18}
$$</p>
<p>As can be seen, all information required to verify (17) is contained in a block's inputs and outputs. One important 
distinction to make is that the Coinbase output in a coinbase transaction does not count toward the script offset. 
This is because the Coinbase UTXO already has special rules accompanying it and it has no input, thus we cannot generate 
a script offset \( \so \). The coinbase output can allow any script \(\script_i\) and sender offset public key 
\( K_{Oi} \) as long as it does not break any of the rules in <a href="RFC-0120_Consensus.html">RFC 120</a> and the script is 
honored at spend. If the coinbase is used as an input, it is treated exactly the same as any other input.</p>
<p>We modify Blockheaders to be:</p>
<pre><code class="language-rust ignore">pub struct BlockHeader {
    
    ...
    
    /// Sum of script offsets for all kernels in this block.
    pub total_script_offset: Scalar,
}</code></pre>
<p>This notion of the script offset \(\so\) means that no third party can remove any input or output from a 
transaction or the block, as that will invalidate the script offset balance equation, either (16) or (18) depending on 
whether the scope is a transaction or block. It is important to know that this also stops 
<a href="#cut-through">cutâ€‘through</a> so that we can verify all spent UTXO scripts. Because the script private key and<br />
sender offset private key are not publicly known, it's impossible to create a new script offset.</p>
<p>Certain scripts may allow more than one valid set of input data. Users might be led to believe that this will allow a 
third party to change the script keypair \((k_{Si}\),\(K_{Si})\). If an attacker can change the \(K_{Si}\) 
keys of the input then he can take control of the \(K_{Oi}\) as well, allowing the attacker to change the metadata of 
the UTXO including the script. But as shown in <a href="#script-offset-security">Script offset security</a>, this is not possible.</p>
<p>If equation (16) or (18) balances then we know that each included input and output in the transaction or block has its 
correct script public key and sender offset public key. Signatures (9) &amp; (11) are checked independently from script 
offset verification (16) and (18), and looked at in isolation those could verify correctly but can still be signed by 
fake keys. When doing verification in (16) and (18) you know that the signatures and the message/metadata signed by the 
private keys can be trusted.</p>
<h3 id="consensus"><a class="header" href="#consensus">Consensus</a></h3>
<p>TariScript does not impact the Mimblewimble balance for blocks and transactions, however, an additional consensus rule for 
transaction and block validation is required.</p>
<p>Verify that for every valid transaction or block:</p>
<ol>
<li>The <a href="Glossary.html#metadata-signature">metadata signature</a> \( s_{Mi} \) is valid for every output.</li>
<li>The script executes successfully using the given input script data.</li>
<li>The result of the script is a valid script public key, \( K_S \).</li>
<li>The script signature, \( s_{Si} \), is valid for every input.</li>
<li>The script offset is valid for every transaction and block.</li>
</ol>
<h3 id="preventing-cut-through-with-the-script-offset"><a class="header" href="#preventing-cut-through-with-the-script-offset">Preventing Cut-through with the Script Offset</a></h3>
<p>Earlier, we described that cut-through must be prevented; this is achieved by the script offset. It mathematically links 
all inputs and outputs of all the transactions in a block and that tallied up creates the script offset. Providing the 
script offset requires knowledge of keys that miners do not possess; thus they are unable to produce the necessary 
script offset when attempting to perform cut-through on a pair of transactions.</p>
<p>Let's show by example how the script offset stops cut-through, where Alice spends to Bob who spends to Carol. Ignoring 
fees, we have: </p>
<p>$$
C_a \Rightarrow  C_b \Rightarrow  C_c
$$</p>
<p>For these two transactions, the total script offset is calculated as follows:</p>
<p>$$
\begin{aligned}
\so_1 = k_{Sa} - k_{Ob}\\
\so_2 = k_{Sb} - k_{Oc}\\
\end{aligned}
\tag{19}
$$</p>
<p>$$
\begin{aligned}
\so_t = \so_1 + \so_2 =  (k_{Sa} + k_{Sb}) - (k_{Ob} + k_{Oc})\\
\end{aligned}
\tag{20}
$$</p>
<p>In standard Mimblewimble <a href="https://tlu.tarilabs.com/protocols/grin-protocol-overview/MainReport.html#cut-through">cut-through</a> can be applied to get:</p>
<p>$$
C_a \Rightarrow  C_c
$$</p>
<p>After cut-through the total script offset becomes: </p>
<p>$$
\begin{aligned}
\so'_t = k_{Sa} - k_{Oc}\\
\end{aligned}
\tag{21}
$$</p>
<p>As we can see:</p>
<p>$$
\begin{aligned}
\so_t\ \neq \so'_t \\
\end{aligned}
\tag{22}
$$</p>
<p>A third party cannot generate a new script offset as only the original owner can provide the script private key 
\(k_{Sa}\) to create a new script offset. </p>
<h3 id="script-offset-security"><a class="header" href="#script-offset-security">Script offset security</a></h3>
<p>If all the inputs in a transaction or a block contain scripts such as just <code>NOP</code> or <code>CompareHeight</code> commands, then the 
hypothesis is that it is possible to recreate a false script offset. Let's show by example why this is not possible. In 
this Example we have Alice who pays Bob with no change output:</p>
<p>$$
C_a \Rightarrow  C_b
$$</p>
<p>Alice has an output \(C_{a}\) which contains a script that only has a <code>NOP</code> command in it. This means that the 
script \( \script_a \) will immediately exit on execution leaving the entire input data \( \input_a \)on the 
stack. She sends all the required information to Bob as per the <a href="#standard-mw-transaction">standard mw transaction</a>, who 
creates an output \(C_{b}\). Because of the <code>NOP</code> script \( \script_a \), Bob can change the script public key 
\( K_{Sa}\) contained in the input data. Bob can now use his own \(k'_{Sa}\) as the script private key. He 
replaces the sender offset public key with his own \(K'_{Ob}\) allowing him to change the script 
\( \script_b \) and generate a new signature as in (9). Bob can now generate a new script offset with 
\(\so' = k'_{Sa} - k'_{Ob} \). Up to this point, it all seems valid. No one can detect that Bob changed the script 
to \( \script_b \).</p>
<p>But what Bob also needs to do is generate the signature in (13). For this signature, Bob needs to know 
\(k_{Sa}, k_a, v_a\). Because Bob created a fake script private key, and there is no change in this transaction, 
he does know the script private key and the value. But Bob does not know the blinding factor \(k_a\) of Alice's 
commitment and thus cannot complete the signature in (13). Only the rightful owner of the commitment, which in 
Mimblewimble terms is the person who knows \( k_a, v_a\), and can generate the signature in (13).</p>
<h3 id="script-lock-key-generation"><a class="header" href="#script-lock-key-generation">Script lock key generation</a></h3>
<p>At face value, it looks like the burden for wallets has tripled, since each UTXO owner has to remember three private 
keys, the spend key, \( k_i \), the sender offset key \( k_{O} \), and the script key \( k_{S} \). In practice, the 
script key will often be a static key associated with the user's node or wallet. Even if it is not, the script and 
sender offset keys can be deterministically derived from the spend key. For example, \( k_{S} \) could be 
\( \hash{ k_i \cat \alpha} \).</p>
<h3 id="blockchain-bloat"><a class="header" href="#blockchain-bloat">Blockchain bloat</a></h3>
<p>The most obvious drawback to TariScript is the effect it has on blockchain size. UTXOs are substantially larger,
with the addition of the script, metadata signature, script signature, and a public key to every output.</p>
<p>These can eventually be pruned but will increase storage and bandwidth requirements.</p>
<p>The input size of a block is much bigger than in standard Mimblewimble, whereas it would only be a commitment and output 
features. In Tari, each input includes a script, input_data, the script signature, and an extra public key. This could be 
compacted by just broadcasting input hashes along with the missing script input data and signature, instead of the full 
input in a transaction message, but this will still be larger than standard Mimblewimble inputs.</p>
<p>In Tari, every header is also bigger as it includes an extra blinding factor that cannot be pruned away.</p>
<h3 id="fodder-for-chain-analysis"><a class="header" href="#fodder-for-chain-analysis">Fodder for chain analysis</a></h3>
<p>Another potential drawback of TariScript is the additional information that is handed to entities wishing to perform 
chain analysis. Having scripts attached to outputs will often clearly mark the purpose of that UTXO. Users may wish to 
re-spend outputs into vanilla, default UTXOs in a mixing transaction to disassociate Tari funds from a particular 
script.</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>Where possible, the &quot;usual&quot; notation is used to denote terms commonly found in cryptocurrency literature. Lowercase 
characters are used as private keys, while uppercase characters are used as public keys. New terms introduced by 
TariScript are assigned Greek lowercase letters in most cases. </p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Definition</th></tr></thead><tbody>
<tr><td>\( \script_i \)</td><td>An output script for output <em>i</em>, serialised to binary.</td></tr>
<tr><td>\( F_i \)</td><td>Output features for UTXO <em>i</em>.</td></tr>
<tr><td>\( f_t \)</td><td>Transaction fee for transaction <em>t</em>.</td></tr>
<tr><td>\( (k_{Oi}, K_{Oi}) \)</td><td>The private - public keypair for the UTXO sender offset key. Note that \( k_{Oi} \) should be treated as a nonce.</td></tr>
<tr><td>\( (k_{Si}, K_{Si}) \)</td><td>The private - public keypair for the script key. The script, \( \script_i \) resolves to \( K_S \) after completing execution.</td></tr>
<tr><td>\( \so_t \)</td><td>The script offset for transaction <em>t</em>, see (15)</td></tr>
<tr><td>\( C_i \)</td><td>A Pedersen commitment to a value \( v_i \), see (4)</td></tr>
<tr><td>\( \input_i \)</td><td>The serialised input for script \( \script_i \)</td></tr>
<tr><td>\( \pi_i \)</td><td>The covenant for UTXO <em>i</em>.</td></tr>
<tr><td>\( \varphi_i \)</td><td>The encrypted value for UTXO <em>i</em>.</td></tr>
<tr><td>\( \vartheta_i \)</td><td>The minimum value promise for UTXO <em>i</em>.</td></tr>
<tr><td>\( s_{Si} \)</td><td>A script signature for output \( i \), see (11 - 13). Additionally, the capital letter subscripts, <em>C</em> and <em>P</em> refer to the <em>ephemeral commitment</em> and <em>ephemeral public key</em> portions respectively (example \( s_{SCi}, s_{SPi} \)) .</td></tr>
<tr><td>\( s_{Mi} \)</td><td>A metadata signature for output \( i \), see (3 - 10). Additional the capital letter subscripts, <em>R</em> and <em>S</em> refer to a UTXO <em>receiver</em> and <em>sender</em> respectively (exmple \( s_{MRi}, s_{MSi} \)) .</td></tr>
</tbody></table>
</div>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<ul>
<li><a href="https://github.com/CjS77">@CjS77</a></li>
<li><a href="https://github.com/hansieodendaal">@hansieodendaal</a></li>
<li><a href="https://github.com/philipr-za">@philipr-za</a> </li>
<li><a href="https://github.com/SWvheerden">@SWvheerden</a></li>
</ul>
<p>Thanks to David Burkett for proposing a method to prevent cut-through and willingness to discuss ideas.</p>
<h1 id="change-log"><a class="header" href="#change-log">Change log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 Aug 2020</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">11 Feb 2021</td><td style="text-align: left">Major update</td><td style="text-align: left">CjS77, SWvheerden, philipr-za</td></tr>
<tr><td style="text-align: left">26 Apr 2021</td><td style="text-align: left">Clarify one sided payment rules</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">31 May 2021</td><td style="text-align: left">Including full script in transaction outputs</td><td style="text-align: left">philipr-za</td></tr>
<tr><td style="text-align: left">04 Jun 2021</td><td style="text-align: left">Remove beta range-proof calculation</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">22 Jun 2021</td><td style="text-align: left">Change script_signature type to ComSig</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">30 Jun 2021</td><td style="text-align: left">Clarify Tari Script nomenclature</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">06 Oct 2022</td><td style="text-align: left">Minor improvements in legibility</td><td style="text-align: left">stringhandler</td></tr>
<tr><td style="text-align: left">11 Nov 2022</td><td style="text-align: left">Update ComAndPubSig and move out examples</td><td style="text-align: left">stringhandler</td></tr>
<tr><td style="text-align: left">22 Nov 2022</td><td style="text-align: left">Added <code>metadata_signature</code> and <code>script_signature</code> math</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">06 Apr 2023</td><td style="text-align: left">Grammar and spelling changes</td><td style="text-align: left">SWvheerden</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="BaseLayerExtensions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="RFC-0202_TariScriptOpcodes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a href="BaseLayerExtensions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a href="RFC-0202_TariScriptOpcodes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <script src=" https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js "></script>
        <script>mermaid.initialize({startOnLoad:true});</script>

        <!-- Custom JS scripts -->


    </body>
</html>
