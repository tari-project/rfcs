<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Tari Network: RFC library</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Tari network RFC library and documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
            }
          });
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0Q69T0B1T4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-0Q69T0B1T4');
        </script>

    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = 'light';
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <img src="theme/images/tari-splash.png" class="tlu">

            <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About the Tari RFC documents</a></li><li class="chapter-item expanded "><a href="RFC-0001_overview.html"><strong aria-hidden="true">1.</strong> RFC-0001: An overview of the Tari network</a></li><li class="chapter-item expanded "><a href="base_layer.html"><strong aria-hidden="true">2.</strong> The Tari Base Layer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0110_BaseNodes.html"><strong aria-hidden="true">2.1.</strong> RFC-0110: Base nodes</a></li><li class="chapter-item expanded "><a href="RFC-0111_BaseNodeArchitecture.html"><strong aria-hidden="true">2.2.</strong> RFC-0111: Base node architecture</a></li><li class="chapter-item expanded "><a href="RFC-0120_Consensus.html"><strong aria-hidden="true">2.3.</strong> RFC-0120: Consensus rules</a></li><li class="chapter-item expanded "><a href="RFC-0131_Mining.html"><strong aria-hidden="true">2.4.</strong> RFC-0131: Mining</a></li><li class="chapter-item expanded "><a href="RFC-0132_Merge_Mining_Monero.html"><strong aria-hidden="true">2.5.</strong> RFC-0132: Merge Mining Monero</a></li><li class="chapter-item expanded "><a href="RFC-0140_Syncing_and_seeding.html"><strong aria-hidden="true">2.6.</strong> RFC-0140: Synchronizing the Blockchain: Archival and Pruned modes</a></li><li class="chapter-item expanded "><a href="RFC-0150_Wallets.html"><strong aria-hidden="true">2.7.</strong> RFC-0150: Wallets</a></li><li class="chapter-item expanded "><a href="RFC-0155_TariAddress.html"><strong aria-hidden="true">2.8.</strong> RFC-0155: TariAddress</a></li><li class="chapter-item expanded "><a href="RFC-0160_BlockSerialization.html"><strong aria-hidden="true">2.9.</strong> RFC-0160: Block Binary Serialization</a></li><li class="chapter-item expanded "><a href="RFC-0170_NetworkCommunicationProtocol.html"><strong aria-hidden="true">2.10.</strong> RFC-0170: Network Communication Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0171_MessageSerialisation.html"><strong aria-hidden="true">2.10.1.</strong> RFC-0171: Message Serialisation</a></li><li class="chapter-item expanded "><a href="RFC-0172_PeerToPeerMessagingProtocol.html"><strong aria-hidden="true">2.10.2.</strong> RFC-0172: Peer to Peer Messaging Protocol</a></li><li class="chapter-item expanded "><a href="RFC-0173_Versioning.html"><strong aria-hidden="true">2.10.3.</strong> RFC-0173: Versioning</a></li><li class="chapter-item expanded "><a href="RFC-0174_Chat_Metadata.html"><strong aria-hidden="true">2.10.4.</strong> RFC-0174: Chat Metadata</a></li></ol></li><li class="chapter-item expanded "><a href="RFC-0181_BulletproofsPlus.html"><strong aria-hidden="true">2.11.</strong> RFC-0181: Bulletproofs+ range proving</a></li><li class="chapter-item expanded "><a href="RFC-0182_CommitmentSignatures.html"><strong aria-hidden="true">2.12.</strong> RFC-0182: Commitment signatures</a></li><li class="chapter-item expanded "><a href="RFC-0190_Mempool.html"><strong aria-hidden="true">2.13.</strong> RFC-0190: Mempool</a></li><li class="chapter-item expanded "><a href="BaseLayerExtensions.html"><strong aria-hidden="true">2.14.</strong> Tari-specific extensions to Mimblewimble</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0201_TariScript.html"><strong aria-hidden="true">2.14.1.</strong> RFC-0201: TariScript</a></li><li class="chapter-item expanded "><a href="RFC-0202_TariScriptOpcodes.html"><strong aria-hidden="true">2.14.2.</strong> RFC-0202: TariScript Opcodes</a></li><li class="chapter-item expanded "><a href="RFC-0204_TariScriptExamples.html"><strong aria-hidden="true">2.14.3.</strong> RFC-0204: TariScript Examples</a></li><li class="chapter-item expanded "><a href="RFC-0203_StealthAddresses.html"><strong aria-hidden="true">2.14.4.</strong> RFC-0203: Stealth Addresses</a></li><li class="chapter-item expanded "><a href="RFC-0205_HardwareTransactions.html"><strong aria-hidden="true">2.14.5.</strong> RFC-0205: Hardware Transactions</a></li><li class="chapter-item expanded "><a href="RFC-0250_Covenants.html"><strong aria-hidden="true">2.14.6.</strong> RFC-0250: Covenants</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="RFC-0303_DanOverview.html"><strong aria-hidden="true">3.</strong> RFC-0303: The Tari Digital Assets Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0313_VNRegistration.html"><strong aria-hidden="true">3.1.</strong> RFC-0313: Validator Node Registration</a></li><li class="chapter-item expanded "><a href="RFC-0320_TurbineModel.html"><strong aria-hidden="true">3.2.</strong> RFC-0320: The turbine model</a></li><li class="chapter-item expanded "><a href="RFC-0350_TariVM.html"><strong aria-hidden="true">3.3.</strong> RFC-0350: The Tari Virtual Machine</a></li></ol></li><li class="chapter-item expanded "><a href="RFC-0305_Consensus.html"><strong aria-hidden="true">4.</strong> RFC-0305: The Tari Network Consensus Layer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0314_VNCSelection.html"><strong aria-hidden="true">4.1.</strong> RFC-0314: Validator node committee selection</a></li><li class="chapter-item expanded "><a href="RFC-0321_ProcessingForeignProposals.html"><strong aria-hidden="true">4.2.</strong> RFC-0321: Processing foreign proposals</a></li><li class="chapter-item expanded "><a href="RFC-0325_DanTimeManagement.html"><strong aria-hidden="true">4.3.</strong> RFC-0325: Epochs and time management</a></li><li class="chapter-item expanded "><a href="RFC-0330_Cerberus.html"><strong aria-hidden="true">4.4.</strong> RFC-0330: The Cerberus-Hotstuff consensus algorithm</a></li><li class="chapter-item expanded "><a href="RFC-0331_Indexers.html"><strong aria-hidden="true">4.5.</strong> RFC-0331: Indexers</a></li></ol></li><li class="chapter-item expanded "><a href="proposals.html"><strong aria-hidden="true">5.</strong> Proposals and Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0123_One_sided_replay_attacks.html"><strong aria-hidden="true">5.1.</strong> RFC-0123: Mitigating One-sided payment replay attacks</a></li><li class="chapter-item expanded "><a href="RFC-0141_Sparse_Merkle_Trees.html"><strong aria-hidden="true">5.2.</strong> RFC-0141: Sparse Merkle Tees</a></li><li class="chapter-item expanded "><a href="RFC-0153_StagedWalletSecurity.html"><strong aria-hidden="true">5.3.</strong> RFC-0153: Staged Wallet Security</a></li><li class="chapter-item expanded "><a href="RFC-0154_DeepLinksConvencion.html"><strong aria-hidden="true">5.4.</strong> RFC-0154: Deep links structure convention</a></li><li class="chapter-item expanded "><a href="RFC-0230_HTLC.html"><strong aria-hidden="true">5.5.</strong> RFC-0230: Hash time locked contracts</a></li><li class="chapter-item expanded "><a href="RFC-0240_AtomicSwap.html"><strong aria-hidden="true">5.6.</strong> RFC-0240: Atomic swap</a></li><li class="chapter-item expanded "><a href="RFC-0241_AtomicSwapXMR.html"><strong aria-hidden="true">5.7.</strong> RFC-0241: XMR Atomic swap</a></li><li class="chapter-item expanded "><a href="RFC-0310_SubmarineSwaps.html"><strong aria-hidden="true">5.8.</strong> RFC-0310: Submarine swaps</a></li><li class="chapter-item expanded "><a href="RFC-0388_BearerTokens.html"><strong aria-hidden="true">5.9.</strong> RFC-0388: Bearer tokens</a></li><li class="chapter-item expanded "><a href="RFC-8001_MultiPartyTransactions.html"><strong aria-hidden="true">5.10.</strong> RFC-8001: Multi-party transactions</a></li><li class="chapter-item expanded "><a href="RFC-8002_TransactionProtocol.html"><strong aria-hidden="true">5.11.</strong> RFC-8002: Transaction protocol</a></li><li class="chapter-item expanded "><a href="RFC-8003_TariUseCases.html"><strong aria-hidden="true">5.12.</strong> RFC-8003: Tari Use Cases</a></li><li class="chapter-item expanded "><a href="RFC-0385_StableCoins.html"><strong aria-hidden="true">5.13.</strong> RFC-0385: Privacy-enabled Stablecoin contract design</a></li><li class="chapter-item expanded "><a href="RFC-0323_TariThrottle.html"><strong aria-hidden="true">5.14.</strong> RFC-0323: Tari throttle exploratory analysis</a></li></ol></li><li class="chapter-item expanded "><a href="deprecated.html"><strong aria-hidden="true">6.</strong> Deprecated RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFCD-0010_CodeStructure.html"><strong aria-hidden="true">6.1.</strong> RFC-0010: Tari code structure and organization</a></li><li class="chapter-item expanded "><a href="RFCD-0121_ConsensusEncoding.html"><strong aria-hidden="true">6.2.</strong> RFC-0121: Consensus encoding</a></li><li class="chapter-item expanded "><a href="RFCD-0130_Mining.html"><strong aria-hidden="true">6.3.</strong> RFC-0130: Mining</a></li><li class="chapter-item expanded "><a href="RFCD-0152_EmojiId.html"><strong aria-hidden="true">6.4.</strong> RFCD-0152: Emoji ID</a></li><li class="chapter-item expanded "><a href="RFCD-0180_BulletproofRewinding.html"><strong aria-hidden="true">6.5.</strong> RFC-0180: Bulletproof range proof rewinding</a></li><li class="chapter-item expanded "><a href="RFCD-0300_DAN.html"><strong aria-hidden="true">6.6.</strong> RFC-0300: The Digital Assets Network</a></li><li class="chapter-item expanded "><a href="RFCD-0301_NamespaceRegistration.html"><strong aria-hidden="true">6.7.</strong> RFC-0301: Namespace Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0302_ValidatorNodes.html"><strong aria-hidden="true">6.8.</strong> RFC-0302: Validator Nodes</a></li><li class="chapter-item expanded "><a href="RFCD-0304_VNCommittees.html"><strong aria-hidden="true">6.9.</strong> RFC-0304: Validator Node committee selection</a></li><li class="chapter-item expanded "><a href="RFCD-0306_DANTemplateRegistration.html"><strong aria-hidden="true">6.10.</strong> RFC-0306: DAN Template Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0311_AssetTemplates.html"><strong aria-hidden="true">6.11.</strong> RFC-0311: Digital Asset templates</a></li><li class="chapter-item expanded "><a href="RFCD-0312_DANHighLevelSpecification.html"><strong aria-hidden="true">6.12.</strong> RFC-0312: High level Digital Asset Network Specification</a></li><li class="chapter-item expanded "><a href="RFCD-0322_VNRegistration.html"><strong aria-hidden="true">6.13.</strong> RFC-0322: Validator Node Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0340_VNConsensusOverview.html"><strong aria-hidden="true">6.14.</strong> RFC-0340: Validator Node Consensus</a></li><li class="chapter-item expanded "><a href="RFCD-0341_AssetRegistration.html"><strong aria-hidden="true">6.15.</strong> RFC-0341: Asset registration</a></li><li class="chapter-item expanded "><a href="RFCD-0345_AssetLifeCycle.html"><strong aria-hidden="true">6.16.</strong> RFC-0345: Asset Life cycle</a></li><li class="chapter-item expanded "><a href="RFCD-0360_NFTInvoices.html"><strong aria-hidden="true">6.17.</strong> RFC-0360: NFT sale using MimbleWimble Invoice</a></li><li class="chapter-item expanded "><a href="RFCD-0500_PaymentChannels.html"><strong aria-hidden="true">6.18.</strong> RFC-0500: Tari payment channels</a></li></ol></li><li class="chapter-item expanded "><a href="RFC_template.html"><strong aria-hidden="true">7.</strong> RFC template</a></li><li class="chapter-item expanded "><a href="Glossary.html"><strong aria-hidden="true">8.</strong> Glossary</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                        </div>

                        <h1 class="menu-title"><img src="theme/images/tari-horizontal-logo.png"/> </h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-tari-rfcs"><a class="header" href="#the-tari-rfcs">The Tari RFCs</a></h1>
<p>Tari is a community-driven project. The documents presented in this RFC collection have typically gone through several
iterations before reaching this point:</p>
<ul>
<li>Ideas and questions are posted in #tari-dev on <a href="https://freenode.net/">#FreeNode IRC</a>. This is typically short-form
content with rapid feedback. Often, these conversations will lead to someone posting an <a href="https://github.com/tari-project/tari/issues?q=is%3Aissue+label%3ARFC" title="Tari RFC Issues">issue</a> or RFC <a href="https://github.com/tari-project/tari/pulls?q=is%3Aopen+is%3Apr+label%3ARFC" title="Tari RFC pull requests">pull request</a>.</li>
<li>RFCs are &quot;Requests for Comment&quot;, so although the proposals in these documents are usually well-thought out, they are
not cast in stone. RFCs can, and should, undergo further evaluation and discussion by the community. RFC comments are
best made using Github <a href="https://github.com/tari-project/tari/issues?q=is%3Aissue+label%3ARFC" title="Tari RFC Issues">issue</a>s.</li>
</ul>
<p>New RFC's should follow the format given in the <a href="RFC_template.html">RFC template</a>.</p>
<h2 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h2>
<p>RFCs go through the following lifecycle, which roughly corresponds to the <a href="https://github.com/unprotocols/rfc/blob/master/2/README.md">COSS</a>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Status</th><th style="text-align: left"></th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Draft</td><td style="text-align: left"><img src="theme/images/status-draft.svg" alt="draft" /></td><td style="text-align: left">Changes, additions and revisions can be expected.</td></tr>
<tr><td style="text-align: left">Stable</td><td style="text-align: left"><img src="theme/images/status-stable.svg" alt="stable" /></td><td style="text-align: left">Typographical and cosmetic changes aside, no further changes should be made. Changes to the Tari code base w.r.t. a stable RFC will lead to the RFC becoming out of date, deprecated, or retired.</td></tr>
<tr><td style="text-align: left">Out of date</td><td style="text-align: left"><img src="theme/images/status-outofdate.svg" alt="out of date" /></td><td style="text-align: left">This RFC has become stale due to changes in the code base. Contributions will be accepted to make it stable again if the changes are relatively minor, otherwise it should eventually become deprecated or retired.</td></tr>
<tr><td style="text-align: left">Deprecated</td><td style="text-align: left"><img src="theme/images/status-deprecated.svg" alt="deprecated" /></td><td style="text-align: left">This RFC has been replaced by a newer RFC document, but is still is use in some places and/or versions of Tari.</td></tr>
<tr><td style="text-align: left">Retired</td><td style="text-align: left"><img src="theme/images/status-retired.svg" alt="retired" /></td><td style="text-align: left">The RFC is no longer in use on the Tari network.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0001overview"><a class="header" href="#rfc-0001overview">RFC-0001/Overview</a></h1>
<h2 id="overview-of-tari-network"><a class="header" href="#overview-of-tari-network">Overview of Tari Network</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence"><a class="header" href="#licence">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2018 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language"><a class="header" href="#language">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>The aim of this proposal is to provide a very high-level perspective of the moving parts of the Tari protocol.</p>
<h2 id="related-requests-for-comment"><a class="header" href="#related-requests-for-comment">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0303_DanOverview.html">RFC-0303: Digital asset network</a></li>
<li><a href="RFC-0131_Mining.html">RFC-0131: Tari mining</a></li>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="RFC-0202_TariScriptOpcodes.html">RFC-0202: TariScript Opcodes</a></li>
</ul>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<h3 id="abstract"><a class="header" href="#abstract">Abstract</a></h3>
<p>Tari's aims to be the most <em>useful</em>,  <em>decentralized</em> platform that <em>empowers anyone</em> to create digitally scarce 
things people love.</p>
<p>This statement packages some important concepts.</p>
<p>To be <em>useful</em>, creators and users need to be able to interact with their digital assets in the way that they've 
been accustomed to in Web 2.0. This means that there is a safe, secure, responsive interface between human and the 
machines that manage their information. It means that the user experience is smooth and intuitive. It means that 
the network protocol itself is flexible and capable enough to provide every type of assets creators can 
imagine.</p>
<p>It also <em>scales</em>, so that the entire network does not become a victim of its own success and grind to a halt when more 
than a few hundred people actually try to use it.</p>
<p><em>Decentralisation</em> is central to Tari's philosophy (pun intended). The tape is wearing thin on the newsreel that 
reports yet another centralised custodian, gatekeeper or &quot;authority&quot; becoming a single point of failure. This has 
led to thousands of people losing their crypto-assets, as well as their trust in the ideas of crypto-assets.</p>
<p>Tari has a strong focus on developer experience. The Tari community obsesses over building beautiful, 
clean, intuitive APIs and templates, which lead to beautiful developer tools. The idea is to widen the pool and allow 
<em>anyone</em> to create safe, secure, performant digital assets, rather than provide a gated community of rent-extracting 
&quot;smart-contract developers&quot;.</p>
<p>In general, some of these goals are in direct opposition to each other. Speed, security and decentralisation 
typically form a trilemma that means that you need to settle for two out of the three.</p>
<p>Tari attempts to resolve the dilemma by splitting operations over two discrete layers. Underpinning everything is a 
base layer that focuses on security and manages global state, and a second, 
digital assets layer that focuses on rapid finalisation and scalability.</p>
<h4 id="multiple-layers"><a class="header" href="#multiple-layers">Multiple Layers</a></h4>
<p>The <a href="https://en.wikipedia.org/wiki/CAP_theorem">distributed system trilemma</a> tells us that these requirements are
mutually exclusive.</p>
<p>We can't have fast, cheap digital assets and also highly secure and decentralized currency tokens on a single system.</p>
<p>Tari overcomes this constraint by building two layers:</p>
<ol>
<li>A base layer that provides a public ledger of Tari coin transactions, secured by PoW to maximize security.</li>
<li>A DAN consisting of a highly scalable, efficient side-chain that each manages the state of all digital asset. </li>
</ol>
<p>The DAN layer gives up some security guarantees in exchange for performance. However, in the case of a liveness 
failure (wherein parts of the DAN cannot make progress), the base layer intervenes to break the deadlock and allow 
the DAN to continue.</p>
<h3 id="base-layer"><a class="header" href="#base-layer">Base Layer</a></h3>
<p><a href="RFC-0100_BaseLayer.html">The Tari base layer</a> has the following primary features:</p>
<ul>
<li>PoW-based blockchain using Nakamoto consensus</li>
<li>Transactions and blocks based on the <a href="Glossary.html#mimblewimble">Mimblewimble</a> protocol</li>
</ul>
<p><a href="Glossary.html#mimblewimble">Mimblewimble</a> is a blockchain protocol that offers some key advantages over other <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>-based
cryptocurrencies such as Bitcoin:</p>
<ul>
<li>Transactions are private. This means that casual observers cannot ascertain the amounts being transferred or the
identities of the parties involved.</li>
<li>Mimblewimble has a different set of security guarantees to Bitcoin. The upshot of this is that you can throw away UTXOs
once they are spent and still verify the integrity of the ledger.</li>
<li>Multi-signature transactions can be easily aggregated, making such transactions very compact, and completely hiding
the parties involved, or the fact that there were multiple parties involved at all.</li>
</ul>
<blockquote>
<p>&quot;Mimblewimble is the most sound, scalable 'base layer' protocol we know&quot; -- @fluffypony</p>
</blockquote>
<p>In addition to this, Tari has made some novel additions to the basic Mimblewimble protocol. Primarily, these were 
invented to allow the DAN to be built on top of Tari, but have found some great applications generally:</p>
<ul>
<li>TariScript. Similar to Bitcoin script, TariScript (<a href="RFC-0201_TariScript.html">RFC-201</a>, <a href="RFC-0202_TariScriptOpcodes.html">RFC-202</a>) provides limited &quot;smart contract&quot; 
functionality on the base layer protocol.</li>
<li>One-sided payments. Vanilla Mimblewimble requires both sender and receiver to participate in the creation of 
transactions. It is impossible in <a href="https://www.mwc.mw/">MimblewimbleCoin</a>, for example, to post a &quot;tip jar&quot; address and let people 
unilaterally send you funds. However, this is possible in Tari, thanks to TariScript.</li>
<li>Stealth addresses. Want to allow people to send you funds using one-sided payments without revealing your public 
key (and thus, who you are) to the world? <a href="RFC-0203_StealthAddresses.html">Stealth addresses</a> have you covered.</li>
<li>Covenants. <a href="RFC-0250_Covenants.html">Covenants</a> allow you to construct complex chains of transactions that follow predefined rules.</li>
<li>Burn transactions. Tari offers unequivocal &quot;burn&quot; transactions that render the burnt outputs permanently 
unspendable. This is an important mechanism that underpins the DAN economy. </li>
</ul>
<h4 id="proof-of-work"><a class="header" href="#proof-of-work">Proof of Work</a></h4>
<p>Tari is mined using a hybrid approach. On average, 50% of block rewards come from <a href="RFC-0132_Merge_Mining_Monero.html">Monero merge-mining</a>,
while 50% come from the <a href="RFC-0131_Mining.html">Sha3x</a> algorithm. Blocks are produced every 2 minutes, on average.</p>
<h3 id="the-role-of-the-base-layer"><a class="header" href="#the-role-of-the-base-layer">The role of the base layer</a></h3>
<p>The Base Layer fulfils these, and only these, major roles:</p>
<ol>
<li>It manages and enforces the accounting and consensus rules of the base Tari (XTR) token. This includes standard payments,
and simple smart contracts such as one-sided payments and cross-chain atomic swaps.</li>
<li>It maintains the Validator node register.</li>
<li>Maintain a register of smart contract templates. This allows users to verify that digital assets are running the 
code that they expect and includes functionality like version tracking.</li>
<li>Provides a global reference clock for the digital assets layer to help it resolve certain operational failure modes.</li>
</ol>
<h3 id="digital-assets-network"><a class="header" href="#digital-assets-network">Digital Assets Network</a></h3>
<p>The DAN is focused on achieving high speed and scalability while maintaining a high degree of decentralisation.</p>
<p>The DAN itself is made up of two conceptual levels. On the more fundamental level, the consensus layer uses 
Cerberus and emergent HotStuff to reach consensus on state changes in the DAN in a highly scalable, decentralised way.</p>
<p>A big, and probably the biggest, advantage of this approach is that assets in disparate smart contracts can easily 
interact, without the need for slow, honey pot-shaped bridges. </p>
<p>Then there is the semantic layer, which is where the Tari contracts are compiled, run and verified inside sandboxed 
Tari virtual machines.</p>
<p>Together, these levels provide that smart contract enabled digital assets layer, that we've simply been calling the DAN.</p>
<h3 id="interplay-of-the-layers"><a class="header" href="#interplay-of-the-layers">Interplay of the layers</a></h3>
<p>In general, the base layer knows <em>nothing about the specifics of what is happening on the side-chain</em>. It only cares
that no Tari is created or destroyed, and that the flow of funds in and out of side chains are carried out by the appropriate
authorised agents.</p>
<p>This is by design: the network cannot scale if details of digital asset contracts have to be tracked on the base layer.
We envisage that there could be hundreds of thousands of contracts deployed on Tari. Some of those contracts may be 
enormous;
imagine controlling every piece of inventory and their live statistics for a massively multiplayer online role-playing
game (MMORPG). The base layer is also too slow. If <em>any</em> state relies on base layer transactions being confirmed, there
is an immediate lag before that state change can be considered final, which kills the latency properties we seek for 
the DAN.</p>
<p>It is better to keep the two networks almost totally decoupled from the outset, and allow each network to play to its
strength.</p>
<h1 id="change-log"><a class="header" href="#change-log">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">18 Dec 2018</td><td style="text-align: left">First outline</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">30 Mar 2019</td><td style="text-align: left">First draft v0.0.1</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">19 Jun 2019</td><td style="text-align: left">Propose payment channel layer</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">22 Jun 2021</td><td style="text-align: left">Remove payment channel layer proposal</td><td style="text-align: left">SimianZa</td></tr>
<tr><td style="text-align: left">14 Jan 2022</td><td style="text-align: left">Update image. Expound on Base layer responsibilities</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">10 Nov 2022</td><td style="text-align: left">Update overview for Cerberus</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">09 Dec 2024</td><td style="text-align: left">Update percentage split for merge mining</td><td style="text-align: left">Solivagant</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="the-tari-base-layer"><a class="header" href="#the-tari-base-layer">The Tari Base Layer</a></h1>
<p>The Tari Base Layer network comprises the following major pieces of software:</p>
<ul>
<li>Base Layer full node implementation. The base layer full nodes are the consensus-critical pieces of software for the
Tari base layer and cryptocurrency. The base nodes validate and transmit transactions and blocks, and maintain
consensus about the longest valid proof-of-work blockchain.</li>
<li>Peer-to-peer communications network. All blockchain systems need a messaging mechanism. The Tari project has 
built its own peer-to-peer, end-to-end encrypted, DHT-based communications platform. It utilises the 
<a href="https://noiseprotocol.org/">Noise protocol</a> and <a href="https://www.torproject.org/">Tor</a>  to be highly secure and 
anonymous. Devices behind NATs and firewalls can use Tari's communication tools with ease.</li>
<li>Mining software. Miners perform proof-of-work to secure the base layer and compete to submit the
next valid block into the Tari blockchain. Tari uses two Proof of Work (PoW) algorithms, the first is 
<a href="RFC-0132_Merge_Mining_Monero.html">merge-mined</a> 
with Monero, and the second is the native <a href="RFC-0131_Mining.html">SHA3x</a> algorithm.
The Tari source provides three alternatives for Tari miners:
<ul>
<li>A standalone miner for SHA3 mining</li>
<li>A merge-mining proxy to be used with XMRig to merge mine Tari with Monero</li>
</ul>
</li>
<li>Wallet software. Client software and Application Programming Interfaces (APIs) offering means to construct 
transactions, query nodes for information and maintain personal private keys. The reference design includes a 
wallet library, an C FFI interface, gRPC client and server code, a multi-platform console text-based wallet, and 
Aurora, the mobile wallet. </li>
</ul>
<p>The RFCs in this section go into great describing how the various components work, and how they fit together to 
provide the backbone of the Tari ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0110basenodes"><a class="header" href="#rfc-0110basenodes">RFC-0110/BaseNodes</a></h1>
<h2 id="base-layer-full-nodes-base-nodes"><a class="header" href="#base-layer-full-nodes-base-nodes">Base Layer Full Nodes (Base Nodes)</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>, <a href="https://github.com/SWvheerden">S W van heerden</a> and  <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-1"><a class="header" href="#licence-1">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-1"><a class="header" href="#language-1">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-1"><a class="header" href="#disclaimer-1">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-1"><a class="header" href="#goals-1">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the roles that <a href="Glossary.html#base-node">base node</a>s play in the Tari network as well as 
their general approach for doing so.</p>
<h2 id="related-requests-for-comment-1"><a class="header" href="#related-requests-for-comment-1">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0140_Syncing_and_seeding.html">RFC-0140: SyncAndSeeding</a></li>
</ul>
<p>$$
\newcommand{\so}{\gamma} % script offset
$$</p>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<h3 id="broad-requirements"><a class="header" href="#broad-requirements">Broad Requirements</a></h3>
<p>Tari Base Nodes form a peer-to-peer network for a proof-of-work based blockchain running the <a href="Glossary.html#mimblewimble">Mimblewimble</a>
protocol. The proof-of-work is performed via hybrid mining, that is merge mining with Monero and stand-alone SHA 3. 
Arguments for this design are presented <a href="RFC-0001_overview.html#proof-of-work">in the overview</a>.</p>
<p>Tari Base Nodes MUST carry out the following tasks:</p>
<ul>
<li>validate all <a href="Glossary.html#tari-coin">Tari coin</a> transactions;</li>
<li>propagate valid <a href="Glossary.html#transaction">transaction</a>s to peer nodes;</li>
<li>validate all new <a href="Glossary.html#block">block</a>s received;</li>
<li>propagate validated new blocks to peer nodes;</li>
<li>connect to peer nodes to catch up (sync) with their blockchain state;</li>
<li>provide historical block information to peers that are syncing.</li>
</ul>
<p>Once the Digital Assets Network (DAN) goes live, Base Nodes will also need to support the tasks described in
<a href="RFC-0303_DanOverview.html">RFC-0303_DAN</a>. These requirements may involve but are not limited to:</p>
<ul>
<li>maintain an index of validator node registrations;</li>
</ul>
<p>To carry out these tasks effectively, Base Nodes SHOULD:</p>
<ul>
<li>save the <a href="Glossary.html#blockchain">blockchain</a> into an indexed local database;</li>
<li>maintain an index of all Unspent Transaction Outputs (<a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s);</li>
<li>maintain a list of all pending, valid transactions that have not yet been mined (the <a href="Glossary.html#mempool">mempool</a>);</li>
<li>manage a list of Base Node peers present on the network.</li>
</ul>
<p>Tari Base Nodes MAY implement chain pruning strategies that are features of Mimblewimble, including transaction
<a href="https://tlu.tarilabs.com/protocols/grin-protocol-overview/MainReport.html#mimblewimble-protocol-overview">block compaction techniques</a>.</p>
<p>Tari Base Nodes MAY also implement the following services via an Application Programming Interface (API) to clients:</p>
<ul>
<li>Block queries</li>
<li>Kernel data queries</li>
<li>Transaction queries</li>
<li>Submission of new transactions</li>
</ul>
<p>Such clients may include &quot;light&quot; clients, block explorers, wallets and Tari applications.</p>
<h3 id="transaction-validation-and-propagation"><a class="header" href="#transaction-validation-and-propagation">Transaction Validation and Propagation</a></h3>
<p>Base nodes can be notified of new transactions by:</p>
<ul>
<li>connected peers;</li>
<li>clients via APIs.</li>
</ul>
<p>When a new transaction has been received, it is then passed to the mempool service where it will be 
validated and either stored or rejected.</p>
<p>The transaction is validated as follows:</p>
<ul>
<li>All inputs to the transaction are valid <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s in the <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> set or are outputs in the current block.</li>
<li>No inputs are duplicated.</li>
<li>All inputs are able to be spent (they are not time-locked).</li>
<li>All inputs are signed by their owners.</li>
<li>All outputs have valid <a href="Glossary.html#range-proof">range proof</a>s.</li>
<li>No outputs currently exist in the current <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> set.</li>
<li>The transaction does not have <a href="RFC-0230_HTLC.html#time-locked-contracts">timelocks</a> applied, limiting it from being mined and added to the blockchain before a
specified block height or timestamp has been reached.</li>
<li>The transaction excess has a valid signature.</li>
<li>The <a href="./Glossary.html#transaction-weight">transaction weight</a> does not exceed the maximum permitted in a single block as defined by consensus.</li>
<li>The transaction excess is a valid public key. This proves that:
$$ \Sigma \left( \mathrm{inputs} - \mathrm{outputs} - \mathrm{fees} \right) = 0 $$.</li>
<li>The transaction excess has a unique value across the whole chain.</li>
<li>The <a href="./RFC-0201_TariScript.html">Tari script</a> of each input must execute successfully and return the public key that signs the script signature. </li>
<li>The script offset \( \so\) is calculated and verified as per <a href="./RFC-0201_TariScript.html">RFC-0201_TariScript</a>.</li>
</ul>
<p>Rejected transactions are dropped without service interruption and noted in log files.</p>
<p>Timelocked transactions are rejected by the mempool. The onus is on the client to submit transactions once they are 
able to be spent.</p>
<p><strong>Note:</strong> More detailed information is available in the <a href="RFC-0230_HTLC.html#time-locked-contracts">timelocks</a> RFC document.</p>
<p>Valid transactions are:</p>
<ul>
<li>added to the <a href="Glossary.html#mempool">mempool</a>;</li>
<li>forwarded to peers using the transaction <a href="Glossary.html#broadcaststrategy">BroadcastStrategy</a>.</li>
</ul>
<h4 id="blocktransaction-weight"><a class="header" href="#blocktransaction-weight">Block/Transaction Weight</a></h4>
<p>The weight of a transaction / block measured in &quot;grams&quot;. Input, output and kernel weights reflect their respective relative 
storage and computation cost. Transaction fees are typically proportional to a transaction body's total weight, creating 
incentive to reduce the size of the UTXO set.</p>
<p>With a target block size of <code>S</code> and 1 gram to represent <code>N</code> bytes, we have 
a maximum block weight of <code>S/N</code> grams. </p>
<p>With an <code>S</code> of 1MiB and <code>N</code> of 16, the block and transaction body weights are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Byte size</th><th>Natural Weight</th><th>Adjust</th><th>Final</th></tr></thead><tbody>
<tr><td>Output</td><td></td><td></td><td></td><td></td></tr>
<tr><td>- Per output</td><td>832</td><td>52</td><td>0</td><td>52</td></tr>
<tr><td>- Tari Script</td><td>variable</td><td>size_of(script) / 16</td><td>0</td><td>size_of(script) / 16</td></tr>
<tr><td>- Output Features</td><td>variable</td><td>size_of(features) / 16</td><td>0</td><td>size_of(features) / 16</td></tr>
<tr><td>Input</td><td>169</td><td>11</td><td>-2</td><td>9</td></tr>
<tr><td>Kernel size</td><td>113</td><td>8</td><td>2</td><td>10</td></tr>
</tbody></table>
</div>
<p>Pseudocode: </p>
<pre><code class="language-text">    output_weight = num_outputs * PER_OUTPUT_GRAMS(53)
    foreach output in outputs:
        output_weight += serialize(output.script) / BYTES_PER_GRAM
        output_weight += serialize(output.features) / BYTES_PER_GRAM
        
    input_weight = num_inputs * PER_INPUT_GRAMS(9)
    kernel_weight = num_kernels * PER_KERNEL_GRAMS(10)
    
    weight = output_weight + input_weight + kernel_weight
</code></pre>
<p>where the capitalized values are hard-coded constants.</p>
<h3 id="block-validation-and-propagation"><a class="header" href="#block-validation-and-propagation">Block Validation and Propagation</a></h3>
<p>The block validation and propagation process is analogous to that of transactions. New blocks are received from the 
peer-to-peer network, or from an API call if the Base Node is connected to a Miner.</p>
<p>When a new block is received, it is passed to the block validation service. The validation service checks that:</p>
<ul>
<li>The block has not been processed before.</li>
<li>Every <a href="Glossary.html#transaction">transaction</a> in the block is valid.</li>
<li>The proof-of-work is valid.</li>
<li>The block header is well-formed.</li>
<li>The block is being added to the chain with the highest accumulated proof-of-work.
<ul>
<li>It is possible for the chain to temporarily fork; Base Nodes SHOULD store orphaned forks up to some configured depth.</li>
<li>It is possible that blocks may be received out of order. Base Nodes SHOULD keep blocks that have block heights 
greater than the current chain tip for some preconfigured period.</li>
</ul>
</li>
<li>The sum of all excesses is a valid public key. This proves that:
$$ \Sigma \left( \mathrm{inputs} - \mathrm{outputs} - \mathrm{fees} \right) = 0$$. </li>
<li>That all kernel excess values are unique for that block and the entire chain.</li>
<li>Check if a block contains already spent outputs, reject that block.</li>
<li>The <a href="./RFC-0201_TariScript.html">Tari script</a> of every input must execute successfully and return the public key that signs the script signature.</li>
<li>The script offset \( \so\) is calculated and verified as per <a href="./RFC-0201_TariScript.html">RFC-0201_TariScript</a>.</li>
</ul>
<p>Because Mimblewimble blocks can simply be seen as large transactions with multiple inputs and outputs, the block 
validation service checks all transaction verification on the block as well.</p>
<p>Rejected blocks are dropped silently.</p>
<p>Base Nodes are not obliged to accept connections from any peer node on the network. In particular:</p>
<ul>
<li>Base Nodes MAY refuse connections from peers that have been added to a denylist.</li>
<li>Base Nodes MAY be configured to exclusively connect to a given set of peer nodes.</li>
</ul>
<p>Validated blocks are</p>
<ul>
<li>added to the <a href="Glossary.html#blockchain">blockchain</a>;</li>
<li>forwarded to every connected base node peer using the block flood <a href="Glossary.html#broadcaststrategy">BroadcastStrategy</a>.</li>
</ul>
<p>In addition, when a block has been validated and added to the blockchain:</p>
<ul>
<li>The mempool MUST also remove all transactions that are present in the newly validated block.</li>
<li>The UTXO set MUST be updated by removing all inputs in the block, and adding all the new outputs into it.</li>
</ul>
<h3 id="peer-validation-and-propagation"><a class="header" href="#peer-validation-and-propagation">Peer Validation and Propagation</a></h3>
<p>When a peer attempts to connect or is shared by a trusted peer the base node will perform a peer validation. Ensuring
the peer has a valid id, signature, and peer address before adding or propagating the peer back to the network.</p>
<h3 id="synchronizing-and-pruning-of-the-chain"><a class="header" href="#synchronizing-and-pruning-of-the-chain">Synchronizing and Pruning of the Chain</a></h3>
<p>Syncing and pruning are discussed in detail in <a href="RFC-0140_Syncing_and_seeding.html">RFC-0140</a>.</p>
<h3 id="archival-nodes"><a class="header" href="#archival-nodes">Archival Nodes</a></h3>
<p><a href="Glossary.html#archive-node">Archival nodes</a> are used to keep a complete history of the blockchain since genesis block. They do not employ pruning
at all. These nodes will allow full syncing of the blockchain, because normal nodes will not keep the full history to
enable this. These nodes must sync from another archival node.</p>
<h3 id="pruned-nodes"><a class="header" href="#pruned-nodes">Pruned Nodes</a></h3>
<p><a href="Glossary.html#pruned-node">Pruned nodes</a> take advantage of the cryptography of <a href="Glossary.html#mimblewimble">mimblewimble</a> to allow them to prune spent inputs and outputs 
beyond the pruning horizon and still validate the integrity of the blockchain i.e. no coins were destroyed or created 
beyond what is allowed by consensus rules. A sufficient number of blocks back from the tip should be configured because 
reorgs are no longer possible beyond that horizon. These nodes can sync from any other base node (archival and pruned).</p>
<h1 id="change-log-1"><a class="header" href="#change-log-1">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">07 Jan 2019</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">25 Jan 2019</td><td style="text-align: left">Pruning and cut-through</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">07 Feb 2021</td><td style="text-align: left">Syncing</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">23 Sep 2021</td><td style="text-align: left">Block weights</td><td style="text-align: left">sbondi</td></tr>
<tr><td style="text-align: left">19 Oct 2022</td><td style="text-align: left">Stabilizing updates</td><td style="text-align: left">brianp</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0111basenodesarchitecture"><a class="header" href="#rfc-0111basenodesarchitecture">RFC-0111/BaseNodesArchitecture</a></h1>
<h2 id="base-node-architecture"><a class="header" href="#base-node-architecture">Base Node Architecture</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-2"><a class="header" href="#licence-2">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-2"><a class="header" href="#language-2">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-2"><a class="header" href="#disclaimer-2">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-2"><a class="header" href="#goals-2">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the high-level Base Node architecture.</p>
<h2 id="architectural-layout"><a class="header" href="#architectural-layout">Architectural Layout</a></h2>
<p>The Base Node architecture is designed to be modular, robust and performant.</p>
<p><img src="theme/images/base_layer_arch.png" alt="Base Layer architecture" /></p>
<p>The major components are separated into separate modules. Each module exposes a public Application Programming Interface
(API), which communicates with other modules using asynchronous messages via futures.</p>
<h3 id="base-node-service"><a class="header" href="#base-node-service">Base Node Service</a></h3>
<p>The Base Node Service fields requests for the local nodes chain state and also accepts newly mined blocks that are 
propagating across the network. The service subscribes to NewBlock and BaseNodeRequest messages via the P2P comms 
interface. These messages are propagated across the P2P network and can also be received directly from other nodes. The 
service also provides a local interface to its functionality via an asynchronous Request-Response API. </p>
<p>The P2P message types this service subscribes to are: </p>
<ul>
<li>
<p><strong>NewBlock:</strong> A newly mined block is being propagated over the network. If the node has not seen the block before, the
node will validate it. Its action depends on the validation outcome:</p>
<ul>
<li><em>Invalid block</em> - drop the block.</li>
<li><em>Valid block appending to the longest chain</em> - add the block to the local state and propagate the block to peers.</li>
<li><em>Valid block forking off main chain</em> - add the block to the local state and propagate the block to peers.</li>
<li><em>Valid block building off unknown block</em> - add the orphan block to the local state.</li>
</ul>
</li>
<li>
<p><strong>BaseNodeServiceRequest:</strong> A collection of requests for chain data from the node.</p>
</li>
</ul>
<h3 id="base-node-state-machine-service"><a class="header" href="#base-node-state-machine-service">Base Node State Machine Service</a></h3>
<p>This service is essentially a finite state machine that synchronises its blockchain state with its peers. When the state 
machine decides it needs to synchronise its chain state with a peer it uses the Base Node Sync RPC service to do so. The
RPC service allows for streaming of headers and blocks in a far more efficient manner than using the P2P messaging.</p>
<p>This service does not provide a local API but does provide an event stream and Status Info watch channel for other 
modules to subscribe to.</p>
<h3 id="mempool-and-mempool-sync-services"><a class="header" href="#mempool-and-mempool-sync-services">Mempool and Mempool Sync Services</a></h3>
<p>The mempool service tracks valid transactions that the node knows about, but that have not yet been included in a
block. The mempool is ephemeral and non-consensus critical, and as such may be a memory-only data structure. Maintaining
a large mempool is far more important for Base Nodes serving miners than those serving wallets. The mempool structure 
itself is a set of hash maps as described in <a href="RFC-0190_Mempool.html">RFC-0190</a></p>
<p>When either the node reboots, or it synchronises a default number of 5 blocks, the Mempool sync service will contact peers and sync valid mempool transactions from them. After 
it has synced this service runs to field such requests from other peers.</p>
<p>The Mempool service handles Mempool Service Requests which it can receive from the P2P comms stack via its 
subscriptions, via the Mempool RPC service and via an internal Request-Response API. All these interfaces provide the 
following calls:</p>
<ul>
<li><em>SubmitTransaction</em>: Submit a transaction to be validated and included in the mempool. If the transaction is invalid 
it will be rejected with a reason.</li>
<li><em>GetTxStateByExcess</em>: Request the state of a transaction if it exists in the mempool using its excess signature</li>
<li><em>GetStats</em> and <em>getState</em>: Request information about the current status of the mempool.</li>
</ul>
<h3 id="liveness-service"><a class="header" href="#liveness-service">Liveness Service</a></h3>
<p>The Liveness service can be used by other modules to test the liveness of a specific peer and also periodically tests a 
set of its connected peers for liveness. This service subscribes to <code>Ping</code> P2P messages and responds with <code>Pong</code>s. The 
service gathers data about the monitored peer's liveness such as its latency. The <code>Ping</code> and Pong` messages also contain
a copy of this nodes current Chain Metadata for use by the receiving nodes Chain Metadata Service.</p>
<h3 id="chain-metadata-service"><a class="header" href="#chain-metadata-service">Chain Metadata Service</a></h3>
<p>The Chain Metadata Service maintains this nodes current Chain Metadata state to be sent out via <code>Ping</code> and <code>Pong</code> 
messages by the Liveness service. This node also monitors the Chain Metadata received from other peers in the <code>Ping</code> and
<code>Pong</code> messages received by the Liveness service. Once a full round of <code>Pong</code> messages are received this service will 
emit this data as an event which the Base Node State Machine monitors.</p>
<h3 id="distributed-hash-table-dht-service"><a class="header" href="#distributed-hash-table-dht-service">Distributed Hash Table (DHT) Service</a></h3>
<p>Peer discovery is a key service that blockchain nodes provide so that the peer mesh network can be navigated by the full
nodes making up the network.</p>
<p>In Tari, the peer-to-peer network is not only used by full nodes (Base Nodes), but also by Validator Nodes, and
Tari and Digital Assets Network (DAN) clients.</p>
<p>For this reason, peer management is handled internally by the Comms layer. If a Base Node wants to propagate a message, 
new block or transaction, for example, it simply selects a <code>BROADCAST</code> strategy for the message and the Comms layer
will do the rest.</p>
<p>When a node wishes to query a peer for its peer list, this request will be handled by the <code>DHTService</code>. It will
communicate with its Comms module's Peer Manager, and provide that information to the peer.</p>
<h3 id="blockchain-database"><a class="header" href="#blockchain-database">Blockchain Database</a></h3>
<p>The blockchain database module is responsible for providing a persistent storage solution for blockchain state data. 
This module is used by the Base Node Service, Base Node State Machine, Mempool Service and the RPC servers. For Tari, 
this is delivered using the Lightning Memory-mapped Database (LMDB). LMDB is highly performant, intelligent and
straightforward to use. An LMDB is essentially treated as a hash map data structure that transparently handles
memory caching, disk Input/Output (I/O) and multi-threaded access. This module is shared by many services and so must
be thread-safe.</p>
<h2 id="communication-interfaces"><a class="header" href="#communication-interfaces">Communication Interfaces</a></h2>
<h3 id="p2p-communications"><a class="header" href="#p2p-communications">P2P communications</a></h3>
<p>The Tari Peer to Peer messaging protocol is defined in <a href="RFC-0172_PeerToPeerMessagingProtocol.html">RFC-0172</a>. It is a fire-and-forget style protocol. Messages can 
be sent directly to a known peer, sent indirectly to an offline or unknown peer and broadcast to a set of peers. When
a message is sent to specific peer it is propagated to the peers local neighbourhood and stored by those peers until it
comes online to receive the message. Messages that are broadcast will be propagated around the network until the whole
network has received them, they are not stored.</p>
<h3 id="rpc-services"><a class="header" href="#rpc-services">RPC Services</a></h3>
<p>Fire-and-forget messaging is not efficient for point to point communications between online peers. For these applications
the Base Node provides RPC services that present an API for clients to interact with. These RPC services provide a
Request-Response interface defined by Profobuf for clients to use. RPC also allows for streaming of data which is much
more efficient when transferring large amounts of data.</p>
<p>Examples of RPC services running in 
Base Node are:</p>
<ul>
<li><strong>Wallet RPC service</strong>: An RPC interface containing methods used by wallets to submit and query transactions on a 
Base Node</li>
<li><strong>Base Node Sync RPC Service</strong>: Used by the Base Node State Machine Service to synchronise blocks</li>
<li><strong>Mempool RPC Service</strong>: Provides the Mempool Service API via RPC</li>
</ul>
<h3 id="grpc-interface"><a class="header" href="#grpc-interface">gRPC Interface</a></h3>
<p>Base Nodes need to provide a local communication interface in addition to the P2P and RPC communication interface. This 
is best achieved using <a href="https://grpc.io/">gRPC</a>. The Base Node gRPC interface provides access to the public API methods of the Base Node
Service, the mempool module and the blockchain state module, as discussed above.</p>
<p>gRPC access is useful for tools such as local User Interfaces (UIs) to a running Base Node; client wallets running on
the same machine as the Base Node that want a more direct communication interface to the node than the P2P network
provides; third-party applications such as block explorers; and, of course, miners.</p>
<p>A non-exhaustive list of methods the base node module API will expose includes:</p>
<ul>
<li>Blockchain state calls, including:
<ul>
<li>checking whether a given Unspent Transaction Output (UTXO) is in the current UTXO set;</li>
<li>requesting the latest block height;</li>
<li>requesting the total accumulated work on the longest chain;</li>
<li>requesting a specific block at a given height;</li>
<li>requesting the Merklish root commitment of the current UTXO set;</li>
<li>requesting a block header for a given height;</li>
<li>requesting the block header for the chain tip;</li>
<li>validating signatures for a given transaction kernel;</li>
<li>validating a new block without adding it to the state tree;</li>
<li>validating and adding a (validated) new block to the state, and informing of the result (orphaned, fork, reorg, etc.).</li>
</ul>
</li>
<li>Mempool calls
<ul>
<li>The number of unconfirmed transactions</li>
<li>Returning a list of transaction ranked by some criterion (of interest to miners)</li>
<li>The current size of the mempool (in transaction weight)</li>
</ul>
</li>
<li>Block and transaction validation calls</li>
<li>Block synchronisation calls</li>
</ul>
<h1 id="change-log-2"><a class="header" href="#change-log-2">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">2 Jul 2019</td><td style="text-align: left">First outline</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">11 Aug 2019</td><td style="text-align: left">Updates</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">15 Jun 2021</td><td style="text-align: left">Significant updates</td><td style="text-align: left">SimianZa</td></tr>
<tr><td style="text-align: left">11 Sep 2022</td><td style="text-align: left">Minor update</td><td style="text-align: left">JorgeAnt</td></tr>
<tr><td style="text-align: left">18 Jan 2023</td><td style="text-align: left">Minor update</td><td style="text-align: left">JorgeAnt</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0120consensus"><a class="header" href="#rfc-0120consensus">RFC-0120/Consensus</a></h1>
<h2 id="base-layer-consensus"><a class="header" href="#base-layer-consensus">Base Layer Consensus</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>, <a href="https://github.com/sdbondi">Stanley Bondi</a> and <a href="https://github.com/SWvheerden">SW van heerden</a></p>
<h1 id="licence-3"><a class="header" href="#licence-3">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-3"><a class="header" href="#language-3">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-3"><a class="header" href="#disclaimer-3">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-3"><a class="header" href="#goals-3">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the fields that a block should contain as well as all consensus rules that will determine the validity of a block.</p>
<h2 id="related-requests-for-comment-2"><a class="header" href="#related-requests-for-comment-2">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0122_Burning.html">RFC-0122: Burn outputs</a></li>
<li><a href="RFCD-0130_Mining.html">RFC-0130: Mining</a></li>
<li><a href="RFC-0140_Syncing_and_seeding.html">RFC-0140: SyncAndSeeding</a></li>
</ul>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>Blockchain consensus is a set of rules that a majority of nodes agree on that determines the state of the blockchain. </p>
<p>This RFC details the consensus rules for the Tari network. </p>
<h3 id="blocks"><a class="header" href="#blocks">Blocks</a></h3>
<p>Every <a href="Glossary.html#block">block</a> MUST:</p>
<ul>
<li>
<p>have <em>exactly one</em> valid <a href="Glossary.html#block-header">block header</a>, as per the <a href="RFC-0120_Consensus.html#block-headers" title="Block headers">Block Headers</a> section</p>
</li>
<li>
<p>have <em>exactly one</em> <a href="RFC-0120_Consensus.html#coinbase" title="Coinbase consensus">coinbase</a> transaction</p>
</li>
<li>
<p>have a total <a href="Glossary.html#transaction-weight">transaction weight</a> less than the consensus maximum</p>
</li>
<li>
<p>be able to calculate matching Merkle roots (<a href="RFC-0120_Consensus.html#kernel_mr" title="Kernel Merkle root">kernel_mr</a>, <a href="RFC-0120_Consensus.html#output_mr" title="Output Merkle root">output_mr</a>, <a href="RFC-0120_Consensus.html#witness_mr" title="Witness Merkle root">witness_mr</a>, and <a href="RFC-0120_Consensus.html#input_mr" title="Input Merkle root">input_mr</a>) </p>
</li>
<li>
<p>each <a href="Glossary.html#transaction">transaction input</a> MUST: </p>
<ul>
<li>be of an allowed <a href="Glossary.html#transaction">transaction input</a> version</li>
<li>spend an existing valid <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> with a maturity less than the current block height</li>
<li>satisfy the <a href="RFC-0250_Covenants.html">covenant</a> attached to the <a href="Glossary.html#unspent-transaction-outputs">UTXO</a></li>
<li>have a valid <a href="Glossary.html#script-signature">script signature</a></li>
<li>be in a canonical order (see <a href="RFC-0120_Consensus.html#transaction-ordering" title="Canonical Transaction Ordering">Transaction ordering</a>)</li>
</ul>
</li>
<li>
<p>each <a href="Glossary.html#unspent-transaction-outputs">transaction output</a> MUST:</p>
<ul>
<li>be of an allowed <a href="Glossary.html#unspent-transaction-outputs">transaction output</a> version</li>
<li>have a unique domain separated hash (<code>version || features || commitment || script || covenant || encrypted_values</code>) with the domain (<code>transaction_output</code>)</li>
<li>have a unique commitment in the current <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> set</li>
<li>be in a canonical order (see <a href="RFC-0120_Consensus.html#transaction-ordering" title="Canonical Transaction Ordering">Transaction ordering</a>)</li>
<li>have a valid <a href="Glossary.html#range-proof">range proof</a></li>
<li>have a valid <a href="Glossary.html#metadata-signature">metadata signature</a></li>
<li>contain only allowed opcodes in the script</li>
</ul>
</li>
<li>
<p>each <a href="Glossary.html#transaction-kernel">transaction kernel</a> MUST </p>
<ul>
<li>have a valid kernel excess signature</li>
<li>have a unique excess</li>
</ul>
</li>
<li>
<p>have a valid total script offset, \( \gamma \), see <a href="Glossary.html#script-offset">script-offset</a>.</p>
</li>
<li>
<p>the number of <code>BURNED</code> outputs MUST equal the number of <code>BURNED_KERNEL</code> kernels exactly,</p>
</li>
<li>
<p>the commitment values of each burnt output MUST match the commitment value of each corresponding <code>BURNED_KERNEL</code> exactly.</p>
</li>
<li>
<p>the transaction commitments and kernels MUST balance, as follows:</p>
<p>$$
\begin{align}
&amp;\sum_i\mathrm{Cout_{i}} - \sum_j\mathrm{Cin_{j}} + \text{fees} \cdot H \stackrel{?}{=} \sum_k\mathrm{K_k} + \text{offset} \\
&amp; \text{for each output}, i, \\
&amp; \text{for each input}, j, \\
&amp; \text{for each kernel excess}, k \\
&amp; \text{and }\textit{offset }\text{is the total kernel offset} \\
\end{align}
\tag{1}
$$</p>
</li>
</ul>
<p>If a <a href="Glossary.html#block">block</a> does not conform to the above, the block SHOULD be discarded and MAY ban the peer that sent it.</p>
<h4 id="coinbase"><a class="header" href="#coinbase">Coinbase</a></h4>
<p>A coinbase transaction contained in a block MUST:</p>
<ul>
<li>be the only transaction in the block with the coinbase flag</li>
<li>consist of exactly one output and one kernel (no input)</li>
<li>have a valid kernel signature</li>
<li>have a value exactly equal to the emission at the block height it was minted (see <a href="Glossary.html#emission-schedule">emission schedule</a>) 
plus the total transaction fees within the block</li>
<li>have a lock-height as per consensus</li>
<li>can not have a offset except 0</li>
<li>can not have a script offset except 0</li>
</ul>
<p>A coinbase transaction contained in a block CAN:</p>
<ul>
<li>include any arbitrary 64 bytes of extra data, <a href="Glossary.html#coinbase-extra">coinbase-extra</a></li>
</ul>
<h3 id="block-headers"><a class="header" href="#block-headers">Block Headers</a></h3>
<p>Every <a href="Glossary.html#block-header">block header</a> MUST contain the following fields:</p>
<ul>
<li>version;</li>
<li>height;</li>
<li>prev_hash;</li>
<li>timestamp;</li>
<li>output_mr;</li>
<li>output_mmr_size;</li>
<li>input_mr;</li>
<li>witness_mr;</li>
<li>kernel_mr;</li>
<li>kernel_mmr_size;</li>
<li>total_kernel_offset;</li>
<li>script_kernel_offset;</li>
<li>nonce;</li>
<li>pow.</li>
</ul>
<p>The <a href="Glossary.html#block-header">block header</a> MUST conform to the following:</p>
<ul>
<li>The nonce and <a href="RFC-0120_Consensus.html#pow">PoW</a> must be valid for the <a href="Glossary.html#block-header">block header</a>.</li>
<li>The [achieved difficulty] MUST be greater than or equal to the <a href="RFC-0120_Consensus.html#target-difficulty" title="Target Difficulty">target difficulty</a>.</li>
<li>The <a href="RFC-0120_Consensus.html#ftl" title="Future Time Limit">FTL</a> and <a href="RFC-0120_Consensus.html#mtp" title="Median Time Passed">MTP</a> rules, detailed below.</li>
<li>The block hash must not appear in the bad block list.</li>
</ul>
<p>The Merkle roots are validated as part of the full block validation, detailed in <a href="RFC-0120_Consensus.html#blocks" title="Block consensus">Blocks</a>.</p>
<p>If the <a href="Glossary.html#block-header">block header</a> does not conform to any of the above, the <a href="Glossary.html#block">block</a> SHOULD be rejected and MAY ban the peer that
sent it.</p>
<h4 id="version"><a class="header" href="#version">Version</a></h4>
<p>This is the version currently running on the chain.</p>
<p>The version MUST conform to the following:</p>
<ul>
<li>It is represented as an unsigned 16-bit integer.</li>
<li>Version numbers MUST be incremented whenever there is a change in the blockchain schema or validation rules starting from 0.</li>
<li>The version must be one of the allowed versions for the consensus rules at this block's height.</li>
</ul>
<h4 id="height"><a class="header" href="#height">Height</a></h4>
<p>A counter indicating how many blocks have passed since the genesis block (inclusive).</p>
<p>The height MUST conform to the following:</p>
<ul>
<li>Represented as an unsigned 64-bit integer.</li>
<li>The height MUST be exactly one more than the block referenced in the <code>prev_hash</code> block header field.</li>
<li>The genesis block MUST have a height of 0.</li>
</ul>
<h4 id="prev_hash"><a class="header" href="#prev_hash">Prev_hash</a></h4>
<p>This is the hash of the previous block's header.</p>
<p>The prev_hash MUST conform to the following:</p>
<ul>
<li>represented as an array of unsigned 8-bit integers (bytes) in little-endian format.</li>
<li>MUST be a hash of the entire contents of the previous block's header using the domain (<code>block_header</code>).</li>
</ul>
<h4 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h4>
<p>This is the timestamp at which the block was mined.</p>
<p>The timestamp MUST conform to the following:</p>
<ul>
<li>Must be transmitted as UNIX timestamp.</li>
<li>MUST be less than <a href="RFC-0120_Consensus.html#ftl" title="Future Time Limit">FTL</a>.</li>
<li>MUST be higher than the <a href="RFC-0120_Consensus.html#mtp" title="Median Time Passed">MTP</a>.</li>
</ul>
<h4 id="output_mr"><a class="header" href="#output_mr">Output_mr</a></h4>
<p>The <code>output_mr</code> MUST be calculated as follows: Hash (<code>TXO MMR root</code>  || Hash(<code>spent TXO bitmap</code>)).</p>
<p>The <code>TXO MMR root</code> is the MMR root that commits to every <a href="Glossary.html#unspent-transaction-outputs">transaction output</a> that has ever existed since 
the genesis <a href="Glossary.html#block">block</a>. </p>
<p>The <code>spent TXO bitmap</code> is a compact serialized <a href="https://github.com/RoaringBitmap/RoaringFormatSpec">roaring bitmap</a> containing all the output MMR leaf indexes 
of all the outputs that have ever been spent. </p>
<p>The output_mr MUST conform to the following:</p>
<ul>
<li>Represented as an array of unsigned 8-bit integers (bytes) in little-endian format.</li>
<li>The hashing function used MUST be blake2b with a 256-bit digest.</li>
</ul>
<h4 id="output_mmr_size"><a class="header" href="#output_mmr_size">Output_mmr_size</a></h4>
<p>This is the total size of the leaves in the output Merkle mountain range.</p>
<p>The Output_mmr_size MUST conform to the following:</p>
<ul>
<li>Represented as a single unsigned 64-bit integer.</li>
</ul>
<h4 id="input_mr"><a class="header" href="#input_mr">Input_mr</a></h4>
<p>This is the Merkle root of all the inputs in the block, which consists of the hashed inputs. It is used to prove that 
all inputs are correct and not changed after mining. This MUST be constructed by adding, in order, the hash of every 
input contained in the block. </p>
<p>The input_mr MUST conform to the following:</p>
<ul>
<li>Represented as an array of unsigned 8-bit integers (bytes) in little-endian format.</li>
<li>The hashing function must be blake2b with a 256-bit digest.</li>
</ul>
<h4 id="witness_mr"><a class="header" href="#witness_mr">Witness_mr</a></h4>
<p>This is the Merkle root of the output witness data, specifically all created outputs’ <a href="Glossary.html#range-proof">range proof</a>s and 
metadata signatures. This MUST be constructed by 
Hash ( <code>RangeProof</code> || <code>metadata commitment signature</code>), in order, for every output contained in the block.</p>
<p>The witness_mr MUST conform to the following:</p>
<ul>
<li>Represented as an array of unsigned 8-bit integers (bytes) in little-endian format.</li>
<li>The hashing function used must be blake2b with a 256-bit digest.</li>
</ul>
<h4 id="kernel_mr"><a class="header" href="#kernel_mr">Kernel_mr</a></h4>
<p>This is the Merkle root of the kernels.</p>
<p>The kernel_mr MUST conform to the following:</p>
<ul>
<li>Must be transmitted as an array of unsigned 8-bit integers (bytes) in little-endian format.</li>
<li>The hashing function used must be blake2b with a 256-bit digest.</li>
</ul>
<h4 id="kernel_mmr_size"><a class="header" href="#kernel_mmr_size">Kernel_mmr_size</a></h4>
<p>This is the total size of the leaves in the kernel Merkle mountain range.</p>
<p>The Kernel_mmr_size MUST conform to the following:</p>
<ul>
<li>Represented as a single unsigned 64-bit integer.</li>
</ul>
<h4 id="total_kernel_offset"><a class="header" href="#total_kernel_offset">Total_kernel_offset</a></h4>
<p>This is the total summed offset of all the transactions in this block.</p>
<p>The total_kernel_offset MUST conform to the following:</p>
<ul>
<li>Must be transmitted as an array of unsigned 8-bit integers (bytes) in little-endian format</li>
</ul>
<h4 id="total_script_offset"><a class="header" href="#total_script_offset">Total_script_offset</a></h4>
<p>This is the total summed script offset of all the transactions in this block.</p>
<p>The total_script_offset MUST conform to the following:</p>
<ul>
<li>Must be transmitted as an array of unsigned 8-bit integers (bytes) in little-endian format</li>
</ul>
<h4 id="nonce"><a class="header" href="#nonce">Nonce</a></h4>
<p>This is the nonce used in solving the Proof of Work.</p>
<p>The nonce MUST conform to the following:</p>
<ul>
<li>MUST be transmitted as an unsigned 64-bit integer;</li>
<li>for RandomX blocks, thus MUST be 0</li>
</ul>
<h4 id="pow"><a class="header" href="#pow">PoW</a></h4>
<p>This is the Proof of Work algorithm used to solve the Proof of Work. This is used in conjunction with the Nonce.</p>
<p>The [PoW] MUST contain the following:</p>
<ul>
<li>pow_algo as an enum (0 for RandomX, 1 for Sha3x).</li>
<li>pow_data for RandomX blocks as an array of unsigned 8-bit integers (bytes) in little-endian format, containing the RandomX merge-mining Proof-of-Work data.
<ul>
<li>the RandomX seed, stored as <code>randomx_key</code> within the RandomX block, must have not been first seen in a block with confirmations more than <code>max_randomx_seed_height</code>.</li>
</ul>
</li>
<li>pow_data for Sha3x blocks MUST be empty.</li>
</ul>
<h4 id="difficulty-calculation"><a class="header" href="#difficulty-calculation">Difficulty Calculation</a></h4>
<p>The target difficulty represents how difficult it is to mine a given block. This difficulty is not fixed and needs to
constantly adjust to changing network hash rates. </p>
<p>The difficulty adjustment MUST be calculated using a linear-weighted moving average (LWMA) algorithm (2)
$$
\newcommand{\solvetime}{ \mathrm{ST_i} }
\newcommand{\solvetimemax}{ \mathrm{ST_{max}} }
$$</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>N</td><td>90</td><td>Target difficulty block window</td></tr>
<tr><td>T</td><td>SHA3x: 300 RandomX: 200</td><td>Target block time in seconds.  The value used depends on the  PoW algorithm being used.</td></tr>
<tr><td>\( \solvetimemax \)</td><td>SHA3x: 1800 RandomX: 1200</td><td>Maximum solve time.  This is six times the target time  of the current PoW algorithm.</td></tr>
<tr><td>\( \solvetime \)</td><td>variable</td><td>The timestamp difference in seconds between  block <em>i</em> and <em>i - 1</em> where \( 1 \le \solvetime \le \solvetimemax \)</td></tr>
<tr><td>\( \mathrm{D_{avg}} \)</td><td>variable</td><td>The average difficulty of the last <em>N</em> blocks</td></tr>
</tbody></table>
</div>
<p>$$
\begin{align}
&amp; \textit{weighted_solve_time} = \sum\limits_{i=1}^N(\solvetime*i)  \\
&amp; \textit{weighted_target_time} = (\sum\limits_{i=1}^Ni) * \mathrm{T} \\
&amp; \textit{difficulty} = \mathrm{D_{avg}} * \frac{\textit{weighted_target_time}}{\textit{weighted_solve_time}}\\
\end{align}
\tag{2}
$$</p>
<p>It is important to note that the two proof of work algorithms are calculated <em>independently</em>. i.e., if the current block uses <em>SHA3x</em> proof of work, the block window and solve times only include <em>SHA3x</em> blocks and vice versa.</p>
<h3 id="ftl"><a class="header" href="#ftl">FTL</a></h3>
<p>The Future Time Limit. This is how far into the future a time is accepted as a valid time. Any time that is more than the FTL is rejected until such a time that it is not more than the FTL.
The FTL is calculated as (T*N)/20 with T and N defined as:
T: Target time - This is the ideal time that should pass between blocks that have been mined.
N: Block window - This is the number of blocks used when calculating difficulty adjustments.</p>
<h3 id="mtp"><a class="header" href="#mtp">MTP</a></h3>
<p>The Median Time Passed (MTP) is the lower bound calculated by taking the median average timestamp of the 
last <em>N</em> blocks. Any block with a timestamp that is less than MTP will be rejected.</p>
<h3 id="total-accumulated-proof-of-work"><a class="header" href="#total-accumulated-proof-of-work">Total accumulated proof of work</a></h3>
<p>This is defined as the total accumulated proof of work done on the blockchain. Tari uses two <em>independent</em> proof of work algorithms 
rated at different difficulties. To compare them, we simply multiply them together into one number:
$$
\begin{align}
\textit{accumulated_randomx_difficulty} * \textit{accumulated_sha3x_difficulty} 
\end{align}
\tag{3}
$$
This value is used to compare chain tips to determine the strongest chain.</p>
<h3 id="transaction-ordering"><a class="header" href="#transaction-ordering">Transaction Ordering</a></h3>
<p>The order in which transaction inputs, outputs, and kernels are added to the Merkle mountain range completely changes the
final Merkle root. Input, output, and kernel ordering within a block is, therefore, part of the consensus. </p>
<p>The block MUST be transmitted in canonical ordering. The advantage of this approach is that sorting does not need to be 
done by the whole network, and verification of sorting is exceptionally cheap.</p>
<ul>
<li>Transaction outputs are sorted lexicographically by the byte representation of their Pedersen commitment i.e. ( \(k \cdot G + v \cdot H\) ).</li>
<li>Transaction kernels are sorted lexicographically by the excess signature byte representation.</li>
<li>Transaction inputs are sorted lexicographically by the hash of the output that is spent by the input.</li>
</ul>
<h1 id="change-log-3"><a class="header" href="#change-log-3">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">11 Oct 2022</td><td style="text-align: left">First stable</td><td style="text-align: left">SWvHeerden</td></tr>
<tr><td style="text-align: left">13 Mar 2023</td><td style="text-align: left">Add mention of coinbase extra</td><td style="text-align: left">SWvHeerden</td></tr>
<tr><td style="text-align: left">05 Jun 2023</td><td style="text-align: left">Add coinbase excess rule</td><td style="text-align: left">SWvHeerden</td></tr>
<tr><td style="text-align: left">01 Aug 2023</td><td style="text-align: left">Add Randomx rule, fix Sha and Monero names</td><td style="text-align: left">SWvHeerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0131mining"><a class="header" href="#rfc-0131mining">RFC-0131/Mining</a></h1>
<h2 id="full-node-mining-on-tari-base-layer"><a class="header" href="#full-node-mining-on-tari-base-layer">Full-node Mining on Tari Base Layer</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/hansieodendaal">Hansie Odendaal</a></p>
<h1 id="licence-4"><a class="header" href="#licence-4">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2020 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-4"><a class="header" href="#language-4">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-4"><a class="header" href="#disclaimer-4">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-4"><a class="header" href="#goals-4">Goals</a></h2>
<p>This document describes the final proof-of-work strategy proposal for Tari main net.</p>
<h2 id="related-requests-for-comment-3"><a class="header" href="#related-requests-for-comment-3">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0110_BaseNodes.html">RFC-0110: Base Nodes</a></li>
</ul>
<p>This RFC replaces and deprecates <a href="RFCD-0130_Mining.html">RFC-0130: Mining</a></p>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>The following proposal draws from many of the key points of debate from the Tari community on the topic of Tari’s
main chain proof of work strategy. The early working assumption was that Tari would be 100% merged mined by Monero.</p>
<p>Having a single, merge mined Proof of Work (PoW) algorithm would be nice, but the risks of hash rate attacks are 
real and meaningful. Double-spends and altering history can happen with &gt;50% hash power, while selfish mining and 
eclipse attacks can happen with &gt;33% hash power for a poorly connected attacker and &gt;25% for a well-connected attacker 
(see <a href="http://repositum.tuwien.ac.at/obvutwhs/download/pdf/2315652"><em>Merged Mining: Analysis of Effects and Implications</em></a>).
Any non-merge mined PoW algorithm that is currently employed is even more vulnerable, especially if one can simply buy
hash rate on platforms like NiceHash.</p>
<p>Hybrid mining is a strategy that apportions blocks across multiple PoW algorithms. If the hybrid algorithms are
independent, then one can get at most x% of the total hash rate, where x is the fraction of blocks apportioned to that
algorithm. As a result, the threat of a double-spend or selfish mining attack is mitigated, and in some cases
eliminated.</p>
<p>This proposal puts forward Hybrid mining as the Tari PoW algorithm. </p>
<h3 id="the-choice-of-algorithms"><a class="header" href="#the-choice-of-algorithms">The choice of algorithms</a></h3>
<p>In hybrid mining, &quot;independence&quot; of algorithms is key. If the same mining hardware can be used on multiple PoW
algorithms in the hybrid mining scheme, you may as well not bother with hybrid mining because miners can simply
switch between them.</p>
<p>In practice, no set of algorithms is genuinely independent. The best we can do is try to choose algorithms that work best
on CPUs, GPUs, and ASICs. In truth, the distinction between GPUs and ASICs is only a matter of time. Any &quot;GPU-friendly&quot;
algorithm is ASIC-friendly, too; it's just a case of whether the capital outlay for fabricating them is worth it, and
this will eventually become true for any algorithm that supplies PoW for a growing market cap.</p>
<p>With this in mind, we should only choose one GPU/ASIC algorithm and one for CPUs. </p>
<p>An excellent technical choice would be merge mining with Monero using RandomX as a CPU-only algorithm and SHA3, also known as Keccak
, for a GPU/ASIC-friendly algorithm. Using a custom configuration of such a simple and well-understood algorithm means there is 
a low likelihood of unforeseen optimizations that will give a single miner a considerable advantage. It also means that it stands a 
good chance of being &quot;commoditized&quot; when ASICs are eventually manufactured. This would mean that SHA3 ASICs are widely available from multiple suppliers.</p>
<h3 id="the-difficulty-adjustment-strategy"><a class="header" href="#the-difficulty-adjustment-strategy">The difficulty adjustment strategy</a></h3>
<p>The choice of difficulty adjustment algorithm is important. In typical hybrid mining strategies, each algorithm operates
completely independently with a scaled target block time. 
Tari testnet has been running very successfully using the Linear Weighted Moving Average (LWMA) from Bitcoin &amp; Zcash
Clones <a href="https://github.com/zawy12/difficulty-algorithms/issues/3#issuecomment-442129791">version 2018-11-27</a>. This LWMA
difficulty adjustment algorithm has also been
<a href="https://github.com/tari-labs/modelling/tree/master/scenarios/multi_pow_01">tested in simulations</a>, 
and it proved to be a good choice in the multi-PoW scene as well.</p>
<h3 id="final-proposal-hybrid-mining-details"><a class="header" href="#final-proposal-hybrid-mining-details">Final proposal, hybrid mining details</a></h3>
<p>Tari's proof-of-work mining algorithm is summarized below:</p>
<ul>
<li>Two mining algorithms, with an average combined target block time of 120 s, to match Monero's block interval.</li>
<li>A log-weighted moving average difficulty adjustment algorithm using a window of 90 blocks.</li>
</ul>
<h3 id="tari-mining-hash"><a class="header" href="#tari-mining-hash">Tari mining hash</a></h3>
<p>First, the block header is hashed with the 256-bit Blake2b hashing algorithm using 
<a href="https://github.com/tari-project/tari-crypto/blob/main/src/hashing.rs">domain-separated hashing</a>, using the domain 
<code>com.tari.base_layer.core.blocks</code>. The fields are hashed in the order:</p>
<ul>
<li>version</li>
<li>block height</li>
<li>previous header hash</li>
<li>timestamp</li>
<li>input Merkle root</li>
<li>output Merkle root</li>
<li>output Merkle mountain range size</li>
<li>witness Merkle root</li>
<li>kernel Merkle root</li>
<li>kernel Merkle mountain range size</li>
<li>total kernel offset</li>
<li>total script offset</li>
</ul>
<p>This hash is used in both the SHA-3 and RandomX proof-of-work algorithms. The header version for the Tari Genesis 
block is 1.</p>
<h4 id="randomx"><a class="header" href="#randomx">RandomX</a></h4>
<p>Monero blocks that are merge-mining Tari MUST include the Tari mining hash in the extra field of the Monero coinbase transaction.</p>
<p>Tari also imposes the following consensus rules:</p>
<ul>
<li>The <code>seed_hash</code> MUST only be used for 3000 blocks, after which a block MUST be discarded if it's used again.</li>
<li>The little-endian difficulty MUST be equal to or greater than the target for that block as determined by the LWMA for Tari.</li>
<li>The LWMA MUST use a target time of 200 seconds.</li>
<li>MUST set the header field PoW:pow_algo as 0 for a Monero block</li>
<li>MUST encode the following data into the Pow:Pow_data field:
<ul>
<li>Monero BlockHeader,</li>
<li>RandomX VM key,</li>
<li>Monero transaction count,</li>
<li>Monero merkle root,</li>
<li>Monero coinbase merkle proof and,</li>
<li>Monero coinbase transaction</li>
</ul>
</li>
</ul>
<h4 id="sha-3x"><a class="header" href="#sha-3x">Sha-3x</a></h4>
<p>Tari's independent proof-of-work algorithm is very straightforward.</p>
<p>Calculate the <em>triple hash</em> of the following input data:</p>
<ul>
<li>Nonce (8 bytes)</li>
<li>Tari mining hash (32 bytes)</li>
<li>PoW record (for Sha-3x, this is always a single byte of value 1)</li>
</ul>
<p>That is, the nonce in little-endian format, mining hash and the PoW record are chained together and hashed by the 
Keccak Sha3-256 algorithm. The result is hashed again, and this result is hashed a third time. The result of the third 
hash is compared to the target value of the current block difficulty. </p>
<p>If the entire 64-bit nonce space is exhausted without finding a valid block, the mining algorithm must request a new 
Tari mining hash from the Tari base node. The simplest way to do this is to update the timestamp field in the block 
header, keeping everything else constant.</p>
<p>Tari imposes the following consensus rules:</p>
<ul>
<li>The Big endian difficulty MUST be equal or greater than the target difficulty for that block as determined by the 
LWMA for Tari. The difficulty and target are related by the equation <code>difficulty = (2^256 - 1) / target</code>.</li>
<li>MUST set the header field PoW:pow_algo as 1 for a Sha block.</li>
<li>The PoW:pow_data field is empty</li>
<li>The LWMA MUST use a target time of 300 seconds.</li>
</ul>
<p>A triple hash is selected to keep the requirements on hardware miners (FPGAs, ASICs) fairly low. But we also want to 
avoid making the proof-of-work immediately &quot;NiceHashable&quot;. There are several coins that already use a single or 
double SHA3 hash, and we'd like to avoid having that hashrate immediately deployable against Tari.</p>
<p>Historical note: In general, little-endian representations for integers are used in Tari. There are a few places 
where big-endian representations are used, in the PoW hash and in some merge-mined fields in particular. The 
latter is required to be compatible with the Monero specification. But we also use the big-endian representation for 
the block hash due to a historical convention. The Bitcoin white paper describes the block hash target as 
containing &quot;a certain number of leading zeros&quot; (paraphrased). This is obviously a big-endian representation. If we 
used little-endian, our block hashes would have trailing zeroes. So we use the big-endian form to satisfy the 
expected in block explorers and such that block hashes should always start with a series of zeroes.</p>
<h1 id="stabilisation-note"><a class="header" href="#stabilisation-note">Stabilisation note</a></h1>
<p>This RFC is stable as of PR#4862</p>
<h1 id="change-log-4"><a class="header" href="#change-log-4">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">2022-11-25</td><td style="text-align: left">Update mining hash decsription</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">2022-10-26</td><td style="text-align: left">Finalise SHA-3 algorithm</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">2022-10-11</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvHeerden</td></tr>
<tr><td style="text-align: left">2024-12-09</td><td style="text-align: left">Corrected percentages for merged and hybrid mining</td><td style="text-align: left">Solivagant</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0132mergeminingmonero"><a class="header" href="#rfc-0132mergeminingmonero">RFC-0132/MergeMiningMonero</a></h1>
<h2 id="tari-protocol-for-merge-mining-with-monero"><a class="header" href="#tari-protocol-for-merge-mining-with-monero">Tari protocol for Merge Mining with Monero</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-5"><a class="header" href="#licence-5">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2020 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-5"><a class="header" href="#language-5">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-5"><a class="header" href="#disclaimer-5">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-5"><a class="header" href="#goals-5">Goals</a></h2>
<p>This document describes the specific protocol Tari uses to merge mine with Monero.</p>
<h2 id="related-requests-for-comment-4"><a class="header" href="#related-requests-for-comment-4">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0131_Mining.html">RFC-0131: Mining</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Tari employs a hybrid mining strategy, accepting 2 mining algorithms whose difficulties are independent of each other as discussed in <a href="/RFC-0131_Mining.html">RFC-0131_Mining.html</a>.
This RFC details a protocol to enable Tari to accept Monero proof of work, enabling participating miners a chance to produce a valid block for either or both chain without additional mining effort.</p>
<p>The protocol must enable a Tari base node to make the following assertions:</p>
<p><strong>REQ 1.</strong> The achieved mining difficulty exceeds target difficulty as dictated by Tari consensus, </p>
<p><strong>REQ 2.</strong> The Monero block was constructed after the current Tari tip block. This is to prevent a miner from submitting blocks from the parent chain that satisfy the auxiliary chain's difficulty without doing new work.</p>
<p>It's worth noting that a Tari base node never has to contact or download data from Monero to make these assertions.</p>
<h2 id="merge-mining-on-tari"><a class="header" href="#merge-mining-on-tari">Merge Mining on Tari</a></h2>
<p>A new Tari block template is obtained from a Tari base node by calling the <code>get_new_block_template</code> gRPC method, setting <code>Monero</code> as the chosen PoW algorithm.
The <code>Monero</code> algorithm must be selected so that the correct mining difficulty for the Monero algorithm is returned. Remember, that Monero and SHA difficulties 
are independent (See <a href="/RFC-0131_Mining.html">RFC-0131_Mining.html</a>). Next, a coinbase transaction is requested from a Tari Wallet for a give height by calling 
the <code>get_coinbase</code> gRPC function. </p>
<p>Next, the coinbase transaction is added to the new block template and passed back to the base node for the new MMR roots to be calculated.
Furthermore, the base node constructs a <em>Blake256</em> hash of <em>some</em> of the Tari header fields. We'll call this hash the merge mining hash \( h_m \) that commits to 
the following header fields in order: <code>version</code>, <code>height</code>,<code>prev_hash</code>,<code>timestamp</code>,<code>input_mr</code>, <code>output_mr</code>,<code>output_mmr_size</code>,<code>kernel_mr</code>,
<code>kernel_mmr_size</code>,<code>total_kernel_offset</code>,<code>total_script_offset</code>. Note, this hash does not include the <code>pow</code> and <code>nonce</code> fields, as these fields are set as part of mining.</p>
<p>To have the chance of mining a Monero block as well as a Tari block, we must obtain a new valid monero block template, by calling <a href="https://ww.getmonero.org/resources/developer-guides/daemon-rpc.html#get_block_template">get_block_template</a>.
This returns a <code>blocktemplate_blob</code>, that is, a serialized Monero block containing the Monero block header, coinbase and a list of hashes referencing the 
transactions included in the block. Additionally, a <code>blockhashing_blob</code> is a fixed size blob containing <code>serialized_monero_header</code>, <code>merkle_tree_root</code> and 
<code>txn_count</code> concatenated together. The <code>merkle_tree_root</code> is a <em>merkle root</em> of the coinbase + the transaction hashes contained in the block.</p>
<pre><code class="language-rust ignore">pub struct Block {
    /// The block header
    pub header: BlockHeader,
    /// Coinbase transaction a.k.a miner transaction
    pub miner_tx: Transaction,
    /// References to the transactions included in this block
    pub tx_hashes: Vec&lt;hash::Hash&gt;,
}</code></pre>
<p><em>fig 1. The Monero block struct</em></p>
<p>Next, modify the Monero block template by including the merge mining hash \( h_m \) in the extra fields of the coinbase transaction. Monero has a <a href="https://docs.rs/monero/0.13.0/monero/blockdata/transaction/enum.SubField.html#variant.MergeMining">merge mining subfield</a> 
to accommodate this data. Importantly, the extra field data part of the coinbase transaction hash and therefore the <code>merkle_tree_root</code>, the <code>blockhashing_blob</code> must be 
reconstructed. A rust port of <a href="https://github.com/monero-project/monero/blob/1c8e598172bd2eddba2607cae0804db2e685813b/src/crypto/tree-hash.c">Monero's tree hash</a> algorithm is needed to achieve this. The coinbase hash MUST be the first element to be hashed when constructing the <code>merkle_tree_root</code>.
This satisfies <strong>REQ 2</strong>, proving that the proof-of-work was performed for the Tari block.</p>
<p>The block may now be mined. Once a solution is found that satisfies the Tari difficulty, the miner must include enough data to allow the Tari blockchain to assert <strong>REQ 1</strong> and <strong>REQ 2</strong>.
Concretely, A miner must serialize <code>MoneroPowData</code> using Monero consensus encoding and add it to the <code>pow_data</code> field in the Tari header.</p>
<pre><code class="language-rust ignore">pub struct MoneroPowData {
    /// Monero header fields
    header: MoneroBlockHeader,
    /// randomX vm key
    randomx_key: FixedByteArray, // Fixed 64 bytes
    /// transaction count
    transaction_count: u16,
    /// transaction root
    merkle_root: MoneroHash,
    /// Coinbase merkle proof hashes
    coinbase_merkle_proof: MerkleProof,
    /// Coinbase tx from Monero
    coinbase_tx: MoneroTransaction,
}</code></pre>
<p><em>fig 2. Monero PoW data struct serialized in Tari blocks</em></p>
<pre><code class="language-rust ignore">pub struct MerkleProof {
   branch: Vec&lt;Hash&gt;,
   depth: u16,
   path_bitmap: u32,
}</code></pre>
<p><em>fig 3. Merkle proof struct</em></p>
<p>A verifier may now check that the <code>coinbase_tx</code> contains the merge mining hash \( h_m \), and validate the <code>coinbase_merkle_proof</code> against the <code>transaction_root</code>.
The <code>coinbase_merkle_proof</code> contains the minimal proof required to construct the <code>transaction_root</code>.</p>
<p>For example, a proof for a merkle tree of 4 hashes will require 2 hashes (h_1, h_23) of 32 bytes each, 4 bytes for the path bitmap and 2 bytes for the depth.</p>
<pre><code class="language-text">           Root*
         /      \
       h_c1*     h_23
      /    \       
     h_c*     h_1
 
 * Not included in proof
</code></pre>
<h2 id="serialisation"><a class="header" href="#serialisation">Serialisation</a></h2>
<p>For Monero proof-of-work, Monero consensus encoding MUST be used to serialize the <code>MoneroPowData</code> struct. Given the same inputs, 
this encoding will byte-for-byte the same. The encoding uses VarInt for all integer types, allowing byte-savings, in particular
for fields that typically contain small values. Importantly, extra bytes that a miner <em>could</em> tack onto the end of the <code>pow_data</code> field
are expressly disallowed.</p>
<h2 id="merge-mining-proxy"><a class="header" href="#merge-mining-proxy">Merge Mining Proxy</a></h2>
<p>The <a href="https://github.com/tari-project/tari/blob/development/applications/tari_merge_mining_proxy">Tari merge mining proxy</a> proxies the <a href="https://www.getmonero.org/resources/developer-guides/daemon-rpc.html">Monero daemon RPC</a> interface. It behaves as a middleware that implements the merge 
mining protocol detailed above. This allows existing Monero miners to merge mine with Tari without having to make changes 
to mining software. </p>
<p>The proxy must be configured to connect to a <code>monerod</code> instance, a Tari base node, and a Tari console wallet. Most requests
are forwarded &quot;as is&quot; to <code>monerod</code>, however some are intercepted and augmented before being returned to the miner.</p>
<h3 id="get_block_template"><a class="header" href="#get_block_template"><code>get_block_template</code></a></h3>
<p>Once <code>monerod</code> has provided the block template response, the proxy retrieves a Tari block template and coinbase, 
and assembles the Tari block. The merge mining hash \( h_m \) is generated and added to the Monero coinbase. The modified
<code>blockhashing_blob</code> and <code>blocktemplate_blob</code> are returned to the miner. The difficulty is set to <code>min(monero_difficulty, tari_difficulty)</code>
so that the miner submits the found block at either chain's difficulty. The Tari block template is cached for later submission.</p>
<h3 id="submit_block"><a class="header" href="#submit_block"><code>submit_block</code></a></h3>
<p>The miner submits a solved Monero block (at a difficulty of <code>min(monero_difficulty, tari_difficulty)</code>) to the proxy. The cached
Tari block is retrieved, enriched with the <code>MoneroPowData</code> struct and submitted to the Tari base node.</p>
<h1 id="change-log-5"><a class="header" href="#change-log-5">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">26 Oct 2022</td><td style="text-align: left">Stablise RFC</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">21 Oct 2022</td><td style="text-align: left">Update fields</td><td style="text-align: left">Cifko</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0140syncandseeding"><a class="header" href="#rfc-0140syncandseeding">RFC-0140/SyncAndSeeding</a></h1>
<h2 id="synchronizing-the-blockchain-archival-and-pruned-modes"><a class="header" href="#synchronizing-the-blockchain-archival-and-pruned-modes">Synchronizing the Blockchain: Archival and Pruned Modes</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/SWvheerden">S W van Heerden</a></p>
<h1 id="licence-6"><a class="header" href="#licence-6">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-6"><a class="header" href="#language-6">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-6"><a class="header" href="#disclaimer-6">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-6"><a class="header" href="#goals-6">Goals</a></h2>
<p>This Request for Comment (RFC) describes the syncing and pruning process.</p>
<h2 id="related-requests-for-comment-5"><a class="header" href="#related-requests-for-comment-5">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0110_BaseNodes.html">RFC-0110: Base Nodes</a></li>
</ul>
<h2 id="descriptions"><a class="header" href="#descriptions">Descriptions</a></h2>
<h3 id="syncing"><a class="header" href="#syncing">Syncing</a></h3>
<p>When a new node comes online, loses connection or encounters a chain reorganization that is longer than it can tolerate, 
it must enter syncing mode. This will allow it to recover its state to the newest up-to-date state. Syncing can be 
divided into two <a href="Glossary.html#synchronisationstrategy">SynchronizationStrategy</a>s: complete sync and horizon sync. Complete sync means that the node 
communicates with an archive node to get the complete history of every single block from genesis block. Horizon Sync 
involves the node getting every block from its <a href="Glossary.html#pruning-horizon">pruning horizon</a> to <a href="Glossary.html#current-head">current head</a>, as well as every block header 
up to the genesis block. </p>
<p>To determine if the node needs to synchronise, the node will monitor the broadcasted <code>chain_metadata</code> messages provided by its neighbours. The fields in the <code>chain_metadata</code> messages MUST be:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td>height_of_longest_chain</td><td>64-bit unsigned</td></tr>
<tr><td>best_block</td><td>hash of the tip block (32-bit)</td></tr>
<tr><td>pruning_horizon</td><td>64-bit unsigned</td></tr>
<tr><td>pruned_height</td><td>64-bit unsigned</td></tr>
<tr><td>accumulated_difficulty</td><td>128-bit unsigned</td></tr>
<tr><td>timestamp</td><td>64-bit unsigned</td></tr>
</tbody></table>
</div>
<h4 id="complete-sync"><a class="header" href="#complete-sync">Complete Sync</a></h4>
<p>Complete sync is only available from archival nodes, as these will be the only nodes that will be able to supply the 
complete history required to sync every block with every transaction from genesis block up onto <a href="Glossary.html#current-head">current head</a>. </p>
<h4 id="complete-sync-process"><a class="header" href="#complete-sync-process">Complete Sync Process</a></h4>
<p>Once the base node has determined that it is lagging behind the network tip it will start to synchronise with the peer
it determines to have all the data required to synchronise.</p>
<p>The syncing process MUST be done in the following steps:</p>
<ol>
<li>Set <a href="Glossary.html#synchronisationstate">SynchronizationState</a> to <code>header_sync</code>.</li>
<li>Sync all missing headers from the genesis block to the current chain tip. The initial header sync allows the node to
confirm that the syncing peer does indeed have a fully intact chain from which to sync that adheres to this node's
consensus rules and has a valid proof-of-work that is higher than any competing chains.</li>
<li>Set <a href="Glossary.html#synchronisationstate">SynchronizationState</a> to <code>block_sync</code>.</li>
<li>Start downloading blocks from sync peer starting with the oldest block in our database. A fresh node will start from 
the genesis block.</li>
<li>Download all block up to <a href="Glossary.html#current-head">current head</a>, validating and adding the blocks to the local chain storage as we go.</li>
<li>Once all blocks have been downloaded up and including the current network tip set the <a href="Glossary.html#synchronisationstate">SynchronizationState</a> to 
<code>listening</code>.</li>
</ol>
<p>After this process, the node will be in sync, and will be able to process blocks and transactions normally as they 
arrive.</p>
<h4 id="horizon-sync-process"><a class="header" href="#horizon-sync-process">Horizon Sync Process</a></h4>
<p>The horizon sync process MUST be done in the following steps:</p>
<ol>
<li>Set <a href="Glossary.html#synchronisationstate">SynchronizationState</a> to <code>header_sync</code>.</li>
<li>Sync all missing headers from the genesis block to the current chain tip. The initial header sync allows the node to
confirm that the syncing peer does indeed have a fully intact chain from which to sync that adheres to this nodes
consensus rules and has a valid proof-of-work that is higher than any competing chains.</li>
<li>Set <a href="Glossary.html#synchronisationstate">SynchronizationState</a> to <code>horizon_sync</code>.</li>
<li>Download all kernels from the current network tip back to this node's <a href="Glossary.html#pruning-horizon">pruning horizon</a>.</li>
<li>Validate kernel MMR root against headers.</li>
<li>Download all <a href="Glossary.html#unspent-transaction-outputs">utxo</a>'s from the current network tip back to this node's <a href="Glossary.html#pruning-horizon">pruning horizon</a>.</li>
<li>Validate outputs and <a href="Glossary.html#unspent-transaction-outputs">utxo</a> MMR.</li>
<li>Validate the chain balances with the expected total emission that the final sync height.</li>
<li>Once all kernels and <a href="Glossary.html#unspent-transaction-outputs">utxo</a>s have been downloaded from the network tip back to this node's <a href="Glossary.html#pruning-horizon">pruning horizon</a> set 
the <a href="Glossary.html#synchronisationstate">SynchronizationState</a> to <code>block_sync</code>. This hands over further syncing to the standard sync protocol which 
should return to the <code>listening</code> state if no further data has been received from peers.</li>
</ol>
<p>After this process, the node will be in sync, and will be able to process blocks and transactions normally as they
arrive.</p>
<h4 id="keeping-in-sync"><a class="header" href="#keeping-in-sync">Keeping in Sync</a></h4>
<p>The node that is in the <code>listening</code> state SHOULD periodically test a subset of its peers with ping messages to ensure 
that they are alive. When a node sends a ping message, it MUST include the all the <code>chain_metadata</code> fields. The 
receiving node MUST reply with a pong message, which should also include its version of the <code>chain_metadata</code> information.</p>
<p>When a node receives pong replies from the current ping round, or the timeout expires, the collected <code>chain_metadata</code>
replies will be examined to determine what the current best chain is, i.e. the chain with the most accumulated work.
If the best chain is longer than out chain data the node will set <a href="Glossary.html#synchronisationstate">SynchronizationState</a> to <code>header_sync</code> and catch up
with the network.</p>
<h4 id="chain-forks"><a class="header" href="#chain-forks">Chain Forks</a></h4>
<p>Chain forks occur in all decentralized proof-of-work blockchains. When the local node is in the <code>listening</code> state it 
will detect that it has fallen behind other nodes in the network. It will then perform a header sync and during the 
header sync process will be able to detect that a chain fork has occurred. The header sync process will then determine
which chain is the correct chain with the highest accumulated work. If required this node will switch the best chain
and proceed to sync the new blocks required to catch up to the correct chain. This process is called a chain 
reorganization or <a href="Glossary.html#chain-reorg">reorg</a>. </p>
<h3 id="pruning"><a class="header" href="#pruning">Pruning</a></h3>
<p>In Mimblewimble, the state can be completely verified using the current <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> set (which contains the output 
commitments and range proofs), the set of excess signatures (contained in the transaction kernels) and the PoW. The full
block and transaction history is not required. This allows base layer nodes to remove old spent inputs from the 
<a href="Glossary.html#blockchain">blockchain</a> storage. </p>
<p>Pruning is only for the benefit of the local Base Node, as it reduces the local blockchain size. Pruning only happens 
after the block is older than the <a href="Glossary.html#pruning-horizon">pruning horizon</a> height. A Base Node will either run in archival mode or pruned mode.
If the Base Node is running in archive mode, it MUST NOT prune. </p>
<p>When running in pruning mode, <a href="Glossary.html#base-node">Base Node</a>s SHOULD remove all spent outputs that are older than the 
<a href="Glossary.html#pruning-horizon">pruning horizon</a> in their current stored <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> set when a new block is received from another <a href="Glossary.html#base-node">Base Node</a>.</p>
<h1 id="change-log-6"><a class="header" href="#change-log-6">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Date</th><th>Change</th><th>Author</th></tr></thead><tbody>
<tr><td>07 Feb 2019</td><td>First draft</td><td>SWvheerden</td></tr>
<tr><td>13 Jul 2021</td><td>Update to better reflect the current implementation</td><td>philipr-za</td></tr>
<tr><td>30 Sep 2022</td><td>Rename title for clarity</td><td>stringhandler</td></tr>
<tr><td>10 Nov 2022</td><td>Minor update to reflect implementation</td><td>mrnaveira</td></tr>
<tr><td>10 Oct 2023</td><td>Minor update to reflect prune mode pruning interval</td><td>SWvheerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0150wallets"><a class="header" href="#rfc-0150wallets">RFC-0150/Wallets</a></h1>
<h2 id="base-layer-wallet-module"><a class="header" href="#base-layer-wallet-module">Base Layer Wallet Module</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<!-- TOC -->
<ul>
<li><a href="RFC-0150_Wallets.html#rfc-0150wallets">RFC-0150/Wallets</a>
<ul>
<li><a href="RFC-0150_Wallets.html#base-layer-wallet-module">Base Layer Wallet Module</a></li>
</ul>
</li>
<li><a href="RFC-0150_Wallets.html#licence">Licence</a>
<ul>
<li><a href="RFC-0150_Wallets.html#language">Language</a></li>
<li><a href="RFC-0150_Wallets.html#disclaimer">Disclaimer</a></li>
<li><a href="RFC-0150_Wallets.html#goals">Goals</a></li>
<li><a href="RFC-0150_Wallets.html#related-requests-for-comment">Related Requests for Comment</a></li>
<li><a href="RFC-0150_Wallets.html#description">Description</a>
<ul>
<li><a href="RFC-0150_Wallets.html#key-responsibilities">Key Responsibilities</a></li>
<li><a href="RFC-0150_Wallets.html#functional-details">Functional Details</a>
<ul>
<li><a href="RFC-0150_Wallets.html#basic-transaction-functionality">Basic Transaction Functionality</a></li>
<li><a href="RFC-0150_Wallets.html#key-management-features">Key Management Features</a></li>
<li><a href="RFC-0150_Wallets.html#state-recovery">State Recovery</a></li>
<li><a href="RFC-0150_Wallets.html#state-recovery-process-overview">State Recovery: Process Overview</a></li>
</ul>
</li>
<li><a href="RFC-0150_Wallets.html#change-log">Change Log</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- TOC -->
<h1 id="licence-7"><a class="header" href="#licence-7">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-7"><a class="header" href="#language-7">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-7"><a class="header" href="#disclaimer-7">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-7"><a class="header" href="#goals-7">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to propose the functionality and techniques required by the <a href="Glossary.html#base-layer">Base Layer</a>
Tari <a href="Glossary.html#wallet">wallet</a> module. The module exposes the core wallet functionality on which user-facing wallet applications may be built.</p>
<h2 id="related-requests-for-comment-6"><a class="header" href="#related-requests-for-comment-6">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0111_BaseNodeArchitecture.html">RFC-0111: Base Node Architecture</a></li>
</ul>
<p>This RFC is derived from a proposal first made in <a href="https://github.com/tari-project/tari/issues/17">this issue</a>.</p>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<h3 id="key-responsibilities"><a class="header" href="#key-responsibilities">Key Responsibilities</a></h3>
<p>The wallet software is responsible for constructing and negotiating <a href="Glossary.html#transaction">transactions</a> for transferring and receiving
<a href="Glossary.html#tari-coin">Tari coins</a> on the <a href="Glossary.html#base-layer">base layer</a>. It should also provide functionality to generate, store and recover a master seed key
and derived cryptographic keypairs that can be used for Base Layer addresses and signing of transactions.</p>
<h3 id="functional-details"><a class="header" href="#functional-details">Functional Details</a></h3>
<p>A detailed description of the required functionality of the Tari software wallet is provided in three parts:</p>
<ul>
<li>basic transaction functionality,</li>
<li>key management features, and</li>
<li>the different methods for recovering the wallet state of the Tari software wallet.</li>
</ul>
<h4 id="basic-transaction-functionality"><a class="header" href="#basic-transaction-functionality">Basic Transaction Functionality</a></h4>
<ul>
<li>Wallet <strong>MUST</strong> be able to send and receive Tari coins using <a href="Glossary.html#mimblewimble">Mimblewimble</a> transactions.</li>
<li>Wallet <strong>SHOULD</strong> be able to establish a connection with other user wallets to interactively negotiate:
<ul>
<li>construction of the transaction,</li>
<li>signing of multi-signature transactions.</li>
</ul>
</li>
<li>Wallet <strong>SHOULD</strong> be implemented as a library or Application Programming Interface (API) so that Graphical
User Interface (GUI) or Command Line Interface (CLI) applications can be developed on top of it.</li>
<li>Wallet <strong>MUST</strong> be able to establish connection to the <a href="Glossary.html#base-node">base node</a>, submit transactions and monitor the Tari <a href="Glossary.html#blockchain">blockchain</a>.</li>
<li>Wallet <strong>SHOULD</strong> maintain an internal ledger to keep track of the Tari coin balance.</li>
<li>Wallet <strong>MAY</strong> offer transaction fee estimation, taking into account:
<ul>
<li>transaction byte size</li>
<li>network congestion</li>
<li>desired transaction priority</li>
</ul>
</li>
<li>Wallet <strong>SHOULD</strong> be able to monitor and present states (<code>Spent</code>, <code>Unspent</code> or <code>Unconfirmed</code>) of previously submitted transactions,
by querying information from the connected base node.</li>
<li>Wallet <strong>SHOULD</strong> present the total <code>Spent</code>, <code>Unspent</code> or <code>Unconfirmed</code> transactions in a summarized form.</li>
<li>Wallet <strong>SHOULD</strong> be able to update its software to patch potential security vulnerabilities.
Automatic updating <strong>SHOULD</strong> be enabled by default, but users can decide to opt out.</li>
<li>Wallet <strong>SHOULD</strong> feature a caching mechanism for querying operations to reduce bandwidth consumption.</li>
</ul>
<h4 id="key-management-features"><a class="header" href="#key-management-features">Key Management Features</a></h4>
<ul>
<li>Wallet <strong>MUST</strong> be able to generate a master seed key for the wallet by using at least one of the following methods:
<ul>
<li>input from the user (e.g. when restoring a wallet or in testing),</li>
<li>user-defined set of mnemonic word sequences using known word lists,</li>
<li>cryptographically secure random number generator.</li>
</ul>
</li>
<li>Wallet <strong>SHOULD</strong> be able to generate derived, transactional, cryptographic keypairs from the master seed key using deterministic
keypair generation.</li>
<li>Wallet <strong>SHOULD</strong> store wallet state using a password or passphrase encrypted persistent key-value database.</li>
<li>Wallet <strong>SHOULD</strong> provide the ability to store backup of the wallet state to a single encrypted file to simplify wallet recovery and
reconstruction at a later stage.</li>
<li>Wallet <strong>MAY</strong> provide the ability to export the master seed key or the wallet state as a printable paper wallet, using coded markers.</li>
</ul>
<h4 id="state-recovery"><a class="header" href="#state-recovery">State Recovery</a></h4>
<ul>
<li>Wallet <strong>MUST</strong> be able to reconstruct the wallet state from a manually entered master seed key.</li>
<li>Wallet <strong>MUST</strong> have a mechanism to systematically scan through the Tari blockchain and <a href="RFC-0190_Mempool.html">mempool</a> for <code>Unspent</code> and <code>Unconfirmed</code>
transactions, using keys derived from the master key.</li>
<li>The master seed key <strong>SHOULD</strong> be derivable from a set of mnemonic word sequences using known word lists.</li>
<li>Wallet <strong>MAY</strong> enable the reconstruction of the master seed key by scanning a coded marker of a paper wallet.</li>
</ul>
<h4 id="state-recovery-process-overview"><a class="header" href="#state-recovery-process-overview">State Recovery: Process Overview</a></h4>
<p>If the wallet database has been lost, corrupted or otherwise damaged, the outputs contained within (<a href="Glossary.html#unspent-transaction-outputs">UTXOs</a>)
can still be recovered from the Tari <a href="Glossary.html#blockchain">blockchain</a>, given you provide the valid recovery keys. When the wallet is first initialized in recovery mode,
it attempts to synchronize with available base nodes, pulling blocks, attempting to recognize outputs attributed to that particular wallet.</p>
<p>If one can successfully decrypt the encrypted value, then the UTXO is successfully recognized. The next step is to attempt the mask (blinding factor)
recovery by rewinding the range proof. All recognized and verified outputs are stored in the newly initialized, local wallet database,
available for further spending.</p>
<p>The recovery of simple and stealth one-sided outputs is a bit more complex as we first have to recognize the output by its script pattern, before we can try
to decrypt the encrypted value.</p>
<p>An output is recognized if it matches either of the following input script patterns:</p>
<ul>
<li>The standard output is the simplest, having a single <code>Nop</code> instruction.</li>
<li>The simple one-sided is matched by the <code>[Opcode::PushPubKey(scanned_pk)]</code> so if the <code>scanned_pk</code> matches the key derived from the recovery phrase - it's recognized,</li>
<li>The <a href="RFC-0203_StealthAddresses.html">stealth one-sided</a> is similar to its simple counterpart with only the script pattern being different <code>[Opcode::PushPubKey(nonce), Opcode::Drop, Opcode::PushPubKey(scanned_pk)]</code>, matching by the last provided <code>Opcode::PushPubKey(scanned_pk)</code> instruction.</li>
</ul>
<h3 id="change-log-7"><a class="header" href="#change-log-7">Change Log</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">26 Oct 2022</td><td style="text-align: left">Stabilized RFC</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">14 Nov 2022</td><td style="text-align: left">Added table of contents, recovery process overview and a few minor adjustments</td><td style="text-align: left">agubarev &amp; hansieodendaal</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0155tariaddress"><a class="header" href="#rfc-0155tariaddress">RFC-0155/TariAddress</a></h1>
<h2 id="tariaddress-specification"><a class="header" href="#tariaddress-specification">TariAddress specification</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>:<a href="https://github.com/swvheerden">SW van Heerden</a></p>
<h1 id="licence-8"><a class="header" href="#licence-8">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2024. The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-8"><a class="header" href="#language-8">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-8"><a class="header" href="#disclaimer-8">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-8"><a class="header" href="#goals-8">Goals</a></h2>
<p>This document outlines the specification for Tari Address, which are encoded wallet addresses used to verify wallet addresses, features, and networks. 
The address should have human-readable network and feature identification and contain all information required to send transactions to a wallet owning an address.</p>
<h2 id="related-requests-for-comment-7"><a class="header" href="#related-requests-for-comment-7">Related Requests for Comment</a></h2>
<p>None</p>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>Wallet addresses should contain all the necessary information for sending transactions to the corresponding wallet. Initially, a wallet must declare its supported features and the network it
operates on. To maintain readability, distinct identifiers are required for both the features and the network.</p>
<p>For typical interactive Mimblewimble (MW) transactions, a public key is necessary for communication. The private key associated with this MUST BE securely stored by the node to prevent spoofing.
This private key functions as the spend key for deriving the actual spend key for the Unspent Transaction Output (UTXO).</p>
<p>However, when non-interactive transactions are initiated, the process becomes more complex. If the receiving wallet is a standard one, it possesses all the essential information for spending
the transaction. Yet, if the recipient utilizes a hardware device like a ledger, the spending information is inaccessible to the wallet. Thus, a secondary view key becomes necessary.
While the wallet can share the private key of this view key with another party for UTXO viewing purposes, it cannot be used for spending.</p>
<p>Additionally, a checksum can be included to detect errors when encoding the address as bytes. Emojis can also be easily incorporated into the encoding process by assigning each u8 an emoji.</p>
<h2 id="the-specification"><a class="header" href="#the-specification">The specification</a></h2>
<h3 id="address"><a class="header" href="#address">Address</a></h3>
<p>Each address consists of four parts: View key, Spend key, Network, and Features.</p>
<h4 id="view-key"><a class="header" href="#view-key">View key</a></h4>
<p>This key allows a node to grant view access to its transactions. Possession of the private key in this key pair SHOULD enable an entity to view all transactions associated with a wallet.</p>
<h4 id="spend-key"><a class="header" href="#spend-key">Spend key</a></h4>
<p>Utilized to compute the spend key of a UTXO and communicate with the node over the network. The private key associated with this key pair must be securely kept hidden.</p>
<h4 id="features"><a class="header" href="#features">Features</a></h4>
<p>Indicates the supported features of the wallet, such as interactive and one-sided transactions. Currently, this is represented by an encoded u8, with each bit denoting a specific feature.</p>
<h4 id="network"><a class="header" href="#network">Network</a></h4>
<p>Specifies the Tari network the wallet operates on, e.g., Esmeralda, Nextnet, etc.</p>
<h4 id="checksum"><a class="header" href="#checksum">Checksum</a></h4>
<p>The checksum is only included when encoding the address as bytes, hex, or emojis. For the checksum, the: <a href="https://github.com/cypherstack/dammsum">DammSum</a> algorithm is employed,
with <code>k = 8</code> and <code>m = 32</code>, resulting in an 8-bit checksum.</p>
<h4 id="payment-id"><a class="header" href="#payment-id">Payment ID</a></h4>
<p>Tari includes an optional encrypted bytes field with a max size of 256 bytes. This field allows you to store bytes that are encrypted on chain, on the UTXO. This can be used to track payments etc. When included into the Tari address, the sent UTXO will include this payment id.</p>
<h3 id="encoding"><a class="header" href="#encoding">Encoding</a></h3>
<h4 id="bytes"><a class="header" href="#bytes">Bytes</a></h4>
<p>When generating a byte representation of the wallet, the following format is used:
[0]: Network encoded as u8
[1]: Raw u8 representing features
[2..33]: Public view key encoded as u8
[35..65]: Public spend key encoded as u8
[66..N]: Payment ID, optional field encoded as [u8]
[N]: DammSum checksum</p>
<p>For nodes lacking a distinct view key, where the view key and spend key are identical, their addresses can be encoded as follows:
[0]: Network encoded as u8
[1]: Raw u8 representing features
[2..33]: Public spend key encoded as u8
[34]: DammSum checksum</p>
<h4 id="hex"><a class="header" href="#hex">Hex</a></h4>
<p>Each byte in the byte representation is encoded as two hexadecimal characters.</p>
<h4 id="base58"><a class="header" href="#base58">Base58</a></h4>
<p>Base58 encoding is also used by TariAddress. When encoding the following format is used:
[0]: Network byte encoded as base58 character
[1]: Raw u8 representing features base58 character
[2..N]: Remaing bytes encoded as base58</p>
<h4 id="emoji-encoding"><a class="header" href="#emoji-encoding">Emoji Encoding</a></h4>
<p>An emoji alphabet of 256 characters has been selected, each assigned a unique index from 0 to 255 inclusive.
The list of chosen emojis is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>🦋</td><td>📟</td><td>🌈</td><td>🌊</td><td>🎯</td><td>🐋</td><td>🌙</td><td>🤔</td><td>🌕</td><td>⭐</td><td>🎋</td><td>🌰</td><td>🌴</td><td>🌵</td><td>🌲</td><td>🌸</td></tr>
<tr><td>🌹</td><td>🌻</td><td>🌽</td><td>🍀</td><td>🍁</td><td>🍄</td><td>🥑</td><td>🍆</td><td>🍇</td><td>🍈</td><td>🍉</td><td>🍊</td><td>🍋</td><td>🍌</td><td>🍍</td><td>🍎</td></tr>
<tr><td>🍐</td><td>🍑</td><td>🍒</td><td>🍓</td><td>🍔</td><td>🍕</td><td>🍗</td><td>🍚</td><td>🍞</td><td>🍟</td><td>🥝</td><td>🍣</td><td>🍦</td><td>🍩</td><td>🍪</td><td>🍫</td></tr>
<tr><td>🍬</td><td>🍭</td><td>🍯</td><td>🥐</td><td>🍳</td><td>🥄</td><td>🍵</td><td>🍶</td><td>🍷</td><td>🍸</td><td>🍾</td><td>🍺</td><td>🍼</td><td>🎀</td><td>🎁</td><td>🎂</td></tr>
<tr><td>🎃</td><td>🤖</td><td>🎈</td><td>🎉</td><td>🎒</td><td>🎓</td><td>🎠</td><td>🎡</td><td>🎢</td><td>🎣</td><td>🎤</td><td>🎥</td><td>🎧</td><td>🎨</td><td>🎩</td><td>🎪</td></tr>
<tr><td>🎬</td><td>🎭</td><td>🎮</td><td>🎰</td><td>🎱</td><td>🎲</td><td>🎳</td><td>🎵</td><td>🎷</td><td>🎸</td><td>🎹</td><td>🎺</td><td>🎻</td><td>🎼</td><td>🎽</td><td>🎾</td></tr>
<tr><td>🎿</td><td>🏀</td><td>🏁</td><td>🏆</td><td>🏈</td><td>⚽</td><td>🏠</td><td>🏥</td><td>🏦</td><td>🏭</td><td>🏰</td><td>🐀</td><td>🐉</td><td>🐊</td><td>🐌</td><td>🐍</td></tr>
<tr><td>🦁</td><td>🐐</td><td>🐑</td><td>🐔</td><td>🙈</td><td>🐗</td><td>🐘</td><td>🐙</td><td>🐚</td><td>🐛</td><td>🐜</td><td>🐝</td><td>🐞</td><td>🐢</td><td>🐣</td><td>🐨</td></tr>
<tr><td>🦀</td><td>🐪</td><td>🐬</td><td>🐭</td><td>🐮</td><td>🐯</td><td>🐰</td><td>🦆</td><td>🦂</td><td>🐴</td><td>🐵</td><td>🐶</td><td>🐷</td><td>🐸</td><td>🐺</td><td>🐻</td></tr>
<tr><td>🐼</td><td>🐽</td><td>🐾</td><td>👀</td><td>👅</td><td>👑</td><td>👒</td><td>🧢</td><td>💅</td><td>👕</td><td>👖</td><td>👗</td><td>👘</td><td>👙</td><td>💃</td><td>👛</td></tr>
<tr><td>👞</td><td>👟</td><td>👠</td><td>🥊</td><td>👢</td><td>👣</td><td>🤡</td><td>👻</td><td>👽</td><td>👾</td><td>🤠</td><td>👃</td><td>💄</td><td>💈</td><td>💉</td><td>💊</td></tr>
<tr><td>💋</td><td>👂</td><td>💍</td><td>💎</td><td>💐</td><td>💔</td><td>🔒</td><td>🧩</td><td>💡</td><td>💣</td><td>💤</td><td>💦</td><td>💨</td><td>💩</td><td>➕</td><td>💯</td></tr>
<tr><td>💰</td><td>💳</td><td>💵</td><td>💺</td><td>💻</td><td>💼</td><td>📈</td><td>📜</td><td>📌</td><td>📎</td><td>📖</td><td>📿</td><td>📡</td><td>⏰</td><td>📱</td><td>📷</td></tr>
<tr><td>🔋</td><td>🔌</td><td>🚰</td><td>🔑</td><td>🔔</td><td>🔥</td><td>🔦</td><td>🔧</td><td>🔨</td><td>🔩</td><td>🔪</td><td>🔫</td><td>🔬</td><td>🔭</td><td>🔮</td><td>🔱</td></tr>
<tr><td>🗽</td><td>😂</td><td>😇</td><td>😈</td><td>🤑</td><td>😍</td><td>😎</td><td>😱</td><td>😷</td><td>🤢</td><td>👍</td><td>👶</td><td>🚀</td><td>🚁</td><td>🚂</td><td>🚚</td></tr>
<tr><td>🚑</td><td>🚒</td><td>🚓</td><td>🛵</td><td>🚗</td><td>🚜</td><td>🚢</td><td>🚦</td><td>🚧</td><td>🚨</td><td>🚪</td><td>🚫</td><td>🚲</td><td>🚽</td><td>🚿</td><td>🧲</td></tr>
</tbody></table>
</div>
<p>These emojis are selected to ensure:</p>
<ul>
<li>Exclusion of similar-looking emojis to avoid confusion.</li>
<li>Only the &quot;base&quot; emoji are considered; modified emojis (e.g., skin tones, gender modifiers) are excluded.</li>
<li>Match emoji's used by Yat.</li>
</ul>
<p>Each byte is encoded using the emoji listed at the corresponding index.</p>
<h2 id="change-log-8"><a class="header" href="#change-log-8">Change Log</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">2024-05-31</td><td style="text-align: left">Initial stable</td><td style="text-align: left">SWvHeerden</td></tr>
<tr><td style="text-align: left">2025-04-30</td><td style="text-align: left">Add payment ID</td><td style="text-align: left">SWvHeerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0160blockserialization"><a class="header" href="#rfc-0160blockserialization">RFC-0160/BlockSerialization</a></h1>
<h2 id="tari-block-binary-serialization"><a class="header" href="#tari-block-binary-serialization">Tari Block Binary Serialization</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-9"><a class="header" href="#licence-9">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-9"><a class="header" href="#language-9">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-9"><a class="header" href="#disclaimer-9">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-9"><a class="header" href="#goals-9">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to specify the binary serialization of:</p>
<ol>
<li>a mined Tari block</li>
<li>a Tari block mining template</li>
</ol>
<p>This is to facilitate interoperability of mining software and hardware.</p>
<h2 id="related-requests-for-comment-8"><a class="header" href="#related-requests-for-comment-8">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0131_Mining.html">RFC-0131: Full-node Mining on Tari Base Layer</a></li>
</ul>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<p>By reviewing the <a href="RFC-0160_BlockSerialization.html#tari-block-and-mining-template---data-types">block and mining template fields</a> below, we have the 
following underlying data types for serialization:</p>
<ol>
<li><code>bool</code></li>
<li><code>u8</code></li>
<li><code>u16</code></li>
<li><code>u64</code></li>
<li><code>i64</code></li>
<li><code>array</code> of type <code>[u8; n]</code></li>
<li><code>Vec&lt;T&gt;</code> where <code>T</code> is <code>u8</code>, <code>enum</code> or <code>array</code></li>
</ol>
<p>For 1. to 5. and all numbers, <a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Base 128 Varint</a> encoding MUST be used.</p>
<p>From the Protocol Buffers documentation:</p>
<blockquote>
<p>Varints are a method of serializing integers using one or more bytes. Smaller numbers take a smaller number of bytes. 
Each byte in a varint, except the last byte, has the most significant bit (msb) set – this indicates that there are 
further bytes to come. The lower 7 bits of each byte are used to store the two's complement representation of the 
number in groups of 7 bits, least significant group first.</p>
</blockquote>
<p>For 6. to 7., the dynamically sized <code>array</code> and <code>Vec</code> type, the encoded array MUST be preceded by a number indicating the 
length of the array. This length MUST also be encoded as a varint. By prepending the length of the array, the decoder 
knows how many elements to decode as part of the sequence.</p>
<h2 id="block-field-ordering"><a class="header" href="#block-field-ordering">Block field ordering</a></h2>
<p>Using this varint encoding, all fields of the complete block MUST be encoded in the following order:</p>
<ol>
<li>Version</li>
<li>Height</li>
<li>Previous block hash</li>
<li>Timestamp</li>
<li>Output Merkle root</li>
<li>Witness Merkle root</li>
<li>Output Merkle mountain range size</li>
<li>Kernel Merkle root</li>
<li>Kernel Merkle mountain range size</li>
<li>Input Merkle root</li>
<li>Total kernel offset</li>
<li>Total script offset</li>
<li>Nonce</li>
<li>Proof of work algorithm</li>
<li>Proof of work supplemental data</li>
<li>Transaction inputs - for each input:
<ul>
<li>Version </li>
<li>Spent output - for each output:
<ul>
<li>Version</li>
<li>Features
<ul>
<li>Version</li>
<li>Maturity</li>
<li>Output type</li>
<li>Sidechain features</li>
<li>Metadata</li>
</ul>
</li>
<li>Commitment</li>
<li>Script</li>
<li>Sender offset public key</li>
<li>Covenant</li>
<li>Encrypted value</li>
<li>Minimum value promise</li>
</ul>
</li>
<li>Input data (<a href="https://doc.rust-lang.org/rust-by-example/std/vec.html">vector</a> of Stack items)</li>
<li>Script signature</li>
</ul>
</li>
<li>Transaction outputs - for each output:
<ul>
<li>Version</li>
<li>Features
<ul>
<li>Version</li>
<li>Maturity</li>
<li>Output type</li>
<li>Sidechain features</li>
<li>Metadata</li>
</ul>
</li>
<li>Commitment</li>
<li>Range proof</li>
<li>Script</li>
<li>Sender offset public key</li>
<li>Metadata signature</li>
<li>Covenant</li>
<li>Encrypted value</li>
<li>Minimum value promise</li>
</ul>
</li>
<li>Transaction kernels - for each kernel:
<ul>
<li>Version</li>
<li>Features</li>
<li>Fee</li>
<li>Lock height</li>
<li>Excess</li>
<li>Excess signature public nonce</li>
<li>Excess signature</li>
<li>Burn commitment</li>
</ul>
</li>
</ol>
<h2 id="mining-template-field-ordering"><a class="header" href="#mining-template-field-ordering">Mining template field ordering</a></h2>
<p>The <a href="RFC-0160_BlockSerialization.html#new-block-template">new block template</a> is provided to miners to complete. Its fields MUST also be encoded using varints, in the following order:</p>
<ol>
<li>Version</li>
<li>Height</li>
<li>Previous block hash</li>
<li>Total kernel offset</li>
<li>Total script offset</li>
<li>Proof of work algorithm</li>
<li>Proof of work supplemental data</li>
<li>Transaction inputs - for each input:
<ul>
<li>Version</li>
<li>Spent output - for each output:
<ul>
<li>Version</li>
<li>Features
<ul>
<li>Version</li>
<li>Maturity</li>
<li>Output type</li>
<li>Sidechain features</li>
<li>Metadata</li>
</ul>
</li>
<li>Commitment</li>
<li>Script</li>
<li>Sender offset public key</li>
<li>Covenant</li>
<li>Encrypted value</li>
<li>Minimum value promise</li>
</ul>
</li>
<li>Input data (<a href="https://doc.rust-lang.org/rust-by-example/std/vec.html">vector</a> of Stack items)</li>
<li>Script signature</li>
</ul>
</li>
<li>Transaction outputs - for each output:
<ul>
<li>Version</li>
<li>Features
<ul>
<li>Version</li>
<li>Maturity</li>
<li>Output type</li>
<li>Sidechain features</li>
<li>Metadata</li>
</ul>
</li>
<li>Commitment</li>
<li>Range proof</li>
<li>Script</li>
<li>Sender offset public key</li>
<li>Metadata signature</li>
<li>Covenant</li>
<li>Encrypted value</li>
<li>Minimum value promise</li>
</ul>
</li>
<li>Transaction kernels - for each kernel:
<ul>
<li>Version</li>
<li>Features</li>
<li>Fee</li>
<li>Lock height</li>
<li>Excess</li>
<li>Excess signature public nonce</li>
<li>Excess signature</li>
<li>Burn commitment</li>
</ul>
</li>
<li>Target difficulty</li>
<li>Reward</li>
<li>Total fees</li>
</ol>
<h2 id="value-encryption"><a class="header" href="#value-encryption">Value encryption</a></h2>
<p>The value of the value commitment MUST be encrypted using <a href="https://en.wikipedia.org/wiki/ChaCha20-Poly1305">ChaCha20Poly1305</a>
Authenticated Encryption with Additional Data (AEAD). The AEAD key MUST be 32 bytes in size and produced using a
<a href="RFC-0160_BlockSerialization.html#hash-domains">domain separated hash</a> of the private key and commitment.</p>
<h2 id="hash-domains"><a class="header" href="#hash-domains">Hash domains</a></h2>
<p>To use a single hash function for producing a sampling of multiple independent hash functions, it's common to employ 
domain separation. Tari uses the <a href="https://github.com/tari-project/tari-crypto/blob/main/src/hashing.rs">hashing API</a> 
within the tari codebase to achieve proper hash domain separation.</p>
<p>The following functional areas MUST each use a separate hash domain that is unique in the tari codebase:</p>
<ul>
<li>kernel Merkle Mointain Range;</li>
<li>witness MMR;</li>
<li>output MMR;</li>
<li>input MMR;</li>
<li>value encryption.</li>
</ul>
<p>To achieve interoperability with other blockchains like Bitcoin and Monero, for example an atomic swap, TariScript MUST 
NOT make use of hash domains.</p>
<h2 id="tari-block-and-mining-template---data-types"><a class="header" href="#tari-block-and-mining-template---data-types">Tari Block and Mining Template - Data Types</a></h2>
<p>A <a href="https://github.com/tari-project/tari/blob/development/base_layer/core/src/blocks/block.rs">Tari block</a> is composed of the <a href="Glossary.html#block-header">block header</a> and <a href="Glossary.html#block-body">aggregate body</a>.</p>
<p>Here we describe the respective Rust types of these fields in the tari codebase, and their underlying data types:</p>
<h3 id="block-header"><a class="header" href="#block-header">Block Header</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Version</td><td><code>u16</code></td><td><code>u16</code></td><td>The Tari protocol version number, used for soft/hard forks</td></tr>
<tr><td>Height</td><td><code>u64</code></td><td><code>u64</code></td><td>Height of this block since the genesis block</td></tr>
<tr><td>Previous Block Hash</td><td><code>BlockHash</code></td><td><code>[u8;32]</code></td><td>Hash of the previous block in the chain</td></tr>
<tr><td>Timestamp</td><td><code>EpochTime</code></td><td><code>u64</code></td><td>Timestamp at which the block was built (number of seconds since Unix epoch)</td></tr>
<tr><td>Output Merkle Root</td><td><code>BlockHash</code></td><td><code>[u8;32]</code></td><td>Merkle Root of the unspent transaction ouputs</td></tr>
<tr><td>Witness Merkle Root</td><td><code>BlockHash</code></td><td><code>[u8;32]</code></td><td>MMR root of the witness proofs</td></tr>
<tr><td>Output MMR Size</td><td><code>u64</code></td><td><code>u64</code></td><td>The size (number of leaves) of the output and range proof MMRs at the time of this header</td></tr>
<tr><td>Kernel Merkle Root</td><td><code>BlockHash</code></td><td><code>[u8;32]</code></td><td>MMR root of the transaction kernels</td></tr>
<tr><td>Kernel MMR Size</td><td><code>u64</code></td><td><code>u64</code></td><td>Number of leaves in the kernel MMR</td></tr>
<tr><td>Input Merkle Root</td><td><code>BlockHash</code></td><td><code>[u8;32]</code></td><td>Merkle Root of the transaction inputs in this block</td></tr>
<tr><td>Total Kernel Offset</td><td><code>BlindingFactor</code></td><td><code>[u8;32]</code></td><td>Sum of kernel offsets for all transaction kernels in this block</td></tr>
<tr><td>Total Script Offset</td><td><code>BlindingFactor</code></td><td><code>[u8;32]</code></td><td>Sum of script offsets for all transaction kernels in this block</td></tr>
<tr><td>Nonce</td><td><code>u64</code></td><td><code>u64</code></td><td>Nonce increment used to mine this block</td></tr>
<tr><td>Pow</td><td><code>ProofOfWork</code></td><td>See <a href="RFC-0160_BlockSerialization.html#proof-of-work">Proof Of Work</a></td><td>Proof of Work information</td></tr>
</tbody></table>
</div>
<p><code>[u8;32]</code> indicates an array of 32 unsigned 8-bit integers</p>
<h4 id="proof-of-work-1"><a class="header" href="#proof-of-work-1">Proof Of Work</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Proof of Work Algorithm</td><td><code>PowAlgorithm</code></td><td><code>u8</code></td><td>The algorithm used to mine this block ((Monero or SHA3))</td></tr>
<tr><td>Proof of Work Data</td><td><code>Vec&lt;u8&gt;</code></td><td><code>u8</code></td><td>Supplemental proof of work data. For example for Sha3, this would be empty (only the block header is required), but for Monero merge mining we need the Monero block header and RandomX seed hash</td></tr>
</tbody></table>
</div>
<h3 id="block-body"><a class="header" href="#block-body">Block Body</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Sorted</td><td><code>bool</code></td><td><code>bool</code></td><td>True if sorted</td></tr>
<tr><td>Transaction Inputs</td><td><code>Vec&lt;TransactionInput&gt;</code></td><td><code>TransactionInput</code></td><td>List of inputs spent</td></tr>
<tr><td>Transaction Outputs</td><td><code>Vec&lt;TransactionOutput&gt;</code></td><td><code>TransactionOutput</code></td><td>List of outputs produced</td></tr>
<tr><td>Transaction Kernels</td><td><code>Vec&lt;TransactionKernel&gt;</code></td><td><code>TransactionKernel</code></td><td>Kernels contain the excesses and their signatures for the transactions</td></tr>
</tbody></table>
</div>
<p>A further breakdown of the body fields is described below:</p>
<h4 id="transactioninput"><a class="header" href="#transactioninput">TransactionInput</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Version</td><td><code>TransactionInputVersion</code></td><td><code>u16</code></td><td>The features of the output being spent. We will check maturity for all outputs.</td></tr>
<tr><td>Spent Output</td><td><code>SpentOutput</code></td><td>See <a href="RFC-0160_BlockSerialization.html#spentoutput">SpentOutput</a></td><td>Either the hash of TransactionOutput that this Input is spending or its data</td></tr>
<tr><td>Input Data</td><td><code>ExecutionStack</code></td><td><code>Vec&lt;u8&gt;</code></td><td>The script input data, maximum size is 512</td></tr>
<tr><td>Script Signature</td><td><code>CommitmentAndPublicKeySignature</code></td><td>See <a href="RFC-0160_BlockSerialization.html#commitmentandpublickeysignature">CommitmentAndPublicKeySignature</a></td><td>A signature signing the script and all other transaction input metadata with the script private key</td></tr>
</tbody></table>
</div>
<h5 id="spentoutput"><a class="header" href="#spentoutput">SpentOutput</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>OutputHash</td><td><code>HashOutput</code></td><td><code>[u8;32]</code></td><td>The features of the output being spent. We will check maturity for all outputs.</td></tr>
<tr><td>Version</td><td><code>TransactionOutputVersion</code></td><td><code>u8</code></td><td>The TransactionOutput version</td></tr>
<tr><td>Features</td><td><code>OutputFeatures</code></td><td>See <a href="RFC-0160_BlockSerialization.html#outputfeatures">OutputFeatures</a></td><td>Options for the output's structure or use</td></tr>
<tr><td>Commitment</td><td><code>PedersenCommitment</code></td><td><code>[u8;32]</code></td><td>The commitment referencing the output being spent.</td></tr>
<tr><td>Script</td><td><code>TariScript</code></td><td><code>Vec&lt;u8&gt;</code></td><td>The serialised script, maximum size is 512</td></tr>
<tr><td>Sender Offset Public Key</td><td><code>CommitmentAndPublicKeySignature</code></td><td><code>[u8;32]</code></td><td>The Tari script sender offset public key</td></tr>
<tr><td>Covenant</td><td><code>Vec&lt;CovenantToken&gt;</code></td><td>See <a href="RFC-0160_BlockSerialization.html#covenanttoken">CovenantToken</a></td><td>A future-based contract detailing input and output metadata</td></tr>
<tr><td>Encrypted Value</td><td><code>EncryptedValue</code></td><td><code>[u8;24]</code></td><td>The encrypted value of the value commitment</td></tr>
<tr><td>Minimum Value Promise</td><td><code>MicroTari</code></td><td><code>u64</code> <em>(See <a href="RFC-0160_BlockSerialization.html#value-encryption">Value encryption</a>)</em></td><td>The minimum value promise embedded in the range proof</td></tr>
</tbody></table>
</div>
<h5 id="commitmentandpublickeysignature"><a class="header" href="#commitmentandpublickeysignature">CommitmentAndPublicKeySignature</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Public Nonce</td><td><code>PedersenCommitment</code></td><td><code>[u8;32]</code></td><td>The public (Pedersen) commitment nonce created with the two random nonces</td></tr>
<tr><td><code>u</code></td><td><code>SecretKey</code></td><td><code>[u8;32]</code></td><td>The first publicly known private key of the signature signing with the value</td></tr>
<tr><td><code>v</code></td><td><code>SecretKey</code></td><td><code>[u8;32]</code></td><td>The second publicly known private key of the signature signing with the blinding factor</td></tr>
<tr><td>Public Key</td><td><code>PedersenCommitment</code></td><td><code>[u8;32]</code></td><td>The public nonce of the Schnorr signature</td></tr>
<tr><td><code>a</code></td><td><code>SecretKey</code></td><td><code>[u8;32]</code></td><td>The publicly known private key of the Schnorr signature</td></tr>
</tbody></table>
</div>
<p>Find out more about CommitmentAndPublicKey signatures:</p>
<ul>
<li><a href="https://eprint.iacr.org/2020/061.pdf">Simple Schnorr Signature with Pedersen Commitment as Key</a></li>
<li><a href="https://documents.uow.edu.au/~wsusilo/ZCMS_IJNS08.pdf">A New and Efficient Signature on Commitment Values</a></li>
<li><a href="https://github.com/tari-project/tari-crypto/blob/main/src/signatures/commitment_and_public_key_signature.rs">Tari Commitment and Public Key Signature</a></li>
</ul>
<h5 id="outputfeatures"><a class="header" href="#outputfeatures">OutputFeatures</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Version</td><td><code>OutputFeaturesVersion</code></td><td><code>u8</code></td><td>The OutputFeatures version</td></tr>
<tr><td>Output Type</td><td><code>OutputType</code></td><td><code>u8</code></td><td>The type of output</td></tr>
<tr><td>Maturity</td><td><code>u64</code></td><td><code>u64</code></td><td>The block height at which the output can be spent</td></tr>
<tr><td>Metadata</td><td><code>Vec&lt;u8&gt;</code></td><td><code>u8</code></td><td>The block height at which the output can be spent</td></tr>
<tr><td>Side-chain Features</td><td><code>SideChainFeatures</code></td><td><em>none</em></td><td><em>Not implemented</em></td></tr>
</tbody></table>
</div>
<h5 id="covenanttoken"><a class="header" href="#covenanttoken">CovenantToken</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Filter</td><td><code>CovenantFilter</code></td><td>See <a href="RFC-0160_BlockSerialization.html#covenantfilter">CovenantFilter</a></td><td>The covenant filter</td></tr>
<tr><td>Arg</td><td><code>CovenantArg</code></td><td>See <a href="RFC-0160_BlockSerialization.html#covenantarg">CovenantArg</a></td><td>The covenant argument(s)</td></tr>
</tbody></table>
</div>
<h5 id="covenantfilter"><a class="header" href="#covenantfilter">CovenantFilter</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Identity</td><td><code>IdentityFilter</code></td><td><em>none</em></td><td>The Identity</td></tr>
<tr><td>And</td><td><code>AndFilter</code></td><td><em>none</em></td><td>And operation</td></tr>
<tr><td>Or</td><td><code>OrFilter</code></td><td><em>none</em></td><td>Or operation</td></tr>
<tr><td>Xor</td><td><code>XorFilter</code></td><td><em>none</em></td><td>Xor operation</td></tr>
<tr><td>Not</td><td><code>NotFilter</code></td><td><em>none</em></td><td>Not operation</td></tr>
<tr><td>Output Hash Equal</td><td><code>OutputHashEqFilter</code></td><td><em>none</em></td><td>Output hash to be equal to</td></tr>
<tr><td>Fields Preserved</td><td><code>FieldsPreservedFilter</code></td><td><em>none</em></td><td>Fields to be preserved</td></tr>
<tr><td>Field Equal</td><td><code>FieldEqFilter</code></td><td><em>none</em></td><td>Field to be equal to</td></tr>
<tr><td>Fields Hashed Equal</td><td><code>FieldsHashedEqFilter</code></td><td><em>none</em></td><td>Fields hashed to be equal to</td></tr>
<tr><td>Absolute Height</td><td><code>AbsoluteHeightFilter</code></td><td><em>none</em></td><td>Absolute height</td></tr>
</tbody></table>
</div>
<h5 id="covenantarg"><a class="header" href="#covenantarg">CovenantArg</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Hash</td><td><code>FixedHash</code></td><td><code>[u8;32]</code></td><td>Future hash value</td></tr>
<tr><td>PublicKey</td><td><code>PublicKey</code></td><td><code>[u8;32]</code></td><td>Future public key</td></tr>
<tr><td>Commitment</td><td><code>PedersenCommitment</code></td><td><code>[u8;32]</code></td><td>Future commitment referencing the output being spent.</td></tr>
<tr><td>Tari Script</td><td><code>TariScript</code></td><td><code>Vec&lt;u8&gt;</code></td><td>Future serialised script, maximum size is 512</td></tr>
<tr><td>Covenant</td><td><code>Vec&lt;CovenantToken&gt;</code></td><td>See <a href="RFC-0160_BlockSerialization.html#covenanttoken">CovenantToken</a></td><td>Future covenant</td></tr>
<tr><td>Output Type</td><td><code>OutputType</code></td><td><code>u8</code></td><td>Future type of output</td></tr>
<tr><td>Uint</td><td><code>Uint</code></td><td><code>u64</code></td><td>Future value</td></tr>
<tr><td>Output Field</td><td><code>OutputField</code></td><td>See <a href="RFC-0160_BlockSerialization.html#outputfield">OutputField</a></td><td>Future set of output fields</td></tr>
<tr><td>OutputFields</td><td><code>Vec&lt;OutputField&gt;</code></td><td>See <a href="RFC-0160_BlockSerialization.html#outputfield">OutputField</a></td><td>Future set of output fields</td></tr>
<tr><td>Bytes</td><td><code>Vec&lt;u8&gt;</code></td><td><code>u8</code></td><td>Future raw data</td></tr>
</tbody></table>
</div>
<h5 id="outputfield"><a class="header" href="#outputfield">OutputField</a></h5>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Commitment</td><td><code>u8</code></td><td><code>u8</code></td><td>Commitment byte code</td></tr>
<tr><td>Script</td><td><code>u8</code></td><td><code>u8</code></td><td>Script byte code</td></tr>
<tr><td>Sender Offset Public Key</td><td><code>u8</code></td><td><code>u8</code></td><td>SenderOffsetPublicKey byte code</td></tr>
<tr><td>Covenant</td><td><code>u8</code></td><td><code>u8</code></td><td>Covenant byte code</td></tr>
<tr><td>Features</td><td><code>u8</code></td><td><code>u8</code></td><td>Features byte code</td></tr>
<tr><td>Features Output Type</td><td><code>u8</code></td><td><code>u8</code></td><td>FeaturesOutputType byte code</td></tr>
<tr><td>Features Maturity</td><td><code>u8</code></td><td><code>u8</code></td><td>FeaturesMaturity byte code</td></tr>
<tr><td>Features Metadata</td><td><code>u8</code></td><td><code>u8</code></td><td>FeaturesMetadata byte code</td></tr>
<tr><td>Features Side Chain Features</td><td><code>u8</code></td><td><code>u8</code></td><td>FeaturesSideChainFeatures byte code</td></tr>
</tbody></table>
</div>
<h4 id="transactionoutput"><a class="header" href="#transactionoutput">TransactionOutput</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Version</td><td><code>TransactionOutputVersion</code></td><td><code>u8</code></td><td>The TransactionOutput version</td></tr>
<tr><td>Features</td><td><code>OutputFeatures</code></td><td>See <a href="RFC-0160_BlockSerialization.html#outputfeatures">OutputFeatures</a></td><td>Options for the output's structure or use</td></tr>
<tr><td>Commitment</td><td><code>PedersenCommitment</code></td><td><code>[u8;32]</code></td><td>The homomorphic commitment representing the output amount</td></tr>
<tr><td>Proof</td><td><code>RangeProof</code></td><td><code>Vec&lt;u8&gt;</code></td><td>A proof that the commitment is in the right range</td></tr>
<tr><td>Script</td><td><code>TariScript</code></td><td><code>Vec&lt;u8&gt;</code></td><td>The script that will be executed when spending this output</td></tr>
<tr><td>Sender Offset Public Key</td><td><code>PublicKey</code></td><td><code>[u8;32]</code></td><td>The Tari script sender offset public key</td></tr>
<tr><td>Metadata Signature</td><td><code>CommitmentAndPublicKeySignature</code></td><td>See <a href="RFC-0160_BlockSerialization.html#commitmentandpublickeysignature">CommitmentAndPublicKeySignature</a></td><td>A signature signing all transaction output metadata with the script offset private key and spending key</td></tr>
<tr><td>Covenant</td><td><code>Vec&lt;CovenantToken&gt;</code></td><td>See <a href="RFC-0160_BlockSerialization.html#covenanttoken">CovenantToken</a></td><td>A future-based contract detailing input and output metadata</td></tr>
<tr><td>Encrypted Value</td><td><code>EncryptedValue</code></td><td><code>[u8;24]</code></td><td>The encrypted value of the value commitment</td></tr>
<tr><td>Minimum Value Promise</td><td><code>MicroTari</code></td><td><code>u64</code> <em>(See <a href="RFC-0160_BlockSerialization.html#value-encryption">Value encryption</a>)</em></td><td>The minimum value promise embedded in the range proof</td></tr>
</tbody></table>
</div>
<h4 id="transactionkernel"><a class="header" href="#transactionkernel">TransactionKernel</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Version</td><td><code>TransactionKernelVersion</code></td><td><code>u8</code></td><td>The TransactionKernel version</td></tr>
<tr><td>Features</td><td><code>KernelFeatures</code></td><td><code>u8</code></td><td>Options for a kernel's structure or use</td></tr>
<tr><td>Fee</td><td><code>MicroTari</code></td><td><code>u64</code></td><td>Fee originally included in the transaction this proof is for.</td></tr>
<tr><td>Lock Height</td><td><code>u64</code></td><td><code>u64</code></td><td>This kernel is not valid earlier than this height. The max maturity of all inputs to this transaction</td></tr>
<tr><td>Excess</td><td><code>PedersenCommitment</code></td><td><code>[u8;32]</code></td><td>Remainder of the sum of all transaction commitments (minus an offset). If the transaction is well-formed, amounts plus fee will sum to zero, and the excess is a valid public key</td></tr>
<tr><td>Excess Signature</td><td><code>RistrettoSchnorr</code></td><td>See <a href="RFC-0160_BlockSerialization.html#ristrettoschnorr">RistrettoSchnorr</a></td><td>An aggregated signature of the metadata in this kernel, signed by the individual excess values and the offset excess of the sender</td></tr>
<tr><td>Burn Commitment</td><td><code>PedersenCommitment</code></td><td><code>[u8;32]</code></td><td>This is an optional field that must be set if the transaction contains a burned output</td></tr>
</tbody></table>
</div>
<h4 id="ristrettoschnorr"><a class="header" href="#ristrettoschnorr">RistrettoSchnorr</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Public nonce</td><td><code>PublicKey</code></td><td><code>[u8;32]</code></td><td>The public nonce of the Schnorr signature</td></tr>
<tr><td>Signature</td><td><code>SecretKey</code></td><td><code>[u8;32]</code></td><td>The signature of the Schnorr signature</td></tr>
</tbody></table>
</div>
<h3 id="new-block-template"><a class="header" href="#new-block-template">New Block Template</a></h3>
<p>The new block template is used in constructing a new partial block, allowing a miner to add the coinbase UTXO and as
a final step for the Base node to add the MMR roots to the header.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Header</td><td><code>NewBlockHeaderTemplate</code></td><td>See <a href="RFC-0160_BlockSerialization.html#new-block-header-template">New Block Header Template</a></td><td>The Tari protocol version number, used for soft/hard forks</td></tr>
<tr><td>Body</td><td><code>AggregateBody</code></td><td>See <a href="RFC-0160_BlockSerialization.html#block-body">Block Body</a></td><td>Height of this block since the genesis block</td></tr>
<tr><td>Target Difficulty</td><td><code>Difficulty</code></td><td><code>u64</code></td><td>The minimum difficulty required to satisfy the Proof of Work for the block</td></tr>
<tr><td>Reward</td><td><code>MicroTari</code></td><td><code>u64</code></td><td>The value of the emission for the coinbase output for the block</td></tr>
<tr><td>Total Fees</td><td><code>MicroTari</code></td><td><code>u64</code></td><td>The sum of all transaction fees in this block</td></tr>
</tbody></table>
</div>
<h4 id="new-block-header-template"><a class="header" href="#new-block-header-template">New Block Header Template</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Abstract Type</th><th>Data Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Version</td><td><code>u16</code></td><td><code>u16</code></td><td>The Tari protocol version number, used for soft/hard forks</td></tr>
<tr><td>Height</td><td><code>u64</code></td><td><code>u64</code></td><td>Height of this block since the genesis block</td></tr>
<tr><td>Previous Hash</td><td><code>BlockHash</code></td><td><code>[u8;32]</code></td><td>Hash of the previous block in the chain</td></tr>
<tr><td>Total Kernel Offset</td><td><code>BlindingFactor</code></td><td><code>[u8;32]</code></td><td>Total accumulated sum of kernel offsets since genesis block. We can derive the kernel offset sum for <em>this</em> block from the total kernel offset of the previous block header.</td></tr>
<tr><td>Total Script Offset</td><td><code>BlindingFactor</code></td><td><code>[u8;32]</code></td><td>Sum of script offsets for all transaction kernels in this block</td></tr>
<tr><td>Pow</td><td><code>ProofOfWork</code></td><td>See <a href="RFC-0160_BlockSerialization.html#proof-of-work">Proof Of Work</a></td><td>Proof of Work information</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0170networkcommunicationprotocol"><a class="header" href="#rfc-0170networkcommunicationprotocol">RFC-0170/NetworkCommunicationProtocol</a></h1>
<h2 id="the-tari-communication-network-and-network-communication-protocol"><a class="header" href="#the-tari-communication-network-and-network-communication-protocol">The Tari Communication Network and Network Communication Protocol</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="license"><a class="header" href="#license">License</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD License</a>.</p>
<p>Copyright 2018 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-10"><a class="header" href="#language-10">Language</a></h2>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-10"><a class="header" href="#disclaimer-10">Disclaimer</a></h2>
<p>The purpose of this document and its content is for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-10"><a class="header" href="#goals-10">Goals</a></h2>
<p>This document will introduce the Tari communication network and the communication protocol used to select, establish and maintain connections between peers on the network.
<a href="Glossary.html#communication-node">Communication Node</a>s and <a href="Glossary.html#communication-client">Communication Client</a>s will be introduced and their required functionality will be proposed.</p>
<h2 id="related-rfcs"><a class="header" href="#related-rfcs">Related RFCs</a></h2>
<ul>
<li><a href="./RFC-0111_BaseNodeArchitecture.html">RFC-0111: Base Node Architecture</a></li>
<li><a href="RFCD-0303_DanOverview.html">RFC-0303: DAN Overview</a></li>
</ul>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<h3 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h3>
<ul>
<li>A communication channel can be established between two peers once their online communication addresses are known to each other.</li>
</ul>
<h3 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h3>
<p>The backbone of the Tari communication network consists of a large number of nodes that maintain peer connections between each other.
These nodes forward and propagate encrypted and unencrypted data messages through the network such as joining requests, discovery requests, <a href="Glossary.html#transaction">transaction</a>s and completed <a href="Glossary.html#block">block</a>s.
Network clients, not responsible for maintaining the network, are able to create ad hoc connections with nodes on the network to perform joining and discovery requests.
The majority of communication between clients and nodes will be performed using direct Peer-to-peer (P2P) communication once the discovery process was used to obtain the online communication addresses of peers.
Where possible the efficient Kademlia based directed forwarding of encrypted data messages can be used to perform quick node discovery and joining of clients and nodes on the Tari communication network. 
Where messages are of importance to a wide variety of entities on the network, Gossip protocol based message propagation can be performed to distribute the message to the entire network.</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>The Tari communication network is a variant of a <a href="https://en.wikipedia.org/wiki/Kademlia">Kademlia</a> network that allows for fast discovery of nodes, with an added ability to perform Gossip protocol based broadcasting of data messages to the entire network.
The majority of the communication required on the <a href="Glossary.html#base-layer">Base Layer</a> and <a href="Glossary.html#digital-asset-network">Digital Asset Network</a> (DAN) will be performed via direct P2P communication between known clients and nodes.
Alternatively, the Tari communication network can be used for broadcasting joining requests, discovery requests and propagating data messages such as completed blocks, transactions and data messages that are of interest to a large part of the Tari communication network. </p>
<p>The Tari communication network consists of a number of different entities that need to communicate in a distributed and ad-hoc manner. 
The primary entities that need to communicate are Validator Nodes (VN), <a href="Glossary.html#base-node">Base Node</a>s (BN), and <a href="Glossary.html#wallet">Wallet</a>s (W).
Here are some examples of different communication tasks that need to be performed by these entities on the Tari Communication network:</p>
<ul>
<li>Base Nodes on the Base Layer need to propagate completed blocks and transactions to other Base Nodes using Gossip protocol based broadcasting.</li>
<li>Wallets need to communicate and negotiate with other Wallets to create transactions. They also need the ability to submit transactions to the <a href="Glossary.html#mempool">mempool</a> of Base Nodes.</li>
<li>Validator Nodes need to communicate with other Validator Nodes to perform consensus. Note that in future, the Validator Nodes may run on a different network.</li>
</ul>
<p>Here is an overview communication matrix that show which source entities SHOULD initiate communication with destination entities on the Tari Communication network:</p>
<div class="table-wrapper"><table><thead><tr><th>Destination (across) <br>Source (down)</th><th>Validator Node</th><th>Base Node</th><th>Wallet</th></tr></thead><tbody>
<tr><td>Validator Node</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td>Base Node</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Wallet</td><td>No</td><td>Yes</td><td>Yes</td></tr>
</tbody></table>
</div>
<h4 id="communication-nodes-and-communication-clients"><a class="header" href="#communication-nodes-and-communication-clients">Communication Nodes and Communication Clients</a></h4>
<p>To simplify the description of the Tari communication network, the different entities with similar behaviour were grouped into two groups: Communication Nodes and Communication Clients.</p>
<ul>
<li>Validator Nodes and Base Nodes are Communication Nodes (CN).</li>
<li>Wallets are Communication Clients (CC).</li>
</ul>
<p>CNs form the core communication infrastructure of the Tari communication network and are responsible for maintaining the Tari communication network by receiving, forwarding and distributing joining requests, discovery requests, data messages and routing information.
CCs are different from CNs in that they do not maintain the network and they are not responsible for propagating any joining requests, discovery requests, data messages and routing information.
They do make use of the network to submit their own joining requests and perform discovery request of other specific CNs and CCs when they need to communicate with them.
Once a CC has discovered the CC or CN they want to communicate with, they will establish a direct P2P channel with them.
The Tari communication network is unaware of this direct P2P communication once discovery is completed.</p>
<p>The different entity types MUST be grouped into the different communication node types as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Entity Type</th><th>Communication Node Type</th></tr></thead><tbody>
<tr><td>Validator Node</td><td>Communication Node</td></tr>
<tr><td>Base Node</td><td>Communication Node</td></tr>
<tr><td>Wallet</td><td>Communication Client</td></tr>
</tbody></table>
</div>
<h4 id="unique-identification-of-communication-nodes-and-communication-clients"><a class="header" href="#unique-identification-of-communication-nodes-and-communication-clients">Unique identification of Communication Nodes and Communication Clients</a></h4>
<p>In the Tari communication network, each CN or CC makes use of a node ID to determine their position in the network.
This node ID can be derived from the CNs or CCs identification public key.
The method used to obtain a node ID will either enhance or limit the trustworthiness of that entity when propagating messages through them on the Tari communication network.</p>
<p>The similarity or distance between different node IDs can be calculated by performing the <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between the bits of the two node ID numbers.
The Hamming distance can be implemented as an Exclusive OR (XOR) between the bits of the numbers and the summation of the resulting true bits.
CCs and/or CNs that have similar node IDs, that produce a small Hamming distance, are located in similar regions of the Tari communication network.
This does not mean that their geographic locations are near each other, but rather that their location in the network is similar.
A thresholding scheme can be applied to the Hamming distance to ensure that only neighboring CNs with similar node IDs are allowed to share and propagate specific information.
As an example, only routing table information that contains similar node IDs to the requesting CCs or CNs node ID should be shared with them.
Limiting the sharing of routing table information makes it more difficult to map the entire Tari communication network.</p>
<p>Note that <a href="Glossary.html#mining-worker">Mining Worker</a>s are excluded from the Tari communication network.
A Mining Server will have a local or remote connection with a Base Node.
They do not need to make use of the communication network and they are not responsible for propagating any messages on the network.
The parent Base Node will perform any communication tasks on the Tari communication network on their behalf.</p>
<h4 id="online-communication-address-peer-address-and-routing-table"><a class="header" href="#online-communication-address-peer-address-and-routing-table">Online Communication Address, Peer Address and Routing Table</a></h4>
<p>Each CC and CN on the Tari communication network will have identification cryptographic keys, a node ID and an online communication address.
The online communication address SHOULD be either an IPv4, IPv6, Or Tor (Base32) address and can be stored using the network address type as follows:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Description</th><th style="text-align: left">Data type</th><th style="text-align: left">Comments</th></tr></thead><tbody>
<tr><td style="text-align: left">address type</td><td style="text-align: left">uint4</td><td style="text-align: left">Specify if IPv4/IPv6/Tor</td></tr>
<tr><td style="text-align: left">address</td><td style="text-align: left">char array</td><td style="text-align: left">IPv4, IPv6, Tor (Base32) address</td></tr>
<tr><td style="text-align: left">port</td><td style="text-align: left">uint16</td><td style="text-align: left">port number</td></tr>
</tbody></table>
</div>
<p>Tari uses the <a href="https://multiformats.io/multiaddr/">Multiaddr</a> format for addresses. </p>
<p>A Tor address can be used when anonymity is important for a CC or CN.
The IPv4 and IPv6 address types do not provide any privacy features but do provide increased bandwidth. </p>
<p>Each CC or CN has a local lookup table that contains the online communication addresses of all CCs and CNs on the Tari communication network known to that CC or CN.
When a CC or CN wants to join the Tari communication network, the online communication address of at least one other CN that is part of the network needs to be known.
The online communication address of the initial CN can either be manually provided or a bootstrapped list of &quot;reliable&quot; and persistent CNs can be provided with the Validator Node, Base Node or Wallet software.
The new CC or CN can then request additional peer contact information of other CNs from the initial peers to extend their own routing table.</p>
<p>The routing table consists of a list of peer addresses that link node IDs, public identification keys and online communication addresses of each known CC and CN.</p>
<p>The Peer Address stored in the routing table MAY be implemented as follows:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Description</th><th style="text-align: left">Data type</th><th style="text-align: left">Comments</th></tr></thead><tbody>
<tr><td style="text-align: left">network address</td><td style="text-align: left">network_address</td><td style="text-align: left">The online communication address of the CC or CN</td></tr>
<tr><td style="text-align: left">node_ID</td><td style="text-align: left">node_ID</td><td style="text-align: left">Registration Assigned for VN, Self selected for BN, W and TW</td></tr>
<tr><td style="text-align: left">public_key</td><td style="text-align: left">public_key</td><td style="text-align: left">The public key of the identification cryptographic key of the CC or CN</td></tr>
<tr><td style="text-align: left">node_type</td><td style="text-align: left">node_type</td><td style="text-align: left">VN, BN, W or TW</td></tr>
<tr><td style="text-align: left">linked asset IDs</td><td style="text-align: left">list of asset IDs</td><td style="text-align: left">Asset IDs can be used as an address on Tari network similar to a node ID</td></tr>
<tr><td style="text-align: left">last_connection</td><td style="text-align: left">timestamp</td><td style="text-align: left">Time of last successful connection with peer</td></tr>
<tr><td style="text-align: left">update_timestamp</td><td style="text-align: left">timestamp</td><td style="text-align: left">A timestamp for the last peer address update</td></tr>
</tbody></table>
</div>
<p>When a new CC or CN wants to join the Tari communication network they need to submit a joining request to the rest of the network.
The joining request contains the peer address of the new CC or CN.
Each CN that receives the joining request can decide if they want to add the new CCs or CNs contact information to their local routing table.
When a CN, that received the joining request, has a similar node ID to the new CC or CN then that node must add the peer address to their routing table.
All CNs with similar node IDs to the new CC or CN should have a copy of the new peer address in their routing tables.</p>
<p>To limit potential attacks, only one registration for a specific node type with the same online communication address can be stored in the routing table of a CN.
This restriction will limit Bad Actors from spinning up multiple CNs on a single computer.</p>
<h4 id="joining-the-network-using-a-joining-request"><a class="header" href="#joining-the-network-using-a-joining-request">Joining the Network using a Joining Request</a></h4>
<p>A new CC or CN needs to register their peer address on the Tari communication network.
This is achieved by submitting a network joining request to a subset of CNs selected from the routing table of the new CC or CN.
These peers will forward the joining request, with the peer address, to the rest of the network until CNs with similar node IDs have been reached.
CNs with similar node IDs will then add the new peer address of the new node to their routing table, allowing for fast discovery of the new CC or CN. </p>
<p>Other CCs and CNs will then be able to retrieve the new CCs or CNs peer address by submitting discovery requests.
Once the peer address of the desired CC or CN has been discovered then a direct P2P communication channel can be established between the two parties for any future communication.
After discovery, the rest of the Tari communication network will be unaware of any further communication between the two parties.</p>
<h4 id="sending-data-messages-and-discovery-requests"><a class="header" href="#sending-data-messages-and-discovery-requests">Sending Data Messages and Discovery Requests</a></h4>
<p>The majority of all communication on the Tari communication network will be performed using direct P2P channels established between different CCs and CNs once they are aware of the peer addresses of each other that contain their online communication addresses.
Message propagation on the network will typically consist only of joining and discovery requests where a CC or CN wants to join the network or retrieve the peer address of another CC or CN so that a direct P2P channel can be established.</p>
<p>Messages can be transmitted in this network in either an unencrypted or encrypted form.
Typically messages that have been sent in unencrypted form are of interest to a number of CNs on the network and should be propagated so that every CN that is interested in that data message obtains a copy.
Block and Transaction propagation are examples of data messages where multiple entities on the Tari communication network are interested in that data message; this requires propagation through the entire Tari communication network in unencrypted form.</p>
<p>Encrypted data messages make use of the source and destinations identification cryptographic keys to construct a shared secret with which the message can be encoded and decoded.
This ensures that only the two parties are able to decode the data message as it is propagated through the communication network.
This mechanism can be used to perform private discovery requests, where the online communication address of the source node is encrypted and propagated through the network until it reached the destination node.
Private discovery requests can only be performed if both parties are online at the same time.
Encryption of the data message ensures that only the destination node is able to view the online address of the source node as the data message moves through the network.
Once the destination node receives and decrypts the data message, that node is then able to establish a P2P communication channel with the source node for any further communication.</p>
<p>Propagation of completely private discovery request, hidden as an encrypted data message, can be performed as a broadcast through the entire network using the Gossip protocol.
Propagation of public discovery requests can be performed using more efficient directed propagation using the Kademlia protocol.
As encrypted message with visible destinations tend to not be of interest to the rest of the network, directed propagation using the Kademlia protocol to forward these messages to the correct parties are preferred.
Privacy of a CCs online address, whom is sending a transaction to a Base Node, may be enhanced if the transaction is encrypted and sent to a Base Node with a node ID that is not the closest to the CCs node ID. This should prevent linking a transaction to the originating online address.</p>
<p>This same encryption technique can be used to send encrypted messages to a single node or a group of nodes, where the group of nodes have shared identification keys.
A Validation Committee is an example of a group of CNs that have shared identification keys for the committee.
The shared identification keys ensure that all members of that committee are able to receive and decrypt data messages that were sent to the committee.</p>
<h4 id="maintaining-connections-with-peers"><a class="header" href="#maintaining-connections-with-peers">Maintaining connections with peers</a></h4>
<p>CCs and CNs establish and maintain connections with peers differently.
CCs only create a few short-lived ad hoc channels and CNs create and maintain long-lived channels with a number of peers.</p>
<p>If a CC is unaware of a destination CNs or CCs online communication address then the address first needs to be obtained using a discovery request.
When a CC already knows the communication address of the CC or CN that he wants to communicate with, then a direct P2P channel can be established between the two peers for the duration of the communication task.
The communication channel can then be closed as soon as the communication task has been completed.</p>
<p>CNs consisting of VNs and BNs typically attempt to maintain communication channels with a large number of peers.
The distribution of peers (VNs vs BNs) that a single CN keeps communication channels open with can change depending on the type of node.
A CN that is also a BN should maintain more peer connections with other BNs, but should also have some connections with other VNs.</p>
<p>A CN that is also a VN should maintain more peer connections with other VNs, but also have some connections with BNs.
CNs that are part of Validator Node committees should attempt to maintain permanent connections with the other members of the committee to ensure that quick consensus can be achieved.</p>
<p>To maintain connections with peers, the following process can be performed.
Discover peers using discovery requests, and add their details to the local routing table.
The CN can decide how the peer connections should be selected from the routing table by either:</p>
<ul>
<li>manually selecting a subset,</li>
<li>automatically selecting a random subset or</li>
<li>selecting a subset of neighbouring nodes with similar node IDs. </li>
</ul>
<h4 id="functionality-required-of-communication-nodes"><a class="header" href="#functionality-required-of-communication-nodes">Functionality Required of Communication Nodes</a></h4>
<ul>
<li>It MUST select a cryptographic key pair used for identification on the Tari Communication network.</li>
<li>A CN MAY request the peer addresses of CNs with similar node IDs from other CNs to extend their local routing table. </li>
<li>If a CN is a BN, then a node ID MUST be derived from the nodes identification public key.</li>
<li>A new CN MUST submit a joining request to the Tari communication network so that the nodes peer address can be added to the routing table of neighbouring peers in the network.</li>
<li>If a CN receives a new joining request with a similar node ID (within a network selected threshold), then the peer address specified in the joining request MUST be added to its local routing table.</li>
<li>When a CN receives an encrypted message, the node MUST attempt to open the message. It MUST authenticate the encryption before trying to decrypt it.</li>
<li>When a CN receives an encrypted message that the node is unable to open, and the destination node ID is known then the CN MUST forward it to all connected peers that have node IDs that are closer to the destination.</li>
<li>When a CN receives an encrypted message that the node is unable to open and the destination node is unknown then the CN MUST forward the message to all connected peers.</li>
<li>A CN MUST have the ability to verify the content of unencrypted messages to limit the propagation of spam messages.</li>
<li>If an unencrypted message is received by the CN with a unspecified destination node ID, then the node MUST verify the content of the message and forward the message to all connected peers.</li>
<li>If an unencrypted message is received by the CN with an specified destination node ID, then the node MUST verify the content of the message and forward the message to all connected peers that have closer node IDs.</li>
<li>A CN MUST have the ability to select a set of peer connections from its routing table.</li>
<li>Connections with the selected set of peers MUST be maintained by the CN.</li>
<li>A CN MUST have a mechanism to construct encrypted and unencrypted joining requests, discovery requests or data messages.</li>
<li>A CN MUST construct and provide a list of peer addresses from its routing table that is similar to a requested node ID so that other CCs and CNs can extend their routing tables.</li>
<li>A CN MUST keep its routing table up to date by removing unreachable peer addresses and adding newly received addresses.</li>
<li>It MUST have a mechanism to determine if a node ID was obtained through registration or was derived from an identification public key.</li>
<li>A CN MUST calculate the similarity between different node IDs by calculating the Hamming distance between the bits of the two node ID numbers.</li>
</ul>
<h4 id="functionality-required-of-communication-clients"><a class="header" href="#functionality-required-of-communication-clients">Functionality Required of Communication Clients</a></h4>
<ul>
<li>It MUST select a cryptographic key pair used for identification on the Tari Communication network.</li>
<li>It MUST have a mechanism to derive a node ID from the self-selected identification public key.</li>
<li>A CC must have the ability to construct a peer address that links its identification public key, node ID and an online communication address.</li>
<li>A new CC MUST broadcast a joining request with its peer address to the Tari communication network so that CNs with similar node IDs can add the peer address of the new CC to their routing tables.</li>
<li>A CC MAY request the peer addresses of CNs with similar node IDs from other CNs to extend their local routing table.</li>
<li>A CC MUST have a mechanism to construct encrypted and unencrypted joining and discovery requests.</li>
<li>A CC MUST maintain a small persistent routing table of Tari Communication network peers with which ad hoc connections can be established.</li>
<li>As the CC becomes aware of other CNs and CCs on the communication network, the CC SHOULD extend its local routing table by including the newly discovered CCs or CNs contact information.</li>
<li>Peers from the CCs routing table that have been unreachable for a number of attempts SHOULD be removed from the its routing table.</li>
<li>A CC MUST calculate the similarity between different node IDs by calculating the Hamming distance between the bits of the two node ID numbers.</li>
</ul>
<h1 id="change-log-9"><a class="header" href="#change-log-9">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">11 Nov 2022</td><td style="text-align: left">Update, removed registration of Validator Nodes</td><td style="text-align: left">Stringhandler</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0171messageserialization"><a class="header" href="#rfc-0171messageserialization">RFC-0171/MessageSerialization</a></h1>
<h2 id="message-serialization"><a class="header" href="#message-serialization">Message Serialization</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a> <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-10"><a class="header" href="#licence-10">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-11"><a class="header" href="#language-11">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-11"><a class="header" href="#disclaimer-11">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-11"><a class="header" href="#goals-11">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the message serialization formats for message payloads used in the Tari network.</p>
<h2 id="related-requests-for-comment-9"><a class="header" href="#related-requests-for-comment-9">Related Requests for Comment</a></h2>
<p><a href="RFC-0170_NetworkCommunicationProtocol.html">RFC-0710: Tari Communication Network and Network Communication Protocol</a></p>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<p>One way of interpreting the Tari network is that it is a large peer-to-peer messaging application. The entities chatting
on the network include:</p>
<ul>
<li>Wallets</li>
<li>Base nodes</li>
<li>Validator nodes</li>
<li>Other client applications (e.g. chat)</li>
</ul>
<p>The types of messages that these entities send might include:</p>
<ul>
<li>Text messages</li>
<li>Transaction messages</li>
<li>Block propagation messages</li>
<li>Asset creation instructions</li>
<li>Asset state change instructions</li>
<li>State Checkpoint messages</li>
</ul>
<p>For successful communication to occur, the following needs to happen:</p>
<ul>
<li>The message is translated from its memory storage format into a standard payload format that will be transported over
the wire.</li>
<li>The communication module wraps the payload into a message format, which may entail any/all of
<ul>
<li>adding a message header to describe the type of payload;</li>
<li>encrypting the message;</li>
<li>signing the message;</li>
<li>adding destination/recipient metadata.</li>
</ul>
</li>
<li>The communication module then sends the message over the wire.</li>
<li>The recipient receives the message and unwraps it, possibly performing any/all of the following:
<ul>
<li>decryption;</li>
<li>verifying signatures;</li>
<li>extracting the payload;</li>
<li>passing the serialized payload to modules that are interested in that particular message type.</li>
</ul>
</li>
<li>The message is deserialized into the correct data structure for use by the receiving software</li>
</ul>
<p>This document only covers the first and last steps, i.e. serializing data from in-memory objects to a format that can
be transmitted over the wire. The other steps are handled by the Tari communication protocol.</p>
<p>In addition to machine-to-machine communication, we also standardize on human-to-machine communication. Use cases for
this include:</p>
<ul>
<li>Handcrafting instructions or transactions. The ideal format here is a very human-readable format.</li>
<li>Copying transactions or instructions from cold wallets. The ideal format here is a compact but easy-to-copy format.</li>
<li>Peer-to-peer text messaging. This is just a special case of what has already been described, with the message
structure containing a unicode <code>message_text</code> field.</li>
</ul>
<p>When sending a message from a human to the network, the following happens:</p>
<ul>
<li>The message is deserialized into the native structure.</li>
<li>Additional validation can be performed.</li>
<li>The usual machine-to-machine process is followed, as described above.</li>
</ul>
<h3 id="binary-serialization-formats"><a class="header" href="#binary-serialization-formats">Binary Serialization Formats</a></h3>
<p>The ideal properties for binary serialization formats are:</p>
<ul>
<li>widely used across multiple platforms and languages, but with excellent Rust support;</li>
<li>compact binary representation; and</li>
<li>serialization &quot;Just Works&quot;(TM) with little or no additional coding overhead.</li>
</ul>
<p>Several candidates fulfill these properties to some degree.</p>
<h4 id="bincode"><a class="header" href="#bincode"><a href="https://docs.rs/bincode/latest/bincode/">bincode</a></a></h4>
<ul>
<li>Pros:
<ul>
<li>Fast and compact</li>
<li>Serde support</li>
</ul>
</li>
<li>Cons:
<ul>
<li>(Almost) any type changes result in incompatibilities</li>
<li>language support outside of rust is limited</li>
</ul>
</li>
</ul>
<h4 id="message-pack"><a class="header" href="#message-pack"><a href="http://msgpack.org/">Message Pack</a></a></h4>
<ul>
<li>Pros:
<ul>
<li>Compact</li>
<li>Fast</li>
<li>Multiple language support</li>
<li>Good Rust/Serde support</li>
<li>Native byte encoding (compared to JSON)</li>
</ul>
</li>
<li>Cons:
<ul>
<li>No metadata support</li>
<li>Self-describing overhead</li>
</ul>
</li>
</ul>
<p>MessagePack has almost the exact same characteristics as JSON, without the syntactical overhead.
It is also self-describing, which can be a pro and a con. Like JSON, field names are encoded as strings 
which adds significant overhead over p2p comms. However, when used in conjunction with <a href="https://github.com/Idein/msgpack-schema">msgpack-schemas</a>
this overhead is removed and binary representations become characteristically similar to protobuf.</p>
<h4 id="protobuf"><a class="header" href="#protobuf"><a href="https://code.google.com/p/protobuf/">Protobuf</a></a></h4>
<p>Protobuf is a widely-used binary serialization format that was developed by Google and has excellent Rust support. 
The Protobuf byte format encodes tag numbers as varints that map to a known schema fields. </p>
<ul>
<li>Pros:
<ul>
<li>Compact</li>
<li>Fast</li>
<li>Multiple language support</li>
<li>Good Rust/Serde support</li>
<li>Some schema changes are backward compatible</li>
</ul>
</li>
<li>Cons
<ul>
<li>Schema must be defined for each message type</li>
<li>Does not fit into the serde ecosystem, meaning it is hard to swap out later.</li>
</ul>
</li>
</ul>
<p>In the latest protoV3 spec, all fields are optional. 
which forces the implementation to check for the presence of required data
and allows for. This means that you can change your schema significantly and there is a </p>
<p>It's fairly easy to reason about backwards-compatibility for schema changes once you understand <a href="https://developers.google.com/protocol-buffers/docs/encoding">protobuf encoding</a>. 
Essentially, since all fields in protov3 are optional, a message will usually be able to successfully decode even if
message tags are added/changed/removed. It therefore depends on the application whether changes are backward-compatible.</p>
<p>Generally, the following rules apply:</p>
<ul>
<li>you should not change existing field types to a non-compatible type. For example, changing a <code>uint32</code> to a <code>uint64</code> is fine, but changing a <code>uint32</code> to a <code>string</code> is not.</li>
<li>you should not change existing tag numbers should not be changed, field names may change as needed since they are not included in the byte format.</li>
<li>you may delete optional or repeated fields</li>
<li>you may add new optional or repeated fields as long as you use a new field number </li>
</ul>
<h4 id="capn-proto"><a class="header" href="#capn-proto"><a href="http://kentonv.github.io/capnproto/">Cap'n Proto</a></a></h4>
<p>Similar to Protobuf, but claims to be much faster. Rust is supported.</p>
<h4 id="hand-rolled-serialization"><a class="header" href="#hand-rolled-serialization">Hand-rolled Serialization</a></h4>
<p><a href="http://zguide.zeromq.org/py:chapter7#Serialization-Libraries">Hintjens recommends</a> using hand-rolled serialization for
bulk messaging. While Pieter usually offers sage advice, I'm going to argue against using custom serializers at this
stage for the following reasons:</p>
<ul>
<li>We're unlikely to improve hugely over existing serialization formats.</li>
<li>Since Serde does 95% of our work for us, there's a significant development overhead (and new bugs)
involved with a hand-rolled solution.</li>
<li>We'd have to write de/serializers for every language that wants Tari bindings; whereas every major language has
a protobuf implementation.</li>
</ul>
<h3 id="tari-message-formats"><a class="header" href="#tari-message-formats">Tari message formats</a></h3>
<h4 id="wire-message-format"><a class="header" href="#wire-message-format">Wire message format</a></h4>
<p>The decision was taken to use <a href="RFC-0171_MessageSerialisation.html#protobufhttpscodegooglecompprotobuf">Protobuf</a> encoding for messages on the Tari peer-to-peer wire protocol, as it ticks these boxes:</p>
<ul>
<li>it is possible to modify message schemas in future versions without breaking network communication with previous versions of node software,</li>
<li>de/encoding is compact and fast, and</li>
<li>it has great Rust support through the <a href="https://github.com/tokio-rs/prost">prost</a> crate.</li>
</ul>
<h4 id="other-serialization-formats"><a class="header" href="#other-serialization-formats">Other serialization formats</a></h4>
<p>For human-readable formats, it makes little sense to deviate from JSON. For copy-paste semantics, the extra compression
that Base64 offers over raw hex or Base58 makes it attractive.</p>
<p>The standard binary representation used in databases (e.g. blockchain storage, wallets) will make use of <code>bincode</code>. 
In these cases, a straightforward <code>#[derive(Deserialize, Serialize)]</code> is all that is required to implement de/encoding 
for the data structure. </p>
<p>However, other structures might need fine-tuning, or hand-written serialization procedures. To capture both use cases,
it is proposed that a <code>MessageFormat</code> trait be defined:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MessageFormat: Sized {
    fn to_binary(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;, MessageFormatError&gt;;
    fn to_json(&amp;self) -&gt; Result&lt;String, MessageFormatError&gt;;
    fn to_base64(&amp;self) -&gt; Result&lt;String, MessageFormatError&gt;;

    fn from_binary(msg: &amp;[u8]) -&gt; Result&lt;Self, MessageFormatError&gt;;
    fn from_json(msg: &amp;str) -&gt; Result&lt;Self, MessageFormatError&gt;;
    fn from_base64(msg: &amp;str) -&gt; Result&lt;Self, MessageFormatError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait will have default implementations to cover most use cases (e.g. a simple call through to <code>serde_json</code>). Serde
also offers significant ability to tweak how a given struct will be serialized through the use of
<a href="https://serde.rs/attributes.html">attributes</a>.</p>
<h1 id="change-log-10"><a class="header" href="#change-log-10">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">29 Mar 2019</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">24 Jul 2019</td><td style="text-align: left">Technical editing</td><td style="text-align: left">anselld</td></tr>
<tr><td style="text-align: left">13 Oct 2022</td><td style="text-align: left">Update</td><td style="text-align: left">sdbondi</td></tr>
<tr><td style="text-align: left">26 Oct 2022</td><td style="text-align: left">Stabilise RFC</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0172peertopeermessaging"><a class="header" href="#rfc-0172peertopeermessaging">RFC-0172/PeerToPeerMessaging</a></h1>
<h2 id="peer-to-peer-messaging-protocol"><a class="header" href="#peer-to-peer-messaging-protocol">Peer to Peer Messaging Protocol</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/sdbondi">Stanley Bondi</a>, <a href="https://github.com/CjS77">Cayle Sharrock</a>, <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-11"><a class="header" href="#licence-11">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-12"><a class="header" href="#language-12">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-12"><a class="header" href="#disclaimer-12">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-12"><a class="header" href="#goals-12">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the peer-to-peer messaging protocol for <a href="Glossary.html#communication-node">communication node</a>s 
and <a href="Glossary.html#communication-client">communication client</a>s on the Tari network.</p>
<h2 id="related-requests-for-comment-10"><a class="header" href="#related-requests-for-comment-10">Related Requests for Comment</a></h2>
<ul>
<li><a href="rfc-0170_NetworkCommunicationProtocol.html">RFC-0170: NetworkCommunicationProtocol</a></li>
<li><a href="RFC-0171_MessageSerialisation.html">RFC-0171: MessageSerialization</a></li>
</ul>
<h2 id="description-8"><a class="header" href="#description-8">Description</a></h2>
<h3 id="assumptions-1"><a class="header" href="#assumptions-1">Assumptions</a></h3>
<ul>
<li>All wire messages are de/serialized as per <a href="RFC-0171_MessageSerialisation.html#wire-message-format">RFC-0171: Message Serialisation</a>.</li>
<li>All peer's public identities are based on <a href="https://ristretto.group/">Ristretto</a> <a href="https://tlu.tarilabs.com/cryptography/elliptic-curves">prime order elliptic curves</a>.</li>
</ul>
<h3 id="broad-requirements-1"><a class="header" href="#broad-requirements-1">Broad Requirements</a></h3>
<p>Tari network peer communication must facilitate secure, private and efficient communication
between peers. Broadly, a <a href="Glossary.html#communication-node">communication node</a> or <a href="Glossary.html#communication-client">communication client</a> MUST be capable of:</p>
<ul>
<li>bidirectional communication between multiple connected peers;</li>
<li>encrypted, authenticated over-the-wire communication;</li>
<li>understanding and constructing Tari messages;</li>
<li>gracefully reestablishing dropped connections; and (optionally)</li>
<li>either: 
<ul>
<li>communicating to a SOCKS5 proxy (e.g. connections over Tor).</li>
<li>or have a static public IPv4 address.</li>
</ul>
</li>
</ul>
<p>Additionally, communication nodes MUST be capable of performing the following tasks:</p>
<ul>
<li>maintaining a list of known and available peers in the form of a peer list;</li>
<li>forwarding directed messages to neighbouring peers; and</li>
<li>broadcasting messages to neighbouring peers.</li>
</ul>
<h3 id="overall-architectural-design"><a class="header" href="#overall-architectural-design">Overall Architectural Design</a></h3>
<p>The Tari communication layer has a modular design to allow for the various communicating nodes and clients to
use the same infrastructure code.</p>
<p>Peer connection state is monitored by the <code>ConnectionManager</code> component. The <code>ConnectionManager</code> emits events to allow 
other components to subscribe to connection state changes. </p>
<ul>
<li><code>ConnectionManager</code> - manages peer connections and connection state monitoring.</li>
<li><code>PeerConnection</code> - manages the sending and receiving of messages for a single peer connection.</li>
<li><code>NetAddress</code> - <a href="https://multiformats.io/multiaddr/">multiaddr</a> describing the public address and transport for a peer-to-peer connection.</li>
<li><code>Messaging Protocol</code> - defines the Tari wire message format and message types.</li>
<li><code>Connection Multiplexer</code> - allows multiple substreams to be established over a single transport-level connection.</li>
</ul>
<h4 id="netaddress"><a class="header" href="#netaddress">NetAddress</a></h4>
<p>A <code>NetAddress</code> is a publicly-accessible address for a peer. A peer may have one or more <code>NetAddress</code>es. </p>
<p>A good <code>NetAddress</code> format should:</p>
<ul>
<li>have an efficient binary representation;</li>
<li>have a human-readable representation with a simple syntax;</li>
<li>support many transport protocols; and</li>
<li>be self-describing</li>
</ul>
<p>For these reasons, we select the <a href="https://multiformats.io/multiaddr/">multiaddr</a> format for all peer-to-peer addresses.</p>
<p>For example,</p>
<ul>
<li><code>/ip4/123.123.123.123/tcp/12345</code> - IPv4 address with TCP transport on port 12345.</li>
<li><code>/onion3/abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrst:12345</code> - Tor onion address </li>
</ul>
<h4 id="supported-transports"><a class="header" href="#supported-transports">Supported Transports</a></h4>
<p>The following transports are supported by the Tari communication layer:</p>
<ul>
<li>TCP/IP - A publicly accessible IPv4 address.</li>
<li>SOCKS5 - Allows a SOCKS5 proxy to be configured for inbound and outbound connections.</li>
<li>Tor - A specialisation of the SOCKS5 transport that facilitates connections over the Tor network.</li>
</ul>
<h4 id="establishing-a-connection"><a class="header" href="#establishing-a-connection">Establishing a Connection</a></h4>
<p>Every participating <a href="Glossary.html#communication-node">communication node</a> SHOULD listen on at least one of the supported transports, accessible from a
public address, to allow remote peers to establish peer connections. </p>
<p>A peer wishing to establish a peer connection should attempt a connection to one of the remote peer's public 
<a href="RFC-0172_PeerToPeerMessagingProtocol.html#netaddress">NetAddresses</a> using the transport described in the <a href="RFC-0172_PeerToPeerMessagingProtocol.html#netaddress">NetAddress</a>. </p>
<p>The peer that is initiating the <em>outbound</em> connection is referred to as <em>the initiator</em> and the peer that accepts the
<em>inbound</em> connection is referred to as <em>the responder</em> for the remainder of this section. </p>
<p>We describe the following socket upgrade procedures for an encrypted peer-to-peer connection on the Tari network.</p>
<ol>
<li>The Wire Mode Byte</li>
</ol>
<p>The wire mode indicates the intention of the initiator. It is up to the application domain to dictate what byte is acceptable
however a common configuration is to use the wire mode to indicate which network (mainnet, testnet etc) the initiator is 
attempting to use allowing the responder to accept/reject the connection early on in the connection procedure.</p>
<p><em>The initiator</em> MUST send a single byte indicating the wire mode within <code>WIRE_MODE_TIMEOUT</code>.
<em>The responder</em> SHOULD to accept or reject (close) the connection based on the initiator's wire mode byte.
<em>The responder</em> SHOULD reject (close) the connection if no byte is received within <code>WIRE_MODE_TIMEOUT</code>.</p>
<p>Once the byte is sent, the initiator may immediately proceed to the next procedure.</p>
<ol start="2">
<li>The <a href="http://www.noiseprotocol.org/">Noise Protocol</a></li>
</ol>
<p>The <a href="http://www.noiseprotocol.org/">Noise Protocol</a> framework is a set of related crypto protocols that support mutual authentication and ephemeral 
encryption key exchange amongst other features. </p>
<p>We list the following characteristics and requirements for encrypted peer-to-peer connections on the Tari network:</p>
<ul>
<li>Mutual authentication of the initiator and responder;</li>
<li><em>the responder</em> need not know <em>the initiator's</em> public identity prior to the connection;</li>
<li>the public identity of each participant is hidden to any observer; </li>
<li>forward secrecy; and,</li>
<li>for efficiency, has a minimal round trip time.</li>
</ul>
<p>For these reasons we select the single round-trip <code>Noise_IX_25519_ChaChaPoly_BLAKE2b</code> protocol, that is, the Noise IX 
handshake pattern using Curve25519 for ephemeral and static identities, ChaChaPoly encryption and a HKDF using BLAKE2b.</p>
<p>If successful, an authenticated encrypted socket connection is established between the peers.</p>
<ol start="3">
<li>Identity Exchange</li>
</ol>
<p>At this point the initiator and responder are aware of each other's public identity keys, however, some additional
information is required to fully &quot;introduce&quot; the participants to each other.</p>
<p>Both the initiator and responder simultaneously transmit a message containing their up-to-date public addresses, 
the peer feature flags, protocols supported by the peer, a timestamp of the last time these details changed 
and a signature that signs the public addresses, feature flags and update timestamp. Peers may store and share 
these details with other peers, who can check the authenticity of the provided information by verifying the signature.</p>
<ol start="4">
<li>Multiplexing</li>
</ol>
<p>Now that these procedures are complete, we have an active PeerConnection. There is no explicit protocol message required 
to initiate multiplexing as both sides implicitly agree to send <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a> protocol messages. Light-weight <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">Yamux</a> 
substreams are opened lazily as/when required by the application.</p>
<p>Multiplexing allows a single socket connection to be used simultaneously by multiple components as if each had their own
dedicated channel, in a very similar way that your browser can perform many HTTP2 requests over a single server connection.
In <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a>, these dedicated channels are called substreams. The details of the <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a> protocol are out of scope for this
RFC.</p>
<h3 id="protocol-negotiation"><a class="header" href="#protocol-negotiation">Protocol Negotiation</a></h3>
<p>To begin any protocol, an initiator MUST open a new <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a> substream and begin protocol negotiation.
Protocol negotiation ensures that both sides of the exchange are speaking the same language. 
Protocols are identified by a unique string identifier given by the author of the protocol.
A protocol name can technically be any string, but it is defined in the Tari protocol as <code>t/{protocol-ident}/{version}</code>,
where <code>t</code> is short for Tari, for example the messaging protocol is <code>t/msg/0.1</code>.</p>
<p>To begin, the initiator MUST send a protocol negotiation message consisting of 1 length byte, 
1 bitflag byte and the protocol identifier string. The length byte MUST be equal to the length of the protocol identifier.</p>
<p>The bitflags are defined as follows:</p>
<ul>
<li><code>0x01</code> - <code>OPTIMISTIC</code></li>
<li><code>0x02</code> - <code>TERMINATE</code></li>
<li><code>0x04</code> - <code>PROTOCOL_NOT_SUPPORTED</code> (response)</li>
<li><code>0x08 - 0x128</code> - Future use (ignored)</li>
</ul>
<p>If the <code>OPTIMISTIC</code> flag is set, the initiator considers the negotiation complete as it is optimistic that the responder 
supports it. It can assume this because the peer gave a list of supported protocols in the <a href="RFC-0172_PeerToPeerMessagingProtocol.html#identity-exchange">Identity Exchange</a> 
procedure. If the responder does not support the protocol, it can simply close the substream.</p>
<p>In general, peers will use <code>OPTIMISTIC</code> negatation and never wait for a response, as they have a full list of supported 
protocols. However, if the initiator wishes to negotiate a protocol not in the protocol list, it may leave the <code>OPTIMISTIC</code> 
flag unset in the initial message.</p>
<p>If the responder supports the protocol, it SHOULD respond with the name of the supported protocol and all flags unset and
immediately proceed with the agreed upon protocol.
If not, it SHOULD respond with the <code>PROTOCOL_NOT_SUPPORTED</code> flag set and an empty protocol name and wait for more messages.
The initiator MAY send another protocol negotiation message or close the substream.</p>
<p>A responder MAY set the <code>TERMINATE</code> flag at any time and close the substream. In practise, this is used to indicate to the 
initiator that it has exceeded the maximum number of protocol negotiation queries (5) and should give up.</p>
<h4 id="peer"><a class="header" href="#peer">Peer</a></h4>
<p>A single peer that can communicate on the Tari network.</p>
<p>Fields include:</p>
<ul>
<li><code>public_key</code> - The <a href="https://ristretto.group/">Ristretto</a> public key identity of the peer.</li>
<li><code>addresses</code> - a list of <a href="RFC-0172_PeerToPeerMessagingProtocol.html#netaddress">NetAddress</a>es associated with the peer, perhaps accompanied by some bookkeeping metadata, such
as preferred address;</li>
<li><code>peer_features</code> - bitflags with the following flags
<ul>
<li><code>MESSAGE_PROPAGATION = 0x01</code> - peer is able to propagate/route messages</li>
<li><code>DHT_STORE_FORWARD = 0x02</code> - peer provides message storage and can respond to <code>SafRequestMessages</code></li>
<li>A <code>COMMUNICATION_NODE</code> is defined as <code>0x03</code> (<code>MESSAGE_PROPAGATION | DHT_STORE_FORWARD</code>)</li>
<li>A <code>COMMUNICATION_CLIENT</code> is defined as <code>0x00</code></li>
</ul>
</li>
<li><code>last_seen</code> - a timestamp of the last time a message has been sent/received from this peer;</li>
<li><code>banned_until</code> - an optional timestamp indicating the peer is banned;</li>
<li><code>offline_at</code> - an optional timestamp indicating at which time a peer was marked as offline due to multiple failed attempts to contact the peer.</li>
</ul>
<p>A peer may also contain reputation metrics (e.g. rejected_message_count, avg_latency) to be used to decide
if a peer should be banned. This mechanism is yet to be decided.</p>
<h4 id="peermanager"><a class="header" href="#peermanager">PeerManager</a></h4>
<p>The PeerManager is responsible for managing the list of peers with which the node has previously interacted.
This list is called a routing table and is made up of <a href="RFC-0172_PeerToPeerMessagingProtocol.html#peer">Peer</a>s.</p>
<p>The PeerManager can</p>
<ul>
<li>add a peer to the routing table;</li>
<li>search for a peer given a node ID, public key or <a href="RFC-0172_PeerToPeerMessagingProtocol.html#netaddress">NetAddress</a>;</li>
<li>delete a peer from the list;</li>
<li>persist the peer list using a storage backend;</li>
<li>restore the peer list from the storage backend;</li>
<li>maintain lightweight views of peers, using a filter criterion, e.g. a list of peers that have been banned, i.e. a denylist; and</li>
<li>prune the routing table based on a filter criterion, e.g. last date seen.</li>
</ul>
<h3 id="general-purpose-messaging-protocol"><a class="header" href="#general-purpose-messaging-protocol">General-purpose Messaging Protocol</a></h3>
<p>The messaging protocol is a simple fire-and-forget protocol where arbitrary messages can be sent between peers.
If Alice wants to send a message to Bob, she will open a new <a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux</a> substream and <a href="RFC-0172_PeerToPeerMessagingProtocol.html#protocol-negotiation">negotiate</a> the 
<code>t/msg/0.1</code> protocol. If Bob wants to send a message to Alice, he will do the same. This means that two substreams (one per direction)
are open for bi-directional message sending as required. </p>
<p>Message frames are length delimited (see <a href="https://docs.rs/tokio-util/latest/tokio_util/codec/length_delimited/">Tokio's LengthDelimitedCodec</a>).
At this level, no structure apart from the length-delimited framing is imposed on the message protocol allowing that 
to be fully determined by domain-level components.</p>
<h4 id="tari-dht-and-base-layer-messaging-protocol"><a class="header" href="#tari-dht-and-base-layer-messaging-protocol">Tari DHT and Base-Layer Messaging Protocol</a></h4>
<p>The following illustrates the structure of a Tari message:</p>
<pre><code class="language-text">+----------------------------------------+
|              DhtEnvelope               |
|  +----------------------------------+  |
|  |             DhtHeader            |  |
|  +----------------------------------+  |
|  +----------------------------------+  |
|  |         EnvelopeBody             |  |
|  | (multipart, optionally encrypted)|  |
|  | +------------------------------+ |  |
|  | |   +-----------------------+  | |  |
|  | |   |    1. MessageHeader   |  | |  |
|  | |   +-----------------------+  | |  |
|  | |   +-----------------------+  | |  |
|  | |   |    2. MessageBody     |  | |  |
|  | |   +-----------------------+  | |  |
|  | +------------------------------+ |  |
|  +----------------------------------+  |
+----------------------------------------+
</code></pre>
<p>Each Tari message is wrapped in a <code>DhtEnvelope</code> which contains a <code>DhtHeader</code> and an <code>EnvelopeBody</code>.</p>
<p>The <code>DhtHeader</code> is a protobuf message with these fields:</p>
<ul>
<li>
<p><code>version: u32</code> </p>
<p>The major message header version. A peer MAY discard the message if the version is not supported.</p>
</li>
<li>
<p><code>message_signature: 64 bytes</code> </p>
<p>The raw representation of a Schnorr signature committing to: </p>
<ul>
<li>sender public key</li>
<li>signature public nonce</li>
<li>and Blake2b hash of:
<ul>
<li>&quot;comms.dht.v1.message_signature&quot;</li>
<li>version </li>
<li>destination </li>
<li>msg_type </li>
<li>flags </li>
<li>expiry </li>
<li>ephemeral_public_key </li>
<li>body </li>
</ul>
</li>
</ul>
<p>This is required if the <code>ENCRYPTED</code> flag is set.</p>
</li>
<li>
<p><code>ephemeral_public_key: 32 bytes</code></p>
<p>Ephemeral public key component of the ECDH shared key. MUST be specified if the ENCRYPTED flag is set.</p>
</li>
<li>
<p><code>dht_message_type: i32</code></p>
<p>Enumeration of the type of message.</p>
<ul>
<li>None = 0 - Domain-level message</li>
<li>Join = 1 - Join/Announce</li>
<li>Discovery = 2 - Discovery request</li>
<li>DiscoveryResponse = 3 - Response to a discovery request</li>
<li>SafRequestMessages = 20 - Request stored messages from a node</li>
<li>SafStoredMessages = 21 - Stored messages response</li>
</ul>
</li>
<li>
<p><code>flags: u32</code> - bitflags <code>0x01 - ENCRYPTED</code> </p>
</li>
<li>
<p><code>message_tag: u64</code> - Message trace ID. This can be omitted or any value and is used for debug tracing.</p>
</li>
<li>
<p><code>expires: Option&lt;prost_types::Timestamp&gt;</code></p>
<p>Expiry timestamp for the message, if any. If specified any peer receiving the message after this time MAY discard it.</p>
</li>
<li>
<p><code>destination: Option&lt;dht_header::Destination&gt;</code></p>
<p>Enumeration of the message destination:</p>
<ul>
<li><code>UNKNOWN = 0</code> - the destination was not specified, this indicates that the message is destined for the receiver.</li>
<li><code>PUBLICKEY(XXXXX) = 1</code> - destination is the specified public key. This MUST be provided when the <code>ENCRYPTED</code> flag is set.</li>
</ul>
</li>
</ul>
<h5 id="inbound-message-validation"><a class="header" href="#inbound-message-validation">Inbound Message Validation</a></h5>
<p>The following validation rules MUST be applied to all incoming messages:</p>
<ul>
<li>If <code>ENCRYPTED</code> is set
<ul>
<li>The <code>destination</code> MUST be <code>PUBLICKEY(XXXXX)</code></li>
<li>The <code>ephemeral_public_key</code> MUST be specified</li>
<li>The <code>message_signature</code> MUST be non-empty</li>
<li>If able to decrypt the message signature:
<ul>
<li>the signature MUST be valid</li>
<li>the destination public key MUST match the local public key</li>
</ul>
</li>
</ul>
</li>
<li>If the <code>ENCRYPTED</code> flag is not set, indicating a cleartext message
<ul>
<li>The <code>message_signature</code> MAY be specified. If it is, it MUST be valid.</li>
<li>Other fields relating to encryption e.g. <code>ephemeral_public_key</code> MAY be set but SHOULD be ignored.</li>
</ul>
</li>
</ul>
<p>If any of these rules fail the message SHOULD be discarded.</p>
<h5 id="outbound-messaging"><a class="header" href="#outbound-messaging">Outbound Messaging</a></h5>
<p>The protocol provides for the following outbound message broadcast strategies:</p>
<ul>
<li><code>Direct(Identity)</code> - Send the message directly to the destination peer. </li>
<li><code>Flood(exclude)</code> - Send to all connected peers excluding <code>exclude</code> peers. If no peers are connected, no messages are sent.</li>
<li><code>Random(n, exclude)</code> - Send to a random set of peers of size n that are Communication Nodes, excluding <code>exclude</code> peers.</li>
<li><code>ClosestNodes({node_id, exclude, connected_only})</code> - Send to all n nearest Communication Nodes to the given node_id.</li>
<li><code>DirectOrClosestNodes({node_id, exclude, connected_only})</code> - Send directly to destination if connected but otherwise send to all n nearest Communication Nodes</li>
<li><code>Broadcast(excludes)</code>- Send to a random set of <em>connected</em> peers, excluding <code>excludes</code> peers. The number of peers selected at most equal to <code>propagation_factor</code>.</li>
<li><code>SelectedPeers(peers)</code> - Send to the specified peers.</li>
<li><code>Propagate(NodeDestination, Vec&lt;NodeId&gt;)</code> - Propagate to a set of <em>connected</em> peers closer to the destination. The number of peers selected at most equal to <code>propagation_factor</code>.</li>
</ul>
<p>A peer's node_id is defined as the 13-byte variable-length Blake2b hash of the public key. To determine if a peer identity 
is &quot;closer&quot; to another peer we compare the XOR distance between peers as proposed by the <a href="https://www.scs.stanford.edu/~dm/home/papers/kpos.pdf">kademlia</a> paper.</p>
<h5 id="dht-messages"><a class="header" href="#dht-messages">DHT Messages</a></h5>
<ul>
<li><code>Join</code></li>
</ul>
<p>Announces a peer's availability to the network. A routing node SHOULD propagate this message closer to the destination. 
As it travels through the network, the peer information is stored in the peer list. Peers close to the newly 
joined node MAY attempt to dial the node on receipt of this message.</p>
<ul>
<li><code>Discovery</code></li>
</ul>
<p>An encrypted discovery request containing the sender's contact details. A routing node SHOULD propagate this message closer to the destination.
The destination peer will attempt to contact the sender and send a <code>DiscoveryResponse</code> message to reciprocate with its peer information.</p>
<ul>
<li><code>DiscoveryResponse</code></li>
</ul>
<p>Sent in response to a <code>Discovery</code> message. </p>
<ul>
<li><code>SafRequestMessages</code> / <code>SafStoredMessages</code></li>
</ul>
<p>Request and response messages for stored messages destined for the requester.</p>
<h5 id="envelopebody"><a class="header" href="#envelopebody">EnvelopeBody</a></h5>
<p>The <code>EnvelopeBody</code> is the &quot;payload&quot; of the message and consists of an arbitrary number of ordered opaque BLOBs.
It may be encrypted for a particular destination. The contents of these BLOBs are decided by domain-level requirements.</p>
<p>The Tari protocol inserts a <code>MessageHeader</code> at index 0 and <code>MessageBody</code> at index 1.</p>
<p>A zero-sized encoding of <code>EnvelopeBody</code> is permitted as that is a valid proto3 encoding. When applying <a href="RFC-0172_PeerToPeerMessagingProtocol.html#message-encryption">message encryption</a>, 
the body MUST be padded and, therefore, a message SHOULD be discarded if the encoded <code>EnvelopeBody</code> is zero-sized.</p>
<h5 id="messageheader"><a class="header" href="#messageheader">MessageHeader</a></h5>
<p>Every Tari message MUST have a payload header containing the following fields at index 0 in the <code>EnvelopeBody</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>message_type</td><td><code>u8</code></td><td>An enumeration of the message type of the body. Refer to message types below.</td></tr>
<tr><td>nonce</td><td><code>u32</code></td><td>The optional message nonce.</td></tr>
</tbody></table>
</div>
<p>MessageTypes are represented as an unsigned eight-bit integer denoting the expected contents of the <code>MessageBody</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th style="text-align: left">Name</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>Network</td><td style="text-align: left">PingPong</td><td>1</td><td>A PongPong message.</td></tr>
<tr><td>Blockchain</td><td style="text-align: left">NewTransaction</td><td>65</td><td>Transaction submitted by a wallet or propagated by a base node.</td></tr>
<tr><td>Blockchain</td><td style="text-align: left">NewBlock</td><td>66</td><td>Block propagated by a base node.</td></tr>
<tr><td>Wallet</td><td style="text-align: left">SenderPartialTransaction</td><td>67</td><td>A partial MimbleWimble transaction submitted by a sender wallet to the receiver.</td></tr>
<tr><td>Wallet</td><td style="text-align: left">ReceiverPartialTransactionReply</td><td>68</td><td>Reply to SenderPartialTransaction submitted by a receiver wallet to the sender.</td></tr>
<tr><td>Blockchain</td><td style="text-align: left">BaseNodeRequest</td><td>69</td><td>Base node request message.</td></tr>
<tr><td>Blockchain</td><td style="text-align: left">BaseNodeResponse</td><td>70</td><td>Base node response in reply to a BaseNodeRequest message.</td></tr>
<tr><td>Blockchain</td><td style="text-align: left">MempoolRequest</td><td>71</td><td>Base node mempool request message.</td></tr>
<tr><td>Blockchain</td><td style="text-align: left">MempoolResponse</td><td>72</td><td>Base node response in reply to a MempoolRequest message.</td></tr>
<tr><td>Wallet</td><td style="text-align: left">TransactionFinalized</td><td>73</td><td>Finalized transaction message sent by a sender to receiver wallet.</td></tr>
<tr><td>Wallet</td><td style="text-align: left">TransactionCancelled</td><td>74</td><td>A courtesy message sent by a wallet to inform the other that the transaction is cancelled.</td></tr>
</tbody></table>
</div>
<p>All other message types are reserved for future use.</p>
<h5 id="message-encryption"><a class="header" href="#message-encryption">Message Encryption</a></h5>
<p>Encrypted messages may be routed across the Tari network such that only the destination node is able to decipher the 
contents of the message. An encrypted message reveals to recipient but keeps the sender and contents private.</p>
<p>To route an encrypted message, the following requirements MUST be met:</p>
<ul>
<li>The destination public key MUST be specified.</li>
<li>The <code>message_signature</code> MUST be non-empty and SHOULD be encrypted.</li>
<li>The <code>ephemeral_public_key</code> MUST be a valid <a href="https://ristretto.group/">Ristretto</a> public key.</li>
<li>The <code>EnvelopeBody</code> MUST be non-empty, as message padding (described below) is required.</li>
<li>If the message <code>expiry</code> is specified, a routing node MAY discard the message if the expiry time has passed.</li>
</ul>
<p>A message is encrypted using the following procedure:</p>
<ul>
<li>The <code>DhtEnvelopBody</code> is containing the <code>MessageHeader</code> and <code>MessageBody</code> is serialized using [protobuf].</li>
<li>A CSRNG is used to generate the cipher nonce and this is prepended onto the message.</li>
<li>The plaintext message is padded with '0x00' to a multiple of 6000 bytes.</li>
<li>The message encryption key is generated as follows:
<ul>
<li>Key material <code>dh_key</code> is generated by Diffie-Hellman of the recipient public key and the ephemeral private key.</li>
<li>The final message key is constructed: <code>message_key = Blake2b(&quot;comms.dht.v1.key_message&quot; || dh_key)</code> to produce a 32-byte key.</li>
</ul>
</li>
<li>The message Schnorr signature is generated as follows:
<ul>
<li>A domain-separated Blake2b hash is generated with the challenge <code>message_challenge = Blake2b(&quot;comms.dht.v1.challenge&quot; || protocol_version || destination || dht_message_type || le_bytes(flags) || expiry || ephemeral_public_key || message_body)</code>.</li>
<li>The signer signs the hashed challenge <code>&quot;comms.dht.v1.message_signature&quot; || signer_public_key || public_nonce || message_challenge</code> with the sender secret key.</li>
<li>The signature is serialized and encrypted using the [ChaCha20Poly1305] AEAD cipher and the same <code>dh_key</code> constructed earlier.
<ul>
<li>The final signature key is constructed: <code>Blake2b(&quot;comms.dht.v1.key_signature&quot; || dh_key)</code> to produce a 32-byte key.</li>
</ul>
</li>
</ul>
</li>
<li>The <code>DhtEnvelopBody</code> is encrypted using the [ChaCha20Poly1305] AEAD cipher and <code>message_key</code>.</li>
<li>The final message is a <code>DhtEnvelope</code> containing the plaintext <code>DhtHeader</code> and encrypted <code>DhtEnvelopeBody</code>.</li>
</ul>
<h5 id="message-routing"><a class="header" href="#message-routing">Message Routing</a></h5>
<p>On receipt of a valid message with destination set to <code>PUBLIC_KEY(xxxx)</code>, a node SHOULD forward a message either
directly to the peer, if able, or closer to the peer as per the XOR metric. If the message is invalid, the node
SHOULD discard it.</p>
<h5 id="store-and-forward"><a class="header" href="#store-and-forward">Store and Forward</a></h5>
<p>Sometimes it may be desirable for messages to be sent without a destination node/client being online. This
is especially important for a modern chat/messaging application as well as interactive Mimblewimble transactions.</p>
<p>Each <a href="Glossary.html#communication-node">communication node</a> SHOULD allocate some disk space for storage of messages for offline recipients.
A sender sends a message destined for a particular public identity to its closest peers, which forward the message
to their closest peers, and so on. A peer is considered close enough by finding the farthest peer from the <code>n</code> closest 
online and available peers to the storage node and comparing that to the XOR distance of the message destination.</p>
<p>Eventually, the message will reach nodes that either know the destination or are very close to the destination.
These nodes SHOULD store the message in some pending message storage for the destination. The maximum number of
buckets and the size of each bucket SHOULD be sufficiently large as to be unlikely to overflow, but not so
large as to approach disk space problems. Individual messages should be small and responsibilities for
storage spread over the entire network.</p>
<p>On receipt of a valid message with destination set to <code>PUBLIC_KEY(xxxx)</code>, and if the peer is sufficiently close to the destination,
a node SHOULD store the message for a time and return it later to the peer in response to a <code>SafRequestMessages</code> message.</p>
<p>If the [DhtEnvelopeBody] is encrypted, the type and contents of the message remain private.</p>
<h5 id="message-deduplication"><a class="header" href="#message-deduplication">Message Deduplication</a></h5>
<p>A peer propagating/routing a message may receive the same message after propagation from another peer as there is no way 
for routing node to know which peers have seen the message before. To prevent infinite message propagation, message contents 
should be hashed and stored in a <em>dedup cache</em>. On receiving a message, if the message hash is found, the message SHOULD be
discarded and not propagated further.</p>
<h1 id="change-log-11"><a class="header" href="#change-log-11">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">13 Jun 2022</td><td style="text-align: left">Moved from tari repo</td><td style="text-align: left">sdbondi</td></tr>
<tr><td style="text-align: left">9 Nov 2022</td><td style="text-align: left">Removed I2P and ZeroMQ</td><td style="text-align: left">stringhandler</td></tr>
<tr><td style="text-align: left">17 Jan 2023</td><td style="text-align: left">Implementation parity updates</td><td style="text-align: left">sdbondi</td></tr>
<tr><td style="text-align: left">25 Jan 2023</td><td style="text-align: left">Clarify empty body rules</td><td style="text-align: left">sdbondi</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0173versioning"><a class="header" href="#rfc-0173versioning">RFC-0173/Versioning</a></h1>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-12"><a class="header" href="#licence-12">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-13"><a class="header" href="#language-13">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-13"><a class="header" href="#disclaimer-13">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-13"><a class="header" href="#goals-13">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the various types of versioning that nodes on the Tari network 
will use during interaction with other nodes.</p>
<h2 id="related-requests-for-comment-11"><a class="header" href="#related-requests-for-comment-11">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0170_NetworkCommunicationProtocol.html">RFC-0710: Tari Communication Network and Network Communication Protocol</a></li>
<li><a href="RFC-0171_MessageSerialisation.html">RFC-0171: MessageSerialization</a></li>
</ul>
<h2 id="description-9"><a class="header" href="#description-9">Description</a></h2>
<p>In a decentralized system the set of nodes on the network will run a variety of software versions as time goes on. Some 
of these versions will be compatible and others not. For example, if a crucial consensus change is added during a hard 
fork event. Furthermore, there will be multiple networks running Tari code, i.e. Mainnet vs Testnet. Versioning refers 
to the strategies we will use for nodes to determine if they can communicate.</p>
<p>Tari will contain three different versioning schemes:</p>
<ol>
<li>WireMode is the first byte a peer sends when connecting to another peer, used to identify the network and/or protocol bytes that follow </li>
<li>P2P message versions that will accompany every P2P message,</li>
<li>Consensus rules versions that will be exchanged on connection and are included in each block header.</li>
</ol>
<h3 id="wiremode-byte"><a class="header" href="#wiremode-byte">WireMode byte</a></h3>
<p>In the Bitcoin P2P protocol messages are preceded by 4 
<a href="https://en.bitcoin.it/wiki/Protocol_documentation#Common_structures">magic values</a> or bytes. These values are used to 
delimit when a new message starts in a byte stream and also are used to indicate which of the Bitcoin networks the node 
is speaking on, such as TestNet or Mainnet.</p>
<p>Tari message packets are encapsulated using the Noise protocol, so we do not need the delimiting functionality of these 
bytes.
Once we have a Noise socket we are able to send/receive bytes as with any other socket, but those bytes are
encrypted over the wire. Using that socket we send 
<a href="https://github.com/hashicorp/yamux/blob/master/spec.md">yamux packets</a> and messaging/rpc messages are 
<a href="https://docs.rs/tokio-util/latest/tokio_util/codec/length_delimited/">length-delimited</a>.</p>
<p>Tari includes a single WireMode byte at the beginning of every connection session. This byte indicates 
which network a node is communicating on, so that if the counterparty is on a different network it can reject this 
connection cheaply without having to perform any further operations, like completing the Noise protocol handshake.</p>
<p>The following is the current mapping of the WireMode byte:</p>
<pre><code class="language-rust ignore">   pub enum Network {
    MainNet = 0x00,
    LocalNet = 0x10,
    Ridcully = 0x21,
    Stibbons = 0x22,
    Weatherwax = 0xa3,
    Igor = 0x24,
    Dibbler = 0x25,
    Esmeralda = 0x26,
}

// As well as the special wiremode for local liveness checks
const LIVENESS_WIRE_MODE: u8 = 0xa6;</code></pre>
<h3 id="p2p-message-version"><a class="header" href="#p2p-message-version">P2P message version</a></h3>
<p>Peer to Peer messages on the Tari network are encapsulated into message envelopes. The body of message envelopes are 
defined, serialized and deserialized using Protobuf. These messages will only be updated by adding new fields to the 
Protobuf definitions, never removing fields. This is done in order to preserve backwards compatibility where newer nodes 
can still communicate with older nodes. </p>
<p>The P2P messaging protocol will see many changes in its lifetime. Some will be minor changes that are fully backwards 
compatible and some changes will be breaking where older nodes will not be able to communicate with newer nodes. In 
order to document these two classes of changes each P2P message header will contain a <code>version</code> field that will use
a two-part semantic versioning scheme with the format of <code>major.minor</code> integer versions. The <code>minor</code> version will be 
incremented whenever there is any change. The <code>major</code> version be incremented when there is a breaking change made to 
the P2P protocol. Each integer can be stored separately.</p>
<h3 id="consensus-version"><a class="header" href="#consensus-version">Consensus version</a></h3>
<p>The final aspect of the Tari system that will be versioned are the Consensus rules. These rules will change as the 
network matures. Changes to consensus rules can be achieved using either a Soft fork or Hard fork. Soft forks are where 
new consensus rules are added that older nodes will see as valid (thus backwards compatible) but newer nodes will reject 
blocks from older nodes that are not aware of the new consensus rules. A hard fork means that the new consensus rules 
are not backwards compatible and so only nodes that know about the new rules will be able to produce and validate new 
transactions and blocks.</p>
<p>The consensus version will be used by a node to determine if it can interact with another node successfully or not. A 
list of fork versions will be maintained within the code. When a connection is started with a new node the two nodes 
will exchange <code>Version</code> messages detailing the consensus version they are each running and the block height at which 
they are currently operating. 
Both nodes will need to reply with a <code>Version Acknowledge</code> message to confirm that they are 
compatible with the counterparty's version. It is possible for a newer node to downgrade its protocol to speak to an 
older node so this must be decided during this handshake process. Only once the acknowledgments have been exchanged can 
further messages be exchanged by the parties. This is the method currently employed on the 
<a href="https://developer.bitcoin.org/devguide/p2p_network.html#connecting-to-peers">Bitcoin network</a></p>
<p>For example, if we have two nodes, Node A and Node B, where Node A is ahead of Node B in version and block height. 
During the handshake Node B will not recognize Node A's version but should wait for Node A to reject or confirm the
connection because Node A could potentially downgrade their version to match Node B's. Node A will speak to Node B if
and only if Node A recognizes Node B's version and Node B's block height is in the correct range for its advertised 
version according to Node A's fork version list.</p>
<p>Tari Block Headers contain a <code>version</code> field which will be used to indicate the version of consensus rules that are 
used in the construction and validation of this block. Consensus rules versions will only consist of breaking changes
and as such will be represented with a single incremented integer. This coupled with the internal list of fork versions,
that includes the height at which they came into effect, will be used to validate whether the consensus rules specified 
in the header are valid for that block's height.</p>
<h1 id="change-log-12"><a class="header" href="#change-log-12">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">26 Oct 2022</td><td style="text-align: left">Stabilise RFC</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0174chat-metadata"><a class="header" href="#rfc-0174chat-metadata">RFC-0174/Chat Metadata</a></h1>
<h2 id="versioning-1"><a class="header" href="#versioning-1">Versioning</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/brianp">brianp</a></p>
<h1 id="licence-13"><a class="header" href="#licence-13">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2023 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-14"><a class="header" href="#language-14">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-14"><a class="header" href="#disclaimer-14">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-14"><a class="header" href="#goals-14">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the various types of versioning that nodes on the Tari network
will use during interaction with other nodes.</p>
<h2 id="related-requests-for-comment-12"><a class="header" href="#related-requests-for-comment-12">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0172_PeerToPeerMessagingProtocol.html">RFC-0712: PeerToPeerMessagingProtocol</a></li>
</ul>
<h2 id="description-10"><a class="header" href="#description-10">Description</a></h2>
<p>The chat protocol incorporates metadata within messages to support various message types, such as Replies,
TokenRequests, Gifs, and Links. This metadata-driven approach enhances the technical flexibility of chat,
allowing for the structured handling of distinct content and interactions within the messaging framework.</p>
<p>Chat metadata is transmitted simply as a length checked byte array allowing for flexbility of future content. Content is
unvalidated in the protocol and requires clients to ensure standardized formatting for specific types.</p>
<h3 id="types--formats"><a class="header" href="#types--formats">Types &amp; Formats</a></h3>
<h4 id="reply"><a class="header" href="#reply">Reply:</a></h4>
<p>MetadataType int: <code>0</code><br />
Data format: <code>String message_id</code>
A reply metadata should be a single String element matching the UUID of the message being replied to.<br />
Example: <code>06703dbfeabc43b98ceff16de2e104bc</code></p>
<h3 id="tokenrequest"><a class="header" href="#tokenrequest">TokenRequest:</a></h3>
<p>MetadataType int: <code>1</code><br />
Data format: <code>double micro_minotari_amount</code><br />
A double (reaL) number representing the request amount in MicroMinoTari.<br />
Example: <code>14000.87</code></p>
<h3 id="gif"><a class="header" href="#gif">Gif:</a></h3>
<p>MetadataType int: <code>2</code><br />
Data format: <code>String giphy_url</code><br />
A url to a giphy hosted image<br />
Example: <code>https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExNjN0dmR2aWNjbTluNGZ3ZHlubHNqajIwcmlqazdtYXExNWp4aG94NSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/VIPdgcooFJHtC/giphy.gif</code></p>
<h3 id="links"><a class="header" href="#links">Links:</a></h3>
<p>MetadataType int: <code>3</code><br />
Data format: <code>String uri</code><br />
A uri in string format<br />
Example: <code>https://www.tari.com/</code></p>
<h1 id="change-log-13"><a class="header" href="#change-log-13">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">21 Dec 2023</td><td style="text-align: left">Proposal draft</td><td style="text-align: left">brianp</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0181bulletproofsplus"><a class="header" href="#rfc-0181bulletproofsplus">RFC-0181/BulletproofsPlus</a></h1>
<h2 id="bulletproofs-range-proving"><a class="header" href="#bulletproofs-range-proving">Bulletproofs+ range proving</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/AaronFeickert">Aaron Feickert</a></p>
<h1 id="licence-14"><a class="header" href="#licence-14">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-15"><a class="header" href="#language-15">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-15"><a class="header" href="#disclaimer-15">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-15"><a class="header" href="#goals-15">Goals</a></h2>
<p>This Request for Comment (RFC) describes Tari-specific implementation details for Bulletproofs+ range proving and verifying, in addition to giving an outline of comparative performance.</p>
<h2 id="related-requests-for-comment-13"><a class="header" href="#related-requests-for-comment-13">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0150_Wallets.html">RFC-0150: Wallets</a></li>
<li><a href="./RFCD-0180_BulletproofRewinding.html">RFC-0180: BulletproofRewinding</a></li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The Tari implementation of the <a href="https://eprint.iacr.org/2020/735">Bulletproofs+</a> range proving system makes several changes and optimizations that we describe here.
In particular, it supports the following useful features:</p>
<ul>
<li>Commitments can be <em>extended</em>; that is, they can commit to a value using multiple masks.</li>
<li>Range proofs can be <em>aggregated</em>; that is, a single range proof can assert valid range for multiple commitments in an efficient way.</li>
<li>A set of arbitrary range proofs can be verified in a <em>batch</em>; that is, the verifier can check the validity of all proofs in the set at once in an efficient way.</li>
<li>The prover can assert a nonzero minimum value bound to a commitment.</li>
<li>The prover can delegate to certain verifiers the ability to recover the masks used for the extended commitment in a non-aggregated proof.</li>
</ul>
<p>The Bulletproofs+ preprint does not address extended commitments, as it only defines its range proving system using Pedersen commitments.
However, a later preprint for <a href="https://eprint.iacr.org/2021/1478">Zarcanum</a> updates the algorithms and security proofs to accommodate one additional mask, and the reasoning extends generally.
Aggregation of range assertions using Pedersen commitments is described in the Bulletproofs+ preprint, and the Zarcanum preprint describes the corresponding changes for extended commitments.
Batch verification is described only informally in the Bulletproofs+ preprint, and in an incomplete fashion.
Minimum value assertion is not addressed in the preprint.
An approach to mask and value recovery was <a href="https://github.com/mimblewimble/grin-wallet/issues/105">used by Grin</a> for the Bulletproofs range proving system, implemented as described by the deprecated <a href="RFCD-0180_BulletproofRewinding.html">RFC-0180</a>, and can be modified to support Bulletproofs+ range proofs with extended commitments.</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>To reduce confusion in our description and more closely match implementation libraries, we use additive notation and uppercase letters for group elements, and otherwise generally assume notation from the preprints.
Denote the commitment value generator by $G_c$ and the commitment mask generator vector by $\vec{H}_c$.
Because the preprint uses the notation $A$ differently in the weighted inner product and range proving protocols, we rename it to $A'$ in the weighted inner product protocol.</p>
<p>We assume that a range proof aggregates $m$ range assertions, each of which is to an $n$-bit range.
We further assume that each value commitment uses $p$ masks; that is, a standard Pedersen commitment would have $p = 1$.</p>
<p>A specific definition of note relates to that of the vector $\vec{d}$ introduced in the preprint.
This vector is defined as
\[
\vec{d} = \sum_{j=0}^{m-1} z^{2(j+1)} \vec{d}_j \tag{1}
\]
where each
\[
\vec{d}_j = (\underbrace{0,\ldots,0}_{jn}, \vec{2}^n, \underbrace{0,\ldots,0}_{(m-j-1)n}) \tag{2}
\]
contains only powers of two.
In particular, this means we can express individual elements of $\vec{d}$ as $d_{jn+i} = z^{2(j+1)} 2^i$ for $0 \leq i &lt; n$ and $0 \leq j &lt; m$.</p>
<p>Finally, we note one additional unfortunate notation change that applies to the implementation.
Both the Bulletproofs+ and Zarcanum preprints use $G$ as the commitment value generator, and either $H$ or $\vec{H}_c$ (in our notation) for masking.
However, in the Tari protocol (as in other similar protocols), this notation is switched!
This is because of how generators are defined and used elsewhere in the protocol and elliptic curve library implementation.
The only resulting change is a switch in generator notation in the Tari implementation: $H$ for the value component generator, and $\vec{G}_c$ (in our notation) for masking.</p>
<h2 id="minimum-value-assertion"><a class="header" href="#minimum-value-assertion">Minimum value assertion</a></h2>
<p>We first briefly note how to achieve minimum value assertion.
Let $0 \leq v_{\text{min}} \leq v \leq v_{\text{max}}$, where $v_{\text{min}}$ is a minimum value specified by the prover, $v$ is the value bound to the prover's commitment $V$, and $v_{\text{max}}$ is a globally-fixed maximum value.
When generating the proof, the prover uses $v - v_{\text{min}}$ as the value witness, and additionally binds $v_{\text{min}}$ into the Fiat-Shamir transcript.
When verifying the proof, the verifier uses $V - v_{\text{min}} G_c$ as the commitment (but binds the original commitment $V$ in the transcript).
This asserts that $v_{\text{min}} \leq v \leq v_{\text{min}} + v_{\text{max}}$.
While this approach modifies the upper bound allowed for value binding, it does not pose problems in practice, as the intent of range proving is to ensure no overflow when performing balance computations elsewhere in the Tari protocol.</p>
<h2 id="extended-commitments-and-aggregation"><a class="header" href="#extended-commitments-and-aggregation">Extended commitments and aggregation</a></h2>
<p>We now describe how to reduce verification of a single aggregated range proof using extended commitments to a single multiscalar multiplication operation.
A partial approach is described in the Bulletproofs+ preprint.
The single multiscalar multiplication used to verify an aggregated range proof (given in Section 6.1 of the Bulletproofs+ preprint) can be written more explicitly in our case by accounting for the extra steps used to support extended commitments, and by noting that the $P$ input term to the weighted inner product argument (given in Figure 1 of the Bulletproofs+ preprint and Figure D.1 of the Zarcanum preprint) is replaced by the term $\widehat{A}$ defined in the overall range proving protocol (given in Figure 3 of the Bulletproofs+ preprint and Figure D.3 of the Zarcanum preprint).</p>
<p>Suppose we index the inner product generator vectors $\vec{G}$ and $\vec{H}$ using $i$, the inner product recursion generator vectors $\vec{L}$ and $\vec{R}$ using $j$, the aggregated commitment vector $\vec{V}$ by $k$, and the extended commitment mask generator vector $\vec{H}_c$ by $l$.
We assume indexing starts at zero unless otherwise noted.
Single aggregated proof verification reduces (by suitable modification of the equation given in Section 6.1 of the Bulletproofs+ preprint) to checking that the following equation holds:
\[
\sum_{i=0}^{mn-1} (r'es_i) G_i + \sum_{i=0}^{mn-1} (s'es_i') H_i + \sum_{l=0}^{p-1} \delta_l' H_{c,l} = e^2 \widehat{A} + \sum_{j=0}^{\operatorname{lg}(mn)-1} (e^2e_j^2) L_j + \sum_{j=0}^{\operatorname{lg}(mn)-1} (e^2e_j^{-2}) R_j + e A' + B
\]
But we also have (from suitable modification of the definition given in Figure 3 of the Bulletproofs+ preprint) that
\[
\widehat{A} = A - \sum_{i=0}^{mn-1} z G_i + \sum_{i=0}^{mn-1} (z + d_iy^{mn-i}) H_i + x G_c + y^{mn+1}\sum_{k=0}^{m-1} z^{2(k+1)} (V_k - v_{\text{min},k} G_c)
\]
defined by the range proving system outside of the inner product argument.
Here
\[
\begin{align*}
x &amp;= \langle \vec{1}^{mn}, \overrightarrow{y}^{mn} \rangle z - \langle \vec{1}^{mn}, \vec{d} \rangle y^{mn+1}z - \langle \vec{1}^{mn}, \overrightarrow{y}^{mn} \rangle z^2 \\
&amp;= z\sum_{i=1}^{mn} y^i - y^{mn+1}z\sum_{i=0}^{mn-1}d_i - z^2\sum_{i=1}^{mn} y^i \tag{3}
\end{align*}
\]
is a scalar defined entirely in terms of constants and challenge values from the proof.
Grouping terms, we find that a single aggregated range proof can be verified by checking that the following equation holds:
\[
\begin{multline*}
\sum_{i=0}^{mn-1} (r'es_i + e^2z) G_i + \sum_{i=0}^{mn-1} (s'es_i' - e^2(z + d_iy^{mn-i})) H_i + \left( r'ys' - e^2x + e^2y^{mn+1}\sum_{k=0}^{m-1} z^{2(k+1)}v_{\text{min},k} \right) G_c \\
+ \sum_{l=0}^{p-1} \delta_l' H_{c,i} - \sum_{k=0}^{m-1} (y^{mn+1}z^{2(k+1)}e^2) V_k - e^2 A - \sum_{j=0}^{\operatorname{lg}(mn)-1} (e^2e_j^2) L_j - \sum_{j=0}^{\operatorname{lg}(mn)-1} (e^2e_j^{-2}) R_j - e A' - B = 0 \tag{4}
\end{multline*}
\]</p>
<h2 id="batch-verification"><a class="header" href="#batch-verification">Batch verification</a></h2>
<p>To verify a batch of proofs, we apply a separate random multiplicative scalar weight $w \neq 0$ to each proof's verification equation, form a linear combination of these equations, and group like terms.
Because each equation receives a separate random weight, successful evaluation of the resulting linear combination means that each constituent equation holds with high probability, and therefore that all proofs in the set are valid.
If the linear combination evaluation fails, at least one included proof is invalid.
The verifier must then test each proof in turn, or use a more efficient approach like binary search to identify each failure.
This follows the general approach informally discussed in Section 6.1 of the Bulletproofs+ preprint.</p>
<p>The reason for this rather convoluted algebra is twofold.
First, grouping like terms means that each unique generator used across a batch is only evaluated in the resulting multiscalar multiplication once; since the generators $\vec{G}, \vec{H}, G_c, \vec{H}_c$ are globally fixed, this provides significant efficiency improvement.
Second, the use of algorithms (like those of Straus and Pippenger and others) to evaluate the multiscalar multiplication scale slightly sublinearly, such that it is generally beneficial to minimize the number of multiscalar multiplications for a given set of generators.
This means our approach to batch verification is effectively optimal.</p>
<h2 id="designated-mask-recovery"><a class="header" href="#designated-mask-recovery">Designated mask recovery</a></h2>
<p>It is possible for the prover to perform careful modifications to a non-aggregated range proof in order to allow a designated verifier to recover the masks used in the corresponding extended commitment.
The construction we describe here does not affect the verification process for non-designated verifiers.
Note that this construction requires a non-aggregated proof that contains a range assertion for only a single commitment.
Unlike the approach used initially in <a href="RFCD-0180_BulletproofRewinding.html">RFC-0180</a>, it is not possible to embed additional data (like the commitment value) into a Bulletproofs+ range proof.</p>
<p>The general approach is that the prover and designated verifier share a common nonce seed.
The prover uses this value to determinstically derive and replace certain nonces used in the proof.
During the verification process, the designated verifier performs the same deterministic derivation and is able to extract the commitment masks from the proof.
Because the resulting proof is still special honest-verifier zero knowledge, as long as the nonce seed is sampled uniformly at random, a non-designated verifier is not able to gain any information about the masks.</p>
<p>After sampling a nonce seed, the prover passes it through an appropriate set of domain-separated hash functions with scalar output to generate the following nonces used in the proof:
\[
\{\eta_l\}, \{\delta_l\}, \{\alpha_l\}, \{d_{L,j,l}\}, \{d_{R,j,l}\}
\]
Here, as before, $0 \leq l &lt; p$ is indexed over the number of masks used in the extended commitment, and $0 \leq j &lt; \operatorname{lg}(mn)$ is indexed over the weighted inner product argument rounds.
Let $\{\gamma_l\}$ be the masks used in the non-aggregated proof.</p>
<p>By doing this, the prover effectively defines the proof element set $\{\delta_l'\}$ as follows:
\[
\delta_l' = \eta_l + \delta_le + e^2 \left( \alpha_l + \gamma_ly^{n+1}z^2 + \sum_{j=0}^{\operatorname{lg}(mn)-1}(e_j^2d_{L,j,l} + e_j^{-2}d_{R,j,l}) \right)
\]</p>
<p>When verifying the proof, the designated verifier uses the nonce seed to perform the same nonce derivation as the prover.
It then computes the mask set $\{\gamma_l\}$ as follows:
\[
\gamma_l = \left( (\delta_l' - \eta_l - \delta_le)e^{-2} - \alpha_l - \sum_{j=0}^{\operatorname{lg}(mn)-1}(e_j^2d_{L,j,l} + e_j^{-2}d_{R,j,l}) \right) y^{-(n+1)}z^{-2}
\]
The recovered masks must then be checked against the extended commitment once the value is separately communicated to the verifier.
Otherwise, if the verifier uses a different nonce seed than the prover did (or if the prover otherwise did not derive the nonces using a nonce seed at all), it will recover incorrect masks.
If the verifier is able to construct the extended commitment from the value and recovered masks, the recovery succeeds; otherwise, the recovery fails.</p>
<h2 id="sum-optimization"><a class="header" href="#sum-optimization">Sum optimization</a></h2>
<p>From Equation (3), the verifier must compute $\sum_i d_i$.
Because the vector $\vec{d}$ contains $mn$ elements by Equations (1) and (2), computing the sum naively is a slow process.
The implementation takes advantage of the fact that this sum can be expressed in terms of a partial sum of a geometric series to compute it much more efficiently; we describe this here.</p>
<p>We first recall the following <a href="https://mathworld.wolfram.com/GeometricSeries.html">identity</a> for the partial sum of a geometric series for $r \neq 0$:
\[
\sum_{k=0}^{n-1} r^k = \frac{1 - r^n}{1 - r}
\]</p>
<p>Next, we note that from Equation (2), we have
\[
\sum_{i=0}^{mn-1} (d_j)_i = \sum_{k=0}^{n-1} 2^k
\]
for all $0 \leq j &lt; m$.</p>
<p>Given these facts, we can express the required sum of the elements of $\vec{d}$ as follows:
\[
\begin{align*}
\langle \vec{1}^{mn}, \vec{d} \rangle &amp;= \sum_{i=0}^{mn-1} d_i \\
&amp;= \sum_{i=0}^{mn-1} \left( \sum_{j=0}^{m-1} z^{2(j+1)} (d_j)_i \right) \\
&amp;= \sum_{j=0}^{m-1} z^{2(j+1)} \left( \sum_{i=0}^{mn-1} (d_j)_i \right) \\
&amp;= \sum_{j=0}^{m-1} z^{2(j+1)} \left( \sum_{k=0}^{n-1} 2^k \right) \\
&amp;= (2^n - 1) \sum_{j=0}^{m-1} z^{2(j+1)}
\end{align*}
\]
This requires a sum of only $m$ even powers of $z$, which can be computed iteratively.</p>
<h2 id="comparative-performance"><a class="header" href="#comparative-performance">Comparative performance</a></h2>
<p>We now compare Bulletproofs+ performance to that of the <a href="https://eprint.iacr.org/2017/1066">Bulletproofs</a> range proving system.</p>
<h3 id="size"><a class="header" href="#size">Size</a></h3>
<p>Bulletproofs+ range proofs, like Bulletproofs, scale logarithmically in size.
In each case, a proof consists of the following:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Proving system</th><th style="text-align: left">Group elements</th><th style="text-align: left">Scalars</th></tr></thead><tbody>
<tr><td style="text-align: left">Bulletproofs</td><td style="text-align: left">$2 \operatorname{lg}(nm) + 4$</td><td style="text-align: left">$5$</td></tr>
<tr><td style="text-align: left">Bulletproofs+</td><td style="text-align: left">$2 \operatorname{lg}(nm) + 3$</td><td style="text-align: left">$p + 2$</td></tr>
</tbody></table>
</div>
<p>That is, both the range bit length $n$ and aggregation factor $m$ contribute logarithmically to the proof size.
In the case of the Tari-specific implementation of Bulletproofs+, the number of masks contributes linearly to the proof size.</p>
<p>Regardless of the bit length $n$ or aggregation factor $m$ used, a single-mask ($p = 1$) Bulletproofs+ range proof saves $1$ group element and $2$ scalars over the equivalent Bulletproofs range proof. For the <a href="https://ristretto.group/">Ristretto</a>-based Tari implementation, this amounts to $96$ bytes after group element and scalar encoding.</p>
<p>We also note that while it is possible to encode an extra scalar of data in a Bulletproofs non-aggregated range proof (in addition to the mask) using nonce-based recovery techniques, this is not possible with Bulletproofs+ range proofs.</p>
<h3 id="verification-efficiency"><a class="header" href="#verification-efficiency">Verification efficiency</a></h3>
<p>Like in Bulletproofs+, it is possible to reduce verification of a batch of Bulletproofs range proofs to a single multiscalar multiplication operation.</p>
<p>To compare this efficiency, we count unique generators used in the multiscalar multiplication operation in both cases.
It is the case that scalar-only operations differ greatly between the two systems, but these operations are much faster than those involving group elements.</p>
<p>Let $b$ be the batch size of such a verification; that is, the number of proofs to be verified together.
This means single-proof verification has $b = 1$.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Proving system</th><th style="text-align: left">Operation size</th></tr></thead><tbody>
<tr><td style="text-align: left">Bulletproofs</td><td style="text-align: left">$b[2\operatorname{lg}(mn) + m + 4] + 2mn + 2$</td></tr>
<tr><td style="text-align: left">Bulletproofs+</td><td style="text-align: left">$b[2\operatorname{lg}(mn) + m + 3] + 2mn + p + 1$</td></tr>
</tbody></table>
</div>
<p>Verification in Bulletproofs+ is slightly faster than in Bulletproofs in theory.</p>
<p>In practice, verification of a single 64-bit range proof in the <a href="https://github.com/tari-project/bulletproofs-plus">Tari Bulletproofs+</a> implementation is comparable to an <a href="https://github.com/tari-project/bulletproofs">updated fork</a> of the <a href="https://github.com/dalek-cryptography/bulletproofs">Dalek Bulletproofs</a> implementation, though verification of an aggregated proof is notably slower.</p>
<h3 id="proving-efficiency"><a class="header" href="#proving-efficiency">Proving efficiency</a></h3>
<p>It is more challenging to compare proving efficiency, since generation of a range proof does not reduce cleanly to a single multiscalar multiplication evaluation for either Bulletproofs or Bulletproofs+ range proofs.
However, we note that the overall complexity between the inner-product arguments in the proving systems is similar in terms of group operations; outside of these inner-product arguments, Bulletproofs+ requires fewer group operations.
Overall efficiency is likely to depend on specific optimizations.</p>
<p>In practice, generation of a single 64-bit range proof in the Tari Bulletproofs+ implementation is about 10% faster than in the Dalek Bulletproofs updated fork, with similar performance for aggregated proofs.</p>
<h2 id="changelog"><a class="header" href="#changelog">Changelog</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">7 Dec 2022</td><td style="text-align: left">First draft</td><td style="text-align: left">Aaron</td></tr>
<tr><td style="text-align: left">13 Jan 2022</td><td style="text-align: left">Performance updates</td><td style="text-align: left">brianp</td></tr>
<tr><td style="text-align: left">20 Jul 2023</td><td style="text-align: left">Sum optimization</td><td style="text-align: left">Aaron</td></tr>
<tr><td style="text-align: left">31 Jul 2023</td><td style="text-align: left">Notation and efficiency</td><td style="text-align: left">Aaron</td></tr>
<tr><td style="text-align: left">3 Aug 2023</td><td style="text-align: left">Proving efficiency note</td><td style="text-align: left">Aaron</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0182commitmentsignatures"><a class="header" href="#rfc-0182commitmentsignatures">RFC-0182/CommitmentSignatures</a></h1>
<h2 id="commitment-and-public-key-signatures"><a class="header" href="#commitment-and-public-key-signatures">Commitment and public key signatures</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/AaronFeickert">Aaron Feickert</a></p>
<h1 id="licence-15"><a class="header" href="#licence-15">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2023 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-16"><a class="header" href="#language-16">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-16"><a class="header" href="#disclaimer-16">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-16"><a class="header" href="#goals-16">Goals</a></h2>
<p>This Request for Comment (RFC) describes signatures relating to commitments and public keys that are useful for Tari transaction authorization.</p>
<h2 id="related-requests-for-comment-14"><a class="header" href="#related-requests-for-comment-14">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0120_TariScript.html">RFC-0120: TariScript</a></li>
</ul>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>A commitment and public key signature (<a href="Glossary.html#commitment-and-public-key-signature">CAPK signature</a>) is used in Tari protocols as part of transaction authorization.
Given a commitment $C = aH + xG$ and public key $P = yG$, a CAPK signature asserts knowledge of the openings $(a,x)$ and $y$ in zero knowledge.
Optionally, the value $a$ may be disclosed as part of the signature.</p>
<p>Structurally, a CAPK signature is a conjunction of Schnorr-type representation proofs for $C$ and $P$.
While it is defined as an interactive protocol, the (strong) Fiat-Shamir technique is used to make it non-interactive and bind arbitrary message data, effectively transforming the proof into a signature.</p>
<h2 id="value-hiding-protocol"><a class="header" href="#value-hiding-protocol">Value-hiding protocol</a></h2>
<p>We first describe the version of the protocol that does not reveal the commitment value.
It is a sigma protocol for the following relation, where $G$ and $H$ are fixed group generators with no efficiently-computable discrete logarithm relationship:
\[
\left\{ C, P ; (a, x, y) | C = aH + xG, P = yG \right\}
\]
The interactive form of this protocol proceeds as follows:</p>
<ul>
<li>The prover samples scalar nonces $r_a, r_x, r_y$ uniformly at random.</li>
<li>The prover computes ephemeral values $C_{eph} = r_a H + r_x G$ and $P_{eph} = r_y G$, and sends these values to the verifier.</li>
<li>The verifier samples a nonzero scalar challenge $e$ uniformly at random, and sends it to the prover.</li>
<li>The prover computes $u_a = r_a + ea$ and $u_x = r_x + ex$ and $u_y = r_y + ey$, and sends these values to the verifier.</li>
<li>The verifier accepts the proof if and only if $u_a H + u_x G = C_{eph} + eC$ and $u_y G = P_{eph} + eP$.</li>
</ul>
<p>The strong Fiat-Shamir technique can transform this into a non-interactive protocol.
To do so, the prover and verifier both use a domain-separated cryptographic hash function to compute the challenge $e$, carefully binding $C$, $P$, $C_{eph}$, $P_{eph}$, and any arbitrary message data.
In this non-interactive format, the public statement data is the tuple $(C, P)$ and the proof data is the tuple $(C_{eph}, P_{eph}, u_a, u_x, u_y)$.</p>
<p>Verification can be made more efficient by reducing to a single linear combination evaluation.
To do this, the verifier samples a nonzero scalar weight $w$ uniformly at random (not using Fiat-Shamir!) and accepts the proof if and only if the following holds:
\[
u_a H + (u_x + wu_y)G - C_{eph} - wP_{eph} - eC - weP = 0
\]</p>
<h3 id="security-proof"><a class="header" href="#security-proof">Security proof</a></h3>
<p>We require that the (interactive) protocol be correct, special sound, and special honest-verifier zero knowledge.
While the proof technique is standard, we present it here for completeness.</p>
<p>Correctness follows immediately by inspection.</p>
<p>To show the protocol is special sound, consider a rewinding argument with two distinct challenges $e \neq e'$ on the same statement $(C, P)$ and initial transcript $(C_{eph}, P_{eph})$.
We must produce extracted witnesses $a, x, y$ consistent with the statement.
Suppose the responses on these transcripts are $(u_a, u_x, u_y)$ and $(u_a', u_x', u_y')$, respectively.
The first verification equation applied to both transcripts yields $(u_a - u_a')H + (u_x - u_x')G = (e - e')C$, from which we obtain witness extractions
\[
a = \frac{u_a - u_a'}{e - e'}
\]
and
\[
x = \frac{u_x - u_x'}{e - e'}
\]
such that $C = aH + xG$, as required.
Similarly, the second verification equation yields $(u_y - u_y')G = (e - e')P$, so
\[
y = \frac{u_y - u_y'}{e - e'}
\]
is the remaining extracted witness, such that $P = yG$.
This shows the protocol is 2-special sound.</p>
<p>Finally, we show the protocol is special honest-verifier zero knowledge.
This requires us to simulate, for an arbitrary statement and challenge, a transcript distributed identically to that of a real proof.
Fix a statement $(C, P)$ and sample a challenge $e \neq 0$ uniformly at random.
Then, sample $u_a, u_x, u_y$ uniformly at random.
We then set $C_{eph} = u_a H + u_x G - eC$ and $P_{eph} = u_y G - eP$.
The resulting transcript is valid by construction.
Further, all proof elements are uniformly distributed at random in both the simulation and in real proofs.
This shows the protocol is special honest-verifier zero knowledge.</p>
<h2 id="value-revealing-protocol"><a class="header" href="#value-revealing-protocol">Value-revealing protocol</a></h2>
<p>We now describe a modified version of the protocol that reveals the commitment value.
While this protocol can be made more efficient than we list here (discussed later), this design is intended to be more closely compatible with the value-hiding protocol for easier implementation.
It is a sigma protocol for the following relation, where $G$ and $H$ are fixed group generators with no efficiently-computable discrete logarithm relationship:
\[
\left\{ C, P, a ; (x, y) | C = aH + xG, P = yG \right\}
\]
The interactive form of this protocol proceeds as follows:</p>
<ul>
<li>The prover samples scalar nonces $r_x, r_y$ uniformly at random.</li>
<li>The prover computes ephemeral values $C_{eph} = r_x G$ and $P_{eph} = r_y G$, and sends these values to the verifier.</li>
<li>The verifier samples a nonzero scalar challenge $e$ uniformly at random, and sends it to the prover.</li>
<li>The prover computes $u_a = ea$ and $u_x = r_x + ex$ and $u_y = r_y + ey$, and sends these values to the verifier.</li>
<li>The verifier accepts the proof if and only if $u_a = ea$ and $u_a H + u_x G = C_{eph} + eC$ and $u_y G = P_{eph} + eP$.</li>
</ul>
<p>As in the value-hiding protocol, the strong Fiat-Shamir technique can transform this into a non-interactive protocol.
Crucially, in this version of the protocol, the prover and verifier must also bind the value $a$ into the challenge.
That is, they both use a domain-separated cryptographic hash function to compute the challenge $e$, carefully binding $C$, $P$, $a$, $C_{eph}$, $P_{eph}$, and any arbitrary message data.
In this non-interactive format, the public statement data is the tuple $(C, P, a)$ and the proof data is the tuple $(C_{eph}, P_{eph}, u_a, u_x, u_y)$.</p>
<p>The same weighting technique as above may be used to combine the second and third verification equations here.
However, the first verification equation must still be checked.</p>
<h3 id="security-proof-1"><a class="header" href="#security-proof-1">Security proof</a></h3>
<p>We require that the (interactive) protocol be correct, special sound, and special honest-verifier zero knowledge.
While the proof technique is standard, we present it here for completeness.</p>
<p>Correctness follows immediately by inspection.</p>
<p>To show the protocol is special sound, consider a rewinding argument with two distinct challenges $e \neq e'$ on the same statement $(C, P, a)$ and initial transcript $(C_{eph}, P_{eph})$.
We must produce extracted witnesses $x, y$ consistent with the statement.
Suppose the responses on these transcripts are $(u_a, u_x, u_y)$ and $(u_a', u_x', u_y')$, respectively.
The first verification equation gives that $u_a = ea$ and $u_a' = e'a$.
The second verification equation applied to both transcripts then yields $(e - e')aH + (u_x - u_x')G = (e - e')C$, from which we obtain witness extraction
\[
x = \frac{u_x - u_x'}{e - e'}
\]
such that $C = aH + xG$, as required.
Similarly, the third verification equation yields $(u_y - u_y')G = (e - e')P$, so
\[
y = \frac{u_y - u_y'}{e - e'}
\]
is the remaining extracted witness, such that $P = yG$.
This shows the protocol is 2-special sound.</p>
<p>Finally, we show the protocol is special honest-verifier zero knowledge.
This requires us to simulate, for an arbitrary statement and challenge, a transcript distributed identically to that of a real proof.
Fix a statement $(C, P)$ and sample a challenge $e \neq 0$ uniformly at random.
Then, fix $u_a = ea$ and sample $u_x, u_y$ uniformly at random.
We then set $C_{eph} = u_a H + u_x G - eC$ and $P_{eph} = u_y G - eP$.
The resulting transcript is valid by construction.
Further, all proof elements are either fixed by verification or uniformly distributed at random in both the simulation and in real proofs.
This shows the protocol is special honest-verifier zero knowledge.</p>
<h3 id="simplification"><a class="header" href="#simplification">Simplification</a></h3>
<p>This protocol may be simplified further.
To do so, the prover does not compute $u_a$ at all, instead sending only $u_x$ and $u_y$ as its post-challenge responses.
To account for this, the verifier accepts the proof if and only if $eaH + u_x G = C_{eph} + eC$ and $u_y G = P_{eph} + eP$.</p>
<p>However, this alters the proof format and verification, which may be undesirable for a more general implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0190mempool"><a class="header" href="#rfc-0190mempool">RFC-0190/Mempool</a></h1>
<p><img src="theme/images/status-stable.svg" alt="status: updated" />
<strong>Maintainer(s)</strong>: <a href="https://github.com/sdbondi">Stanley Bondi</a>, <a href="https://github.com/SWvheerden">SW van Heerden</a></p>
<h2 id="the-mempool-for-unconfirmed-transactions-on-the-tari-base-layer"><a class="header" href="#the-mempool-for-unconfirmed-transactions-on-the-tari-base-layer">The Mempool for Unconfirmed Transactions on the Tari Base Layer</a></h2>
<!-- TOC -->
<ul>
<li><a href="RFC-0190_Mempool.html#rfc-0190mempool">RFC-0190/Mempool</a>
<ul>
<li><a href="RFC-0190_Mempool.html#the-mempool-for-unconfirmed-transactions-on-the-tari-base-layer">The Mempool for Unconfirmed Transactions on the Tari Base Layer</a></li>
</ul>
</li>
<li><a href="RFC-0190_Mempool.html#license">License</a>
<ul>
<li><a href="RFC-0190_Mempool.html#language">Language</a></li>
<li><a href="RFC-0190_Mempool.html#disclaimer">Disclaimer</a></li>
<li><a href="RFC-0190_Mempool.html#goals">Goals</a></li>
<li><a href="RFC-0190_Mempool.html#related-rfcs">Related RFCs</a></li>
<li><a href="RFC-0190_Mempool.html#description">Description</a>
<ul>
<li><a href="RFC-0190_Mempool.html#assumptions">Assumptions</a></li>
<li><a href="RFC-0190_Mempool.html#abstract">Abstract</a></li>
<li><a href="RFC-0190_Mempool.html#overview">Overview</a></li>
<li><a href="RFC-0190_Mempool.html#prioritizing-unconfirmed-transactions">Prioritizing Unconfirmed Transactions</a></li>
<li><a href="RFC-0190_Mempool.html#memory-pool-state--syncing-and-updating">Memory Pool State: Syncing and Updating</a></li>
<li><a href="RFC-0190_Mempool.html#unconfirmed-pool">Unconfirmed Pool</a></li>
<li><a href="RFC-0190_Mempool.html#reorg-pool">Reorg Pool</a></li>
<li><a href="RFC-0190_Mempool.html#mempool">Mempool</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- TOC -->
<h1 id="license-1"><a class="header" href="#license-1">License</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD License</a>.</p>
<p>Copyright 2018 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-17"><a class="header" href="#language-17">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-17"><a class="header" href="#disclaimer-17">Disclaimer</a></h2>
<p>The purpose of this document and its content is for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-17"><a class="header" href="#goals-17">Goals</a></h2>
<p>This document will introduce the Tari <a href="Glossary.html#base-layer">base layer</a> <a href="Glossary.html#mempool">Mempool</a> that consists of an <a href="Glossary.html#transaction-pool">Unconfirmed Pool</a> and <a href="Glossary.html#reorg-pool">Reorg Pool</a>.
The Mempool is used for storing and managing unconfirmed <a href="Glossary.html#transaction">transactions</a>.</p>
<h2 id="related-rfcs-1"><a class="header" href="#related-rfcs-1">Related RFCs</a></h2>
<ul>
<li><a href="./RFC-0111_BaseNodeArchitecture.html">RFC-0111: Base Node Architecture</a></li>
</ul>
<h2 id="description-11"><a class="header" href="#description-11">Description</a></h2>
<h3 id="assumptions-2"><a class="header" href="#assumptions-2">Assumptions</a></h3>
<ul>
<li>Each <a href="Glossary.html#base-node">base node</a> is connected to a number of peers that maintain their own copies of the Mempool.</li>
</ul>
<h3 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h3>
<p>The Mempool is responsible for managing, verifying and maintaining all unconfirmed transactions that have not yet
been included in a <a href="Glossary.html#block">block</a> and added to the Tari <a href="Glossary.html#blockchain">blockchain</a>. It is also responsible for propagating valid transactions and
sharing the Mempool state with connected peers. An overview of the required functionality for the Mempool and each
of its component pools will be provided.</p>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<p>Every base node maintains a transaction pool called <code>Mempool</code> that consists of two separate pools: the Unconfirmed Pool and Reorg Pool.
These two pools have different tasks and work together to form the Mempool used for maintaining unconfirmed transactions.</p>
<p>This is the role descriptions for each component pool:</p>
<ul>
<li><code>Unconfirmed Pool</code>: contains all unconfirmed transactions that have been verified, have passed all checks, that
only spend valid <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s and don't have any time-lock restrictions.</li>
<li><code>Reorg Pool</code>: stores a backup of all transactions that have recently been included into blocks, in case a blockchain
reorganization occurs and these transactions have to be restored back to the Unconfirmed Pool, so that they can be included
in future blocks.</li>
</ul>
<h3 id="prioritizing-unconfirmed-transactions"><a class="header" href="#prioritizing-unconfirmed-transactions">Prioritizing Unconfirmed Transactions</a></h3>
<p>The maximum storage capacity used for storing unconfirmed transactions by the Mempool and each of its component pools
can be configured. When a new transaction is received and the storage capacity limit is reached, then
transactions are prioritized by ordering their total <code>fee per gram</code> of all UTXOs used and transaction age, in that order.
The transactions of the least priority are discarded to make room for higher priority transactions.</p>
<p>The transaction priority metric has the following behavior:</p>
<ul>
<li>transactions with higher fee per gram <strong>SHOULD</strong> be prioritized over lower fee per gram transactions.</li>
<li>older transactions in the mempool <strong>SHOULD</strong> be prioritized over newer ones.</li>
</ul>
<h3 id="memory-pool-state-syncing-and-updating"><a class="header" href="#memory-pool-state-syncing-and-updating">Memory Pool State: Syncing and Updating</a></h3>
<p>On the initial startup, the complete state of the unconfirmed pool is pulled from the connected peers. Typically, Mempool
doesn't persist its state, but can be configured to do so. If the state is locally present, then only the missing, unconfirmed transactions
are synced from the peers, otherwise, the full state is requested. The validity and priority of transactions are computed
as they are being downloaded from the connected peers. If the base node undergoes a re-org, then the missing state is again 
pulled from the peers.</p>
<p>The functional bahavior required for the Mempool's synchronization are the following:</p>
<ul>
<li>All verified transactions <strong>MUST</strong> be propagated to neighboring peers.</li>
<li>Unverified or invalid transactions <strong>MUST NOT</strong> be propagated to peers.</li>
<li>Verified transactions that were discarded due to low priority levels <strong>MUST</strong> be propagated to peers.</li>
<li>Duplicate transactions <strong>MUST NOT</strong> be propagated to peers.</li>
<li>Mempool <strong>MUST</strong> have an interface, allowing peers to query and download its state, partially and in full.</li>
<li>Mempool <strong>MUST</strong> accept all transactions received from peers but <strong>MAY</strong> decide to discard low-priority transactions.</li>
<li>Mempool <strong>MUST</strong> allow wallets to track payments by monitoring that a particular transaction has been added to the Mempool.</li>
<li>Mempool <strong>MAY</strong> choose:
<ul>
<li>to discard its state on restart and then download the full state from its peers or</li>
<li>to store its state using persistent storage to reduce communication bandwidth required when
reinitializing the pool after a restart.</li>
</ul>
</li>
</ul>
<h3 id="unconfirmed-pool"><a class="header" href="#unconfirmed-pool">Unconfirmed Pool</a></h3>
<p>This Mempool component consists of transactions that have been received, verified and have passed
all the checks, but not yet included in the blocks. These transactions are ready to be used to construct 
new blocks for the Tari blockchain.</p>
<p>Functional behavior required of the Unconfirmed Pool:</p>
<ul>
<li>It <strong>MUST</strong> verify that incoming transactions spend only existing UTXOs.</li>
<li>It <strong>MUST</strong> ensure that incoming transactions don't have a processing time-lock or has a time-lock that has
expired.</li>
<li>It <strong>MUST</strong> ensure that all time-locks of the UTXOs that will be spent by the transaction have expired.</li>
<li>Transactions that have been used to construct new blocks <strong>MUST</strong> be removed from the Unconfirmed Pool and added to the Reorg Pool.</li>
</ul>
<h3 id="reorg-pool"><a class="header" href="#reorg-pool">Reorg Pool</a></h3>
<p>The Reorg Pool consists of transactions that have recently been added to blocks, resulting in
their removal from the Unconfirmed Pool. When a potential blockchain reorganization occurs that invalidates previously
assembled blocks, the transactions used to construct these discarded blocks can be moved back into the Unconfirmed Pool. 
This ensures that high-priority transactions are not lost during reorganization and can be included in future blocks. 
The Reorg Pool is an internal, isolated Mempool component and cannot be accessed or queried from outside.</p>
<p>Functional behavior required of the Reorg Pool:</p>
<ul>
<li>Copies of the transactions used recently in blocks <strong>MUST</strong> be stored in the Reorg Pool.</li>
<li>Transactions in the Reorg Pool <strong>MAY</strong> be discarded after a set expiration threshold has been reached.</li>
<li>When reorganization is detected, all affected transactions found in the Reorg Pool <strong>MUST</strong> be moved back to the
Unconfirmed Pool and removed from the Reorg Pool.</li>
</ul>
<h3 id="mempool"><a class="header" href="#mempool">Mempool</a></h3>
<p>The Mempool is responsible for the internal transaction management and synchronization with the peers. New transactions
must pass all verification steps to make it into the Unconfirmed Pool and further be propagated to peers.</p>
<p>Functional behavior required of the Mempool:</p>
<ul>
<li>If the received transaction already exists in the Mempool, then it <strong>MUST</strong> be discarded.</li>
<li>If multiple transactions contain the same UTXO, then only the highest priority transaction <strong>MUST</strong> be kept and the
rest (having the said UTXO included) <strong>MUST</strong> be discarded.</li>
<li>If the storage capacity limit is reached, then new incoming transactions <strong>SHOULD</strong> be prioritized according
to a set number of <a href="RFC-0190_Mempool.html#prioritizing-unconfirmed-transactions">rules</a>.</li>
<li>Transactions of the least priority <strong>MUST</strong> be discarded to make room for higher priority incoming transactions.</li>
<li>Transactions with its computed priority being lower than the minimum set threshold <strong>MUST</strong> be discarded.</li>
<li>The Mempool <strong>MUST</strong> verify that incoming transactions do not have duplicate outputs.</li>
<li>The Mempool <strong>MUST</strong> verify that only matured coinbase outputs can be spent.</li>
<li>Each component pool <strong>MAY</strong> have the storage capacity configured and adjusted.</li>
<li>The memory pool <strong>SHOULD</strong> have a mechanism to estimate fee categories from the current Mempool state. For example, 
the transaction fee can be estimated, ensuring that new transactions will be properly prioritized, to be added
into new blocks in a timely manner.</li>
</ul>
<p>Functional behavior required for the allocation of incoming transactions in the component pools:</p>
<ul>
<li>Verified transactions that have passed all checks such as spending of valid UTXOs and expired time-locks <strong>MUST</strong> be
placed in the Unconfirmed Pool.</li>
<li>Incoming transactions with time-locks, prohibiting them from being included in new blocks <strong>SHOULD</strong> be discarded.</li>
<li>Newly received, verified transactions attempting to spend a UTXO that does not yet exist <strong>MUST</strong> be discarded.</li>
<li>Transactions that have been added to blocks and were removed from the Unconfirmed Pool <strong>SHOULD</strong> be added to the Reorg Pool.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tari-specific-base-layer-extensions"><a class="header" href="#tari-specific-base-layer-extensions">Tari-specific Base Layer Extensions</a></h1>
<p>This section covers RFCs that describe extensions to the Mimblewimble protocol that enable key functionality for the
Tari Base layer token and Digital Asset network.</p>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="RFC-0202_TariScriptOpcodes.html">RFC-0202: TariScript Opcodes</a></li>
<li><a href="RFC-0203_StealthAddresses.html">RFC-0203: Stealth Addresses</a></li>
<li><a href="RFC-0230_HTLC.html">RFC-0230: Time related transactions</a></li>
<li><a href="RFC-0240_AtomicSwap.html">RFC-0240: Atomic swaps</a></li>
<li><a href="RFC-0250_Covenants.html">RFC-0250: Covenants</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0201tariscript"><a class="header" href="#rfc-0201tariscript">RFC-0201/TariScript</a></h1>
<h2 id="tariscript"><a class="header" href="#tariscript">TariScript</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>, <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-16"><a class="header" href="#licence-16">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2020 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-18"><a class="header" href="#language-18">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-18"><a class="header" href="#disclaimer-18">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-18"><a class="header" href="#goals-18">Goals</a></h2>
<p>This Request for Comment (RFC) presents a proposal for introducing <a href="Glossary.html#tariscript">TariScript</a> into the Tari base layer protocol. Tari
Script aims to provide a general mechanism for enabling further extensions such as side-chains, the DAN, one-sided
payments and atomic swaps.</p>
<h2 id="related-requests-for-comment-15"><a class="header" href="#related-requests-for-comment-15">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0182_CommitmentSignatures.html">RFC-0182: Commitment and public key signatures</a></li>
<li><a href="BaseLayerExtensions.html">RFC-0200: Base Layer Extensions</a></li>
<li><a href="RFC-0202_TariScriptOpcodes.html">RFC-0202: TariScript Opcodes</a></li>
<li><a href="RFC-0204_TariScriptExamples.html">RFC-0204: TariScript Examples</a></li>
<li><a href="RFC-0250_Covenants.html">RFC-0250: Covenants</a></li>
</ul>
<p>$$
\newcommand{\script}{\alpha} % utxo script
\newcommand{\input}{ \theta }
\newcommand{\cat}{\Vert}
\newcommand{\so}{\gamma} % script offset
\newcommand{\hash}[1]{\mathrm{H}\bigl({#1}\bigr)}
$$</p>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>It is hopefully clear to anyone reading these RFCs that the ambitions of the Tari project extend beyond a
Mimblewimble-clone-coin.
It should also be fairly clear that vanilla Mimblewimble does not have the feature set to provide functionality such as:</p>
<ul>
<li>One-sided payments</li>
<li>Multiparty side-chain peg-outs and peg-ins</li>
<li>Generalised smart contracts</li>
</ul>
<p>Extensions to <a href="Glossary.html#mimblewimble">Mimblewimble</a> have been proposed for most of these features, for example, David Burkett's one-sided payment
proposal for LiteCoin (<a href="https://github.com/DavidBurkett/lips/blob/master/lip-0004.mediawiki">LIP-004</a>) and this project's <a href="RFC-0230_HTLC.html">HTLC RFC</a>.</p>
<p>Some smart contract features are possible, or partly possible in vanilla <a href="Glossary.html#mimblewimble">Mimblewimble</a> using <a href="https://tlu.tarilabs.com/cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html">Scriptless script</a>, such as</p>
<ul>
<li>Atomic swaps </li>
<li>Hash time-locked contracts</li>
</ul>
<p>Tari implemented a scripting language similar to Bitcoin script, called <a href="Glossary.html#tariscript">TariScript</a>, under a single set of (relatively 
minor) modifications and additions to the Mimblewimble protocol, which achieved collapsing all of these use cases.</p>
<h2 id="scripting-on-mimblewimble"><a class="header" href="#scripting-on-mimblewimble">Scripting on Mimblewimble</a></h2>
<p>Other than Beam, none of the existing <a href="Glossary.html#mimblewimble">Mimblewimble</a> projects have employed a scripting language. </p>
<p><a href="https://github.com/mimblewimble/grin">Grin</a> styles itself as a &quot;Minimal implementation of the Mimblewimble protocol&quot;,
so one might infer that this status is unlikely to change soon.</p>
<p>Beam <a href="https://github.com/BeamMW/beam/wiki/Beam-Smart-Contracts">does have a smart contract</a>
protocol, which allows users to execute arbitrary code (shaders) in a sandboxed Beam VM and have the results of that 
code interact with transactions.</p>
<p><a href="https://github.com/mwcproject/mwc-node/blob/master/doc/roadmap.md">Mimblewimble coin</a> is a fork of Grin and &quot;considers
the protocol ossified&quot;.</p>
<p>Litecoin has included Mimblewimble as a
<a href="https://github.com/litecoin-project/lips/blob/master/lip-0003.mediawiki">side-chain through MWEB</a>. As of 2022, there 
appears to be no plans to include general scripting into the protocol.</p>
<h3 id="scriptless-scripts"><a class="header" href="#scriptless-scripts">Scriptless scripts</a></h3>
<p><a href="https://tlu.tarilabs.com/cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html">Scriptless script</a> is a wonderfully elegant technology and the inclusion of <a href="Glossary.html#tariscript">TariScript</a> does not preclude the use of
Scriptless scripts in Tari. However, scriptless scripts have some disadvantages:</p>
<ul>
<li>They are often difficult to reason about, with the result that the development of features based on scriptless scripts
is essentially in the hands of a very select group of cryptographers and developers.</li>
<li>The use case set is impressive considering that the &quot;scripts&quot; are essentially signature wrangling, but is still 
somewhat limited.</li>
<li>Every feature must be written and implemented separately using the specific and specialised protocol designed for that
feature. That is, it cannot be used as a dynamic scripting framework on a running blockchain.</li>
</ul>
<h2 id="tariscript---a-brief-motivation"><a class="header" href="#tariscript---a-brief-motivation">TariScript - a brief motivation</a></h2>
<p>The essential idea of <a href="Glossary.html#tariscript">TariScript</a> is as follows:</p>
<p>Given a standard Tari UTXO, we add <em>additional restrictions</em> on whether that UTXO can be included as a valid input in a
transaction.</p>
<p>As long as those conditions are suitably committed to, are not malleable throughout the existence of the UTXO, and one
can prove that the script came from the UTXO owner, then these conditions are not that different to the 
requirement of having range proofs attached to UTXOs, which require that the value of Tari commitments is non-negative.</p>
<p>This argument is independent of the nature of the additional restrictions. Specifically, if these restrictions are
manifested as a script that provides additional constraints over whether a UTXO may be spent, the same arguments apply.</p>
<p>This means that in a very hand-wavy sort of way, there ought to be no reason that TariScript is not workable.</p>
<p>Note that range proofs can be discarded after a UTXO is spent. This entails that the global security guarantees of
Mimblewimble is not that every transaction in history was valid from an inflation perspective, but that the net effect
of all transactions leads to zero spurious inflation. This sounds worse than it is, since locally, every individual
transaction is checked for validity at the time of inclusion in the blockchain.</p>
<p>If it somehow happened that two illegal transactions made it into the blockchain (perhaps due to a bug), and the two
cancelled each other out such that the global coin supply was still correct, one would never know this when doing a
chain synchronisation in pruned mode.</p>
<p>But if there was a steady inflation bug due to invalid range proofs making it into the blockchain, a pruned mode sync
would still detect that <em>something</em> was awry, because the global coin supply balance acts as another check.</p>
<p>With TariScript, once the script has been pruned away, and then there is a re-org to an earlier point on the chain,
then there's no way to ensure that the script was honoured unless you run an archival node.</p>
<p>This is broadly in keeping with the Mimblewimble security guarantees that, in pruned-mode synchronisation, individual 
transactions are not necessarily verified during chain synchronisation.</p>
<p>However, the guarantee that no additional coins are created or destroyed remains intact.</p>
<p>Put another way, the blockchain relies on the network <em>at the time</em> to enforce the TariScript spending rules. 
This means that the scheme may be susceptible to certain <em>horizon attacks</em>.</p>
<p>Incidentally, a single honest archival node would be able to detect any fraud on the same chain and provide a simple 
proof that a transaction did not honour the redeem script.</p>
<h3 id="additional-requirements"><a class="header" href="#additional-requirements">Additional requirements</a></h3>
<p>The assumptions that broadly equate scripting with range proofs in the above argument are:</p>
<ul>
<li>The script must be committed to the blockchain.</li>
<li>The script must not be malleable in any way without invalidating the transaction. This restriction extends to all 
participants, including the UTXO owner.</li>
<li>We must be able to prove that the UTXO originator provides the script and no one else.</li>
<li>The scripts and their redeeming inputs must be stored on the blockchain. In particular, the input data must not be
malleable.</li>
</ul>
<h3 id="preventing-cut-through"><a class="header" href="#preventing-cut-through">Preventing Cut-through</a></h3>
<p>A major issue with many Mimblewimble extension schemes is that miners are able to cut-through UTXOs if an output is 
spent in the same block it was created. This makes it so that the intervening UTXO never existed; along with any checks 
and balances carried in that UTXO. It's also impossible to prove without additional information that cut-through even 
occurred (though one may suspect, since the &quot;one&quot; transaction would contribute two kernels to the block).</p>
<p>In particular, cut-through is devastating for an idea like TariScript which relies on conditions present in the UTXO 
being enforced. For example, say there is a UTXO in the mempool that everyone knows the blinding factor to, but is 
restricted to a single public key via the TariScript. A malicious user can spend the UTXO in a zero-conf transaction, 
and send the cut-through transaction to the mempool. Since the miner only sees the resulting aggregate transaction, it 
cannot know that there was a TariScript on the removed UTXO. The solution to this problem is described later in this RFC.</p>
<p>In contrast, range proofs are still valid if they are cut-through, because the resulting UTXOs must have 
valid range proofs. </p>
<h2 id="protocol-additions"><a class="header" href="#protocol-additions">Protocol additions</a></h2>
<p>Please refer to <a href="RFC-0201_TariScript.html#notation">Notation</a>, which provides important pre-knowledge for the remainder of the report.</p>
<p>At a high level, TariScript works as follows:</p>
<ul>
<li>The spending <em>script</em> \((\script)\) is recorded in the transaction UTXO.</li>
<li>Although scripts are included on the UTXO, they are only executed when the UTXO is <strong>spent</strong>, and in most cases, will 
require additional input data to be provided at this time. </li>
<li>The <em>script input data</em> is recorded in the transaction inputs.</li>
<li>When validating a transaction, the <em>script</em> is executed using the <em>script input data</em>.</li>
<li>After the <em>script</em> \((\script)\) is executed, the execution stack must contain exactly one value that will be 
interpreted as the <em><a href="Glossary.html#script-keypair">script public key</a></em> \((K_{S})\). </li>
<li>The <em><a href="Glossary.html#script-keypair">script public key</a></em> and commitment must match the <em>script signature</em> on the input, which prevents malleability 
of the data in the input.</li>
<li>To prevent a script from being removed from a UTXO, a new field  <em><a href="Glossary.html#sender-offset-keypair">sender offset</a> public key</em> \((K_{O})\) has been 
added.</li>
<li>The <em>sender offset private keys</em> \((k_{O})\) and <em>script private keys</em> \((k_{S})\) are used in conjunction to 
create a <em>script offset</em> \((\so)\), which are used in the consensus balance to prevent a number of attacks.</li>
</ul>
<blockquote>
<p>NOTE: One can prove ownership of a UTXO by demonstrating knowledge of both the commitment <em>blinding factor</em> \((k\)), 
<em>and</em> the <em><a href="Glossary.html#script-keypair">script private key</a></em> \((k_{S})\) for a valid script input.</p>
</blockquote>
<h3 id="utxo-data-commitments"><a class="header" href="#utxo-data-commitments">UTXO data commitments</a></h3>
<p>The script, as well as other UTXO metadata, such as the output features are signed for with the <a href="Glossary.html#sender-offset-keypair">sender offset</a> private 
key to prevent malleability. As we will describe later, the notion of a <a href="Glossary.html#script-offset">script offset</a> is introduced to prevent 
cut-through and forces the preservation of these commitments until they are recorded into the blockchain.</p>
<h3 id="transaction-output"><a class="header" href="#transaction-output">Transaction output</a></h3>
<p>The definition of a Tari transaction output is:</p>
<pre><code class="language-rust ignore">pub struct TransactionOutput {
    /// The transaction output version
    version: TransactionOutputVersion,
    /// Options for an output's structure or use
    features: OutputFeatures,
    /// The homomorphic commitment representing the output amount
    commitment: Commitment,
    /// A proof that the commitment is in the right range
    proof: RangeProof,
    /// The serialised script
    script: Vec&lt;u8&gt;,
    /// The sender offset pubkey, K_O
    sender_offset_public_key: PublicKey
    /// UTXO signature signing the transaction output data and the homomorphic commitment with a combination 
    /// of the homomorphic commitment private values (amount and blinding factor) and the sender offset private key.
    metadata_signature: CommitmentAndPublicKeySignature,
    /// The covenant that will be executed when spending this output
    covenant: Covenant,
    /// The encrypted commitment value.
    encrypted_value: EncryptedValue,
    /// The minimum value of the commitment that is proven by the range proof
    minimum_value_promise: MicroTari,
}</code></pre>
<p>The <a href="Glossary.html#metadata-signature">metadata signature</a> is a <a href="Glossary.html#commitment-and-public-key-signature">CAPK signature</a> (as described in <a href="./RFC-0182_CommitmentSignatures.html">RFC-0182</a>) signed with 
the commitment value, \( v_i \), known by the sender and receiver, the spending key, \( k_i \), known by the 
receiver and the sender offset private key, \(k_{Oi}\), known by the sender. (<em>Note that \( k_{Oi} \) should be 
treated as a nonce.</em>) The CAPK signature is effectively an aggregated CAPK signature between the sender and receiver, 
and the challenge consists of all the transaction output metadata, effectively forming a contract between the sender and 
receiver, making all those values non-malleable and ensuring only the sender and receiver can enter into this contract.</p>
<p>For purposes of this RFC, we denote the metadata signature terms as follows:</p>
<ul>
<li>\( R_{MRi} \) is the ephemeral commitment, </li>
<li>\( R_{MSi} \) is the ephemeral public key, </li>
<li>\( a_{MRi} \) and \( b_{MRi} \) are the first and second commitment signature scalars,</li>
<li>\( b_{MSi} \) is the public key signature scalar. </li>
</ul>
<p><u>Sender:</u></p>
<p>The sender's ephemeral public key is:</p>
<p>$$
\begin{aligned}
R_{MSi} &amp;= r_{MSi_b} \cdot G
\end{aligned}
\tag{3}
$$</p>
<p>The sender sends \( (K_{Oi}, R_{MSi}) \) along with the other partial transaction information 
\( (\script_i, F_i) \) to the receiver, who now has all the required information to calculate the final challenge.</p>
<p><u>Reciver:</u></p>
<p>The commitment definition is unchanged:</p>
<p>$$
\begin{aligned}
C_i = v_i \cdot H  + k_i \cdot G
\end{aligned}
\tag{4}
$$</p>
<p>The receiver's ephemeral commitment is:</p>
<p>$$
\begin{aligned}
R_{MRi} &amp;= r_{MRi_a} \cdot H + r_{MRi_b} \cdot G
\end{aligned}
\tag{5}
$$</p>
<p>The final challenge is:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{ R_{MSi} \cat R_{MRi} \cat \script_i \cat F_i \cat K_{Oi} \cat C_i \cat \pi_i \cat \varphi_i \cat \vartheta_i } \\
\end{aligned}
\tag{6}
$$</p>
<p>The receiver can now calculate their portion of the aggregated CAPK signature as:</p>
<p>$$
\begin{aligned}
a_{MRi} &amp;= r_{MRi_a} + e \cdot v_{i} \\
b_{MRi} &amp;= r_{MRi_b} + e \cdot k_i
\end{aligned}
\tag{7}
$$</p>
<p>The receiver sends \( s_{MRi} = (a_{MRi}, b_{MRi}, R_{MRi} ) \) along with the other partial transaction information
\( (C_i) \) to the sender.</p>
<p><u>Sender:</u></p>
<p>The sender starts by calculating the final challenge \( e \) (6) and then completes their part of the aggregated CAPK 
signature.</p>
<p>$$
\begin{aligned}
b_{MSi} &amp;= r_{MSi_b} + e \cdot k_{Oi}
\end{aligned}
\tag{8}
$$</p>
<p>The final CAPK signature is combined as follows:</p>
<p>$$
\begin{aligned}
s_{Mi} = (a_{MRi}, b_{MRi}, R_{MRi}, b_{MSi}, R_{MSi} )
\end{aligned}
\tag{9}
$$</p>
<p><u>Verifier:</u></p>
<p>This is verified by the following:</p>
<p>$$
\begin{aligned}
a_{MRi} \cdot H + b_{MRi} \cdot G &amp;\overset{?}{=} R_{MRi} + e \cdot C \\
b_{MSi} \cdot G &amp;\overset{?}{=} R_{MSi} + e \cdot K_{Oi}
\end{aligned}
\tag{10}
$$</p>
<p>Note that:</p>
<ul>
<li>The UTXO has a positive value \( v \) like any normal UTXO.</li>
<li>The script and the output features can no longer be changed by the miner or any other party. This includes the sender 
and receiver; they would need to cooperate to enter into a new contract to change any metadata, otherwise, the 
metadata signature will be invalidated.</li>
<li>We provide the complete script on the output.</li>
</ul>
<h3 id="transaction-input"><a class="header" href="#transaction-input">Transaction input</a></h3>
<p>In standard Mimblewimble, an input is the same as an output <em>sans</em> range proof. The range proof doesn't need to be 
checked again when spending inputs, so it is dropped. </p>
<p>The definition of a Tari transaction input is:</p>
<pre><code class="language-rust ignore">pub struct TransactionInput {
    /// The transaction input version
    version: TransactionInputVersion,
    /// The output that will be spent that this input is referencing 
    spent_output: SpentOutput {
        /// The transaction output version
        version: TransactionOutputVersion,
        /// Options for an output's structure or use
        features: OutputFeatures,
        /// The homomorphic Pedersen commitment representing the output amount
        commitment: Commitment,
        /// The serialised script
        script: Vec&lt;u8&gt;,
        /// The sender offset pubkey, K_O
        sender_offset_public_key: PublicKey
        /// The covenant that will be executed when spending this output
        covenant: Covenant,
        /// The encrypted commitment value.
        encrypted_value: EncryptedValue,
        /// The minimum value of the commitment that is proven by the range proof
        minimum_value_promise: MicroTari,
    }
    /// The script input data, if any
    input_data: Vec&lt;u8&gt;,
    /// Signature signing the script, input data, [script public key], and the homomorphic commitment with a combination 
    /// of the homomorphic commitment private values (amount and blinding factor) and the [script private key].
    script_signature: CommitmentAndPubKeySignature,
}</code></pre>
<p>The <a href="Glossary.html#script-signature">script signature</a> is a <a href="Glossary.html#commitment-and-public-key-signature">CAPK signature</a>  using a combination of the output commitment private values 
\( (v_i \, , \, k_i )\) and <a href="Glossary.html#script-keypair">script private key</a> \(k_{Si}\) to prove ownership thereof. It signs the script, 
the script input, <a href="Glossary.html#script-keypair">script public key</a>, and the commitment.</p>
<p>For purposes of this RFC, we denote the script signature terms as follows:</p>
<ul>
<li>\( R_{SCi} \) is the ephemeral commitment,</li>
<li>\( R_{SPi} \) is the ephemeral public key,</li>
<li>\( a_{SCi} \) and \( b_{SCi} \) are the first and second commitment signature scalars,</li>
<li>\( b_{SPi} \) is the public key signature scalar.</li>
</ul>
<p><u>Sender:</u></p>
<p>The script signature is given by</p>
<p>$$
\begin{aligned}
s_{Si} = (a_{SCi}, b_{SCi}, R_{SCi}, b_{SPi}, R_{SPi} )
\end{aligned}
\tag{11}
$$</p>
<p>where</p>
<p>$$
\begin{aligned}
R_{SCi} &amp;= r_{SCi_a} \cdot H + r_{SCi_b} \cdot G \\
a_{SCi}  &amp;= r_{SCi_a} +  e \cdot v_i \\
b_{SCi} &amp;= r_{SCi_b} +  e \cdot k_i \\
R_{SPi} &amp;= r_{SPi_b} \cdot G \\
b_{SPi} &amp;= r_{SPi_b} +  e \cdot k_{Si} \\
\end{aligned}
\tag{12}
$$</p>
<p>with the challenge being</p>
<p>$$
\begin{aligned}
e &amp;= \hash{ R_{SCi} \cat R_{SPi} \cat \alpha_i \cat \input_i \cat K_{Si} \cat C_i} \\
\end{aligned}
\tag{13}
$$</p>
<p><u>Verifier:</u></p>
<p>This is verified by the following:</p>
<p>$$
\begin{aligned}
a_{SCi} \cdot H + b_{SCi} \cdot G &amp;\overset{?}{=} R_{SCi} + e \cdot C \\
b_{SPi} \cdot G &amp;\overset{?}{=} R_{SPi} + e \cdot K_{Si}
\end{aligned}
\tag{14}
$$</p>
<p>The script public key \(K_{Si}\) needed for the script signature verification is not stored with the 
TransactionInput, but obtained by executing the script with the provided input data. Because this signature is signed 
with the script private key \(k_{Si}\), it ensures that only the owner can provide the input data \(\input_i\) to 
the TransactionInput. </p>
<h3 id="script-offset"><a class="header" href="#script-offset">Script Offset</a></h3>
<p>For every transaction, an accompanying <a href="Glossary.html#script-offset">script offset</a> \( \so \) needs to be provided. This is there to prove that every<br />
script public key \( K_{Sj} \) and every sender offset public key \( K_{Oi} \) supplied with the UTXOs are the 
correct ones. The sender will know and provide sender offset private keys \(k_{Oi} \) and script private keys 
\(k_{Si} \); these are combined to create the script offset \( \so \), which is calculated as follows:</p>
<p>$$
\begin{aligned}
\so = \sum_j\mathrm{k_{Sj}} - \sum_i\mathrm{k_{Oi}} \; \text{for each input}, j,\, \text{and each output}, i
\end{aligned}
\tag{15}
$$</p>
<p>Verification of (15) will entail:</p>
<p>$$
\begin{aligned}
\so \cdot G = \sum_j\mathrm{K_{Sj}} - \sum_i\mathrm{K_{Oi}} \; \text{for each input}, j,\, \text{and each output}, i
\end{aligned}
\tag{16}
$$</p>
<p>We modify the transactions to be:</p>
<pre><code class="language-rust ignore">pub struct Transaction {
    
    ...
    
    /// A scalar offset that links outputs and inputs to prevent cut-through, enforcing the correct application of
    /// the output script.
    pub script_offset: BlindingFactor,
}</code></pre>
<p>All script offsets (\(\so\)) from (15) contained in a block are summed together to create a total <a href="Glossary.html#script-offset">script offset</a> (17) 
so that algorithm (15) still holds for a block.</p>
<p>$$
\begin{aligned}
\so_{total} = \sum_k\mathrm{\so_{k}}\; \text{for every transaction}, k
\end{aligned}
\tag{17}
$$</p>
<p>Verification of (17) will entail:</p>
<p>$$
\begin{aligned}
\so_{total} \cdot G = \sum_j\mathrm{K_{Sj}} - \sum_i\mathrm{K_{Oi}} \; \text{for each input}, j,\, \text{and each output}, i
\end{aligned}
\tag{18}
$$</p>
<p>As can be seen, all information required to verify (17) is contained in a block's inputs and outputs. One important 
distinction to make is that the Coinbase output in a coinbase transaction does not count toward the script offset. 
This is because the Coinbase UTXO already has special rules accompanying it and it has no input, thus we cannot generate 
a script offset \( \so \). The coinbase output can allow any script \(\script_i\) and sender offset public key 
\( K_{Oi} \) as long as it does not break any of the rules in <a href="RFC-0120_Consensus.html">RFC 120</a> and the script is 
honored at spend. If the coinbase is used as an input, it is treated exactly the same as any other input.</p>
<p>We modify Blockheaders to be:</p>
<pre><code class="language-rust ignore">pub struct BlockHeader {
    
    ...
    
    /// Sum of script offsets for all kernels in this block.
    pub total_script_offset: Scalar,
}</code></pre>
<p>This notion of the script offset \(\so\) means that no third party can remove any input or output from a 
transaction or the block, as that will invalidate the script offset balance equation, either (16) or (18) depending on 
whether the scope is a transaction or block. It is important to know that this also stops 
<a href="RFC-0201_TariScript.html#cut-through">cut‑through</a> so that we can verify all spent UTXO scripts. Because the script private key and<br />
sender offset private key are not publicly known, it's impossible to create a new script offset.</p>
<p>Certain scripts may allow more than one valid set of input data. Users might be led to believe that this will allow a 
third party to change the script keypair \((k_{Si}\),\(K_{Si})\). If an attacker can change the \(K_{Si}\) 
keys of the input then he can take control of the \(K_{Oi}\) as well, allowing the attacker to change the metadata of 
the UTXO including the script. But as shown in <a href="RFC-0201_TariScript.html#script-offset-security">Script offset security</a>, this is not possible.</p>
<p>If equation (16) or (18) balances then we know that each included input and output in the transaction or block has its 
correct script public key and sender offset public key. Signatures (9) &amp; (11) are checked independently from script 
offset verification (16) and (18), and looked at in isolation those could verify correctly but can still be signed by 
fake keys. When doing verification in (16) and (18) you know that the signatures and the message/metadata signed by the 
private keys can be trusted.</p>
<h3 id="consensus"><a class="header" href="#consensus">Consensus</a></h3>
<p>TariScript does not impact the Mimblewimble balance for blocks and transactions, however, an additional consensus rule for 
transaction and block validation is required.</p>
<p>Verify that for every valid transaction or block:</p>
<ol>
<li>The <a href="Glossary.html#metadata-signature">metadata signature</a> \( s_{Mi} \) is valid for every output.</li>
<li>The script executes successfully using the given input script data.</li>
<li>The result of the script is a valid script public key, \( K_S \).</li>
<li>The script signature, \( s_{Si} \), is valid for every input.</li>
<li>The script offset is valid for every transaction and block.</li>
</ol>
<h3 id="preventing-cut-through-with-the-script-offset"><a class="header" href="#preventing-cut-through-with-the-script-offset">Preventing Cut-through with the Script Offset</a></h3>
<p>Earlier, we described that cut-through must be prevented; this is achieved by the script offset. It mathematically links 
all inputs and outputs of all the transactions in a block and that tallied up creates the script offset. Providing the 
script offset requires knowledge of keys that miners do not possess; thus they are unable to produce the necessary 
script offset when attempting to perform cut-through on a pair of transactions.</p>
<p>Let's show by example how the script offset stops cut-through, where Alice spends to Bob who spends to Carol. Ignoring 
fees, we have: </p>
<p>$$
C_a \Rightarrow  C_b \Rightarrow  C_c
$$</p>
<p>For these two transactions, the total script offset is calculated as follows:</p>
<p>$$
\begin{aligned}
\so_1 = k_{Sa} - k_{Ob}\\
\so_2 = k_{Sb} - k_{Oc}\\
\end{aligned}
\tag{19}
$$</p>
<p>$$
\begin{aligned}
\so_t = \so_1 + \so_2 =  (k_{Sa} + k_{Sb}) - (k_{Ob} + k_{Oc})\\
\end{aligned}
\tag{20}
$$</p>
<p>In standard Mimblewimble <a href="https://tlu.tarilabs.com/protocols/grin-protocol-overview/MainReport.html#cut-through">cut-through</a> can be applied to get:</p>
<p>$$
C_a \Rightarrow  C_c
$$</p>
<p>After cut-through the total script offset becomes: </p>
<p>$$
\begin{aligned}
\so'_t = k_{Sa} - k_{Oc}\\
\end{aligned}
\tag{21}
$$</p>
<p>As we can see:</p>
<p>$$
\begin{aligned}
\so_t\ \neq \so'_t \\
\end{aligned}
\tag{22}
$$</p>
<p>A third party cannot generate a new script offset as only the original owner can provide the script private key 
\(k_{Sa}\) to create a new script offset. </p>
<h3 id="script-offset-security"><a class="header" href="#script-offset-security">Script offset security</a></h3>
<p>If all the inputs in a transaction or a block contain scripts such as just <code>NOP</code> or <code>CompareHeight</code> commands, then the 
hypothesis is that it is possible to recreate a false script offset. Let's show by example why this is not possible. In 
this Example we have Alice who pays Bob with no change output:</p>
<p>$$
C_a \Rightarrow  C_b
$$</p>
<p>Alice has an output \(C_{a}\) which contains a script that only has a <code>NOP</code> command in it. This means that the 
script \( \script_a \) will immediately exit on execution leaving the entire input data \( \input_a \)on the 
stack. She sends all the required information to Bob as per the <a href="RFC-0201_TariScript.html#standard-mw-transaction">standard mw transaction</a>, who 
creates an output \(C_{b}\). Because of the <code>NOP</code> script \( \script_a \), Bob can change the script public key 
\( K_{Sa}\) contained in the input data. Bob can now use his own \(k'_{Sa}\) as the script private key. He 
replaces the sender offset public key with his own \(K'_{Ob}\) allowing him to change the script 
\( \script_b \) and generate a new signature as in (9). Bob can now generate a new script offset with 
\(\so' = k'_{Sa} - k'_{Ob} \). Up to this point, it all seems valid. No one can detect that Bob changed the script 
to \( \script_b \).</p>
<p>But what Bob also needs to do is generate the signature in (13). For this signature, Bob needs to know 
\(k_{Sa}, k_a, v_a\). Because Bob created a fake script private key, and there is no change in this transaction, 
he does know the script private key and the value. But Bob does not know the blinding factor \(k_a\) of Alice's 
commitment and thus cannot complete the signature in (13). Only the rightful owner of the commitment, which in 
Mimblewimble terms is the person who knows \( k_a, v_a\), and can generate the signature in (13).</p>
<h3 id="script-lock-key-generation"><a class="header" href="#script-lock-key-generation">Script lock key generation</a></h3>
<p>At face value, it looks like the burden for wallets has tripled, since each UTXO owner has to remember three private 
keys, the spend key, \( k_i \), the sender offset key \( k_{O} \), and the script key \( k_{S} \). In practice, the 
script key will often be a static key associated with the user's node or wallet. Even if it is not, the script and 
sender offset keys can be deterministically derived from the spend key. For example, \( k_{S} \) could be 
\( \hash{ k_i \cat \alpha} \).</p>
<h3 id="blockchain-bloat"><a class="header" href="#blockchain-bloat">Blockchain bloat</a></h3>
<p>The most obvious drawback to TariScript is the effect it has on blockchain size. UTXOs are substantially larger,
with the addition of the script, metadata signature, script signature, and a public key to every output.</p>
<p>These can eventually be pruned but will increase storage and bandwidth requirements.</p>
<p>The input size of a block is much bigger than in standard Mimblewimble, whereas it would only be a commitment and output 
features. In Tari, each input includes a script, input_data, the script signature, and an extra public key. This could be 
compacted by just broadcasting input hashes along with the missing script input data and signature, instead of the full 
input in a transaction message, but this will still be larger than standard Mimblewimble inputs.</p>
<p>In Tari, every header is also bigger as it includes an extra blinding factor that cannot be pruned away.</p>
<h3 id="fodder-for-chain-analysis"><a class="header" href="#fodder-for-chain-analysis">Fodder for chain analysis</a></h3>
<p>Another potential drawback of TariScript is the additional information that is handed to entities wishing to perform 
chain analysis. Having scripts attached to outputs will often clearly mark the purpose of that UTXO. Users may wish to 
re-spend outputs into vanilla, default UTXOs in a mixing transaction to disassociate Tari funds from a particular 
script.</p>
<h2 id="notation-1"><a class="header" href="#notation-1">Notation</a></h2>
<p>Where possible, the &quot;usual&quot; notation is used to denote terms commonly found in cryptocurrency literature. Lowercase 
characters are used as private keys, while uppercase characters are used as public keys. New terms introduced by 
TariScript are assigned Greek lowercase letters in most cases. </p>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Definition</th></tr></thead><tbody>
<tr><td>\( \script_i \)</td><td>An output script for output <em>i</em>, serialised to binary.</td></tr>
<tr><td>\( F_i \)</td><td>Output features for UTXO <em>i</em>.</td></tr>
<tr><td>\( f_t \)</td><td>Transaction fee for transaction <em>t</em>.</td></tr>
<tr><td>\( (k_{Oi}, K_{Oi}) \)</td><td>The private - public keypair for the UTXO sender offset key. Note that \( k_{Oi} \) should be treated as a nonce.</td></tr>
<tr><td>\( (k_{Si}, K_{Si}) \)</td><td>The private - public keypair for the script key. The script, \( \script_i \) resolves to \( K_S \) after completing execution.</td></tr>
<tr><td>\( \so_t \)</td><td>The script offset for transaction <em>t</em>, see (15)</td></tr>
<tr><td>\( C_i \)</td><td>A Pedersen commitment to a value \( v_i \), see (4)</td></tr>
<tr><td>\( \input_i \)</td><td>The serialised input for script \( \script_i \)</td></tr>
<tr><td>\( \pi_i \)</td><td>The covenant for UTXO <em>i</em>.</td></tr>
<tr><td>\( \varphi_i \)</td><td>The encrypted value for UTXO <em>i</em>.</td></tr>
<tr><td>\( \vartheta_i \)</td><td>The minimum value promise for UTXO <em>i</em>.</td></tr>
<tr><td>\( s_{Si} \)</td><td>A script signature for output \( i \), see (11 - 13). Additionally, the capital letter subscripts, <em>C</em> and <em>P</em> refer to the <em>ephemeral commitment</em> and <em>ephemeral public key</em> portions respectively (example \( s_{SCi}, s_{SPi} \)) .</td></tr>
<tr><td>\( s_{Mi} \)</td><td>A metadata signature for output \( i \), see (3 - 10). Additional the capital letter subscripts, <em>R</em> and <em>S</em> refer to a UTXO <em>receiver</em> and <em>sender</em> respectively (exmple \( s_{MRi}, s_{MSi} \)) .</td></tr>
</tbody></table>
</div>
<h2 id="credits"><a class="header" href="#credits">Credits</a></h2>
<ul>
<li><a href="https://github.com/CjS77">@CjS77</a></li>
<li><a href="https://github.com/hansieodendaal">@hansieodendaal</a></li>
<li><a href="https://github.com/philipr-za">@philipr-za</a> </li>
<li><a href="https://github.com/SWvheerden">@SWvheerden</a></li>
</ul>
<p>Thanks to David Burkett for proposing a method to prevent cut-through and willingness to discuss ideas.</p>
<h1 id="change-log-14"><a class="header" href="#change-log-14">Change log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 Aug 2020</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">11 Feb 2021</td><td style="text-align: left">Major update</td><td style="text-align: left">CjS77, SWvheerden, philipr-za</td></tr>
<tr><td style="text-align: left">26 Apr 2021</td><td style="text-align: left">Clarify one sided payment rules</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">31 May 2021</td><td style="text-align: left">Including full script in transaction outputs</td><td style="text-align: left">philipr-za</td></tr>
<tr><td style="text-align: left">04 Jun 2021</td><td style="text-align: left">Remove beta range-proof calculation</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">22 Jun 2021</td><td style="text-align: left">Change script_signature type to ComSig</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">30 Jun 2021</td><td style="text-align: left">Clarify Tari Script nomenclature</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">06 Oct 2022</td><td style="text-align: left">Minor improvements in legibility</td><td style="text-align: left">stringhandler</td></tr>
<tr><td style="text-align: left">11 Nov 2022</td><td style="text-align: left">Update ComAndPubSig and move out examples</td><td style="text-align: left">stringhandler</td></tr>
<tr><td style="text-align: left">22 Nov 2022</td><td style="text-align: left">Added <code>metadata_signature</code> and <code>script_signature</code> math</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">06 Apr 2023</td><td style="text-align: left">Grammar and spelling changes</td><td style="text-align: left">SWvheerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0202tariscriptopcodes"><a class="header" href="#rfc-0202tariscriptopcodes">RFC-0202/TariScriptOpcodes</a></h1>
<h2 id="tariscript-opcodes"><a class="header" href="#tariscript-opcodes">TariScript Opcodes</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-17"><a class="header" href="#licence-17">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2020 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-19"><a class="header" href="#language-19">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-19"><a class="header" href="#disclaimer-19">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-19"><a class="header" href="#goals-19">Goals</a></h2>
<p>This Request for Comment (RFC) defines the opcodes that make up the TariScript scripting language and provides some 
examples and applicaitons.</p>
<h2 id="related-requests-for-comment-16"><a class="header" href="#related-requests-for-comment-16">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="BaseLayerExtensions.html">RFC-0200: Base Layer Extensions</a></li>
</ul>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<h2 id="tariscript-semantics"><a class="header" href="#tariscript-semantics">TariScript semantics</a></h2>
<p>The proposal for TariScript is straightforward. It is based on Bitcoin script and inherits most of its ideas.</p>
<p>The main properties of <a href="Glossary.html#tariscript">TariScript</a> are</p>
<ul>
<li>The scripting language is stack-based. At redeem time, the UTXO spender must supply an input stack. The script runs by
operating on the stack contents.</li>
<li>If an error occurs during execution, the script fails.</li>
<li>After the script completes, it is successful if and only if it has not aborted, and there is exactly a single element
on the stack. The script fails if the stack is empty, or contains more than one element, or aborts early.</li>
<li>It is not Turing complete, so there are no loops or timing functions.</li>
<li>The opcodes enforce type safety. e.g. A public key cannot be added to an integer scalar. Errors of this kind MUST 
cause the script to fail. The Rust implementation of <a href="Glossary.html#tariscript">TariScript</a> automatically applies the type safety rules.</li>
</ul>
<h3 id="failure-modes"><a class="header" href="#failure-modes">Failure modes</a></h3>
<p>Bitcoin transactions can &quot;fail&quot; in two main ways: Either there is a genuine error in the locking or unlocking script;
or a wallet broadcasts a <em><a href="https://www.frontiersin.org/articles/10.3389/fbloc.2019.00007/full">Non-standard transaction</a></em> to a non-mining node. To be more precise, Bitcoin core nodes
only accept a small subset of valid transaction scripts that are deemed <a href="https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch05.html">Standard transactions</a>. To succesfully produce
a non-standard Bitcoin transaction, one has to submit it directly to a miner that accepts non-standard transactions.</p>
<p>It's interesting to note that only 0.02% of transactions
mined in Bitcoin before block 550,000 were non-standard, and it appears that the vast majority of these were in fact
unintentional, leading to loss of funds (see <a href="https://www.frontiersin.org/articles/10.3389/fbloc.2019.00007/full">Non-standard transaction</a>).</p>
<p>The present RFC proposes that TariScript not identify a subset of transactions as &quot;standard&quot;. However, some transactions
might be invalid in and of- themselves (e.g. invalid signature, invalid script), while others may be invalid because of
the execution context (e.g. a lock time has not expired).</p>
<p>All Tari nodes MUST reject the former type of invalid transaction; and SHOULD reject the latter. In these instances, it
is the <em>wallets'</em> responsibility to wait until transactions are valid before broadcasting them.</p>
<p>Rejected transactions are simply silently dropped.</p>
<p>This policy discourages spamming on the network and promotes responsible behaviour by wallets.</p>
<p>The full list of <a href="RFC-0202_TariScriptOpcodes.html#error-codes">Error codes</a> is given below.</p>
<h3 id="constraints"><a class="header" href="#constraints">Constraints</a></h3>
<ul>
<li>The maximum length of a script when serialised is 1,024 bytes.</li>
<li>The maximum length of a script's input is 1,024 bytes.</li>
<li>The maximum stack height is 255.</li>
</ul>
<h3 id="opcode-versions"><a class="header" href="#opcode-versions">Opcode versions</a></h3>
<p>Base layer core consensus constants are linked to block height for each network, be it testnet, stagenet or mainnet, 
and are backwards compatible, meaning a base node running updated consensus constants will also be able to validate the 
blockchain for the previous version up to its last effective block height.</p>
<p>Opcode versioning is contained within the consensus constants and is used to determine which opcodes are effective 
from which block height. As an example, <code>OpcodeVersion::V0</code> could be effective from the genesis block, 
<code>OpcodeVersion::V1</code> may contain two additional opcodes and could be effective from height 1234, whereas 
<code>OpcodeVersion::V2</code> may deprecate three other opcodes and be effective from height 21743.</p>
<h2 id="opcodes"><a class="header" href="#opcodes">Opcodes</a></h2>
<p><a href="Glossary.html#tariscript">TariScript</a> opcodes range from 0 to 255 and are represented as a single unsigned byte. The opcode set is
limited to allow for the applications specified in this RFC, but can be expanded in the future.</p>
<h3 id="block-height-checks"><a class="header" href="#block-height-checks">Block height checks</a></h3>
<p>All these opcodes test the current block height (or, if running the script as part of a transaction
validation, the next earliest block height) against a given value.</p>
<h5 id="checkheightverifyheight"><a class="header" href="#checkheightverifyheight">CheckHeightVerify(height)</a></h5>
<p>Pops the top of the stack as <code>height</code>. Compare the current block height to <code>height</code>. </p>
<ul>
<li>Fails with <code>IncompatibleTypes</code> if u64 is not a valid 64-bit unsigned integer. </li>
<li>Fails with <code>VerifyFailed</code> if the block height &lt; <code>height</code>.</li>
</ul>
<h5 id="checkheightheight"><a class="header" href="#checkheightheight">CheckHeight(height)</a></h5>
<p>Pops the top of the stack as <code>height</code>. Pushes the value of (the current tip height - <code>height</code>) to the stack. In
other words, the top of the stack will hold the height difference between <code>height</code> and the current height.
If the chain has progressed beyond <code>height</code>, the value is positive; and negative if the chain has yet to
reach <code>height</code>. </p>
<ul>
<li>Fails with <code>IncompatibleTypes</code> if u64 is not a valid 64-bit unsigned integer. </li>
<li>Fails with <code>StackOverflow</code> if the stack would exceed the max stack height.</li>
</ul>
<h5 id="compareheightverify"><a class="header" href="#compareheightverify">CompareHeightVerify</a></h5>
<p>Pops the top of the stack as <code>height</code> and compares it to the current block height. </p>
<ul>
<li>Fails with <code>InvalidInput</code> if there is not a valid integer value on top of the stack. </li>
<li>Fails with <code>StackUnderflow</code> if the stack is empty.</li>
<li>Fails with <code>VerifyFailed</code> if the block height &lt; <code>height</code>.</li>
</ul>
<h5 id="compareheight"><a class="header" href="#compareheight">CompareHeight</a></h5>
<p>Pops the top of the stack as <code>height</code>, then pushes the value of (<code>height</code> - the current height) to the stack.
In other words, this opcode replaces the top of the stack with the difference between <code>height</code> and the
current height. </p>
<ul>
<li>Fails with <code>InvalidInput</code> if there is not a valid integer value on top of the stack. </li>
<li>Fails with <code>StackUnderflow</code> if the stack is empty.</li>
</ul>
<h3 id="stack-manipulation"><a class="header" href="#stack-manipulation">Stack manipulation</a></h3>
<h5 id="noop"><a class="header" href="#noop">NoOp</a></h5>
<p>No op. Does nothing. Never fails.</p>
<h5 id="pushzero"><a class="header" href="#pushzero">PushZero</a></h5>
<p>Pushes a zero onto the stack. This is a very common opcode and has the same effect as <code>PushInt(0)</code> but is more
compact. <code>PushZero</code> can also be interpreted as <code>PushFalse</code>, although no such opcode exists. </p>
<ul>
<li>Fails with <code>StackOverflow</code> if the stack would exceed the max stack height.</li>
</ul>
<h5 id="pushone"><a class="header" href="#pushone">PushOne</a></h5>
<p>Pushes a one onto the stack. This is a very common opcode and has the same effect as <code>PushInt(1)</code> but is more
compact. <code>PushOne</code> can also be interpreted as <code>PushTrue</code>, although no such opcode exists. </p>
<ul>
<li>Fails with <code>StackOverflow</code> if the stack would exceed the max stack height.</li>
</ul>
<h5 id="pushhashhashvalue"><a class="header" href="#pushhashhashvalue">PushHash(HashValue)</a></h5>
<p>Pushes the associated 32-byte value onto the stack. </p>
<ul>
<li>Fails with <code>IncompatibleTypes</code> if HashValue is not a valid 32 byte sequence. </li>
<li>Fails with <code>StackOverflow</code> if the stack would exceed the max stack height.</li>
</ul>
<h5 id="pushintval"><a class="header" href="#pushintval">PushInt(val)</a></h5>
<p>Pushes the associated 64-bit signed integer (<code>val</code>) onto the stack. </p>
<ul>
<li>Fails with <code>IncompatibleTypes</code> if <code>val</code> is not a valid 64-bit signed integer. </li>
<li>Fails with <code>StackOverflow</code> if the stack would exceed the max stack height.</li>
</ul>
<h5 id="pushpubkeypublickey"><a class="header" href="#pushpubkeypublickey">PushPubKey(PublicKey)</a></h5>
<p>Pushes the associated 32-byte value onto the stack. It will be interpreted as a public key or a commitment.</p>
<ul>
<li>Fails with <code>IncompatibleTypes</code> if PublicKey is not a valid 32 byte RistrettoPublicKey sequence. </li>
<li>Fails with <code>StackOverflow</code> if the stack would exceed the max stack height.</li>
</ul>
<h5 id="drop"><a class="header" href="#drop">Drop</a></h5>
<p>Drops the top stack item. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty.</li>
</ul>
<h5 id="dup"><a class="header" href="#dup">Dup</a></h5>
<p>Duplicates the top stack item. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>StackOverflow</code> if the stack would exceed the max stack height.</li>
</ul>
<h5 id="revrot"><a class="header" href="#revrot">RevRot</a></h5>
<p>Reverse rotation. The top stack item moves into 3rd place, e.g. abc =&gt; bca. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than three items.</li>
</ul>
<h3 id="math-operations"><a class="header" href="#math-operations">Math operations</a></h3>
<h4 id="gezero"><a class="header" href="#gezero">GeZero</a></h4>
<p>Pops the top stack element as <code>val</code>. If <code>val</code> is greater than or equal to zero, push a 1 to the stack,
otherwise push 0. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>InvalidInput</code> if <code>val</code> is not an integer.</li>
</ul>
<h4 id="gtzero"><a class="header" href="#gtzero">GtZero</a></h4>
<p>Pops the top stack element as <code>val</code>. If <code>val</code> is strictly greater than zero, push a 1 to the stack, otherwise push 0. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>InvalidInput</code> if the item is not an integer.</li>
</ul>
<h4 id="lezero"><a class="header" href="#lezero">LeZero</a></h4>
<p>Pops the top stack element as <code>val</code>. If <code>val</code> is less than or equal to zero, push a 1 to the stack, otherwise push 0. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>InvalidInput</code> if the item is not an integer.</li>
</ul>
<h4 id="ltzero"><a class="header" href="#ltzero">LtZero</a></h4>
<p>Pops the top stack element as <code>val</code>. If <code>val</code> is strictly less than zero, push a 1 to the stack, otherwise push 0. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>InvalidInput</code> if the items is not an integer.</li>
</ul>
<h5 id="add"><a class="header" href="#add">Add</a></h5>
<p>Pops two items from the stack and pushes their sum to the stack. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than two items. </li>
<li>Fails with <code>InvalidInput</code> if the items cannot be added to each other (e.g. an integer and public key).</li>
</ul>
<h5 id="sub"><a class="header" href="#sub">Sub</a></h5>
<p>Pops two items from the stack and pushes the second minus the top to the stack. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than two items. </li>
<li>Fails with <code>InvalidInput</code> if the items cannot be subtracted from each other (e.g. an integer and public key).</li>
</ul>
<h5 id="equal"><a class="header" href="#equal">Equal</a></h5>
<p>Pops the top two items from the stack, and pushes 1 to the stack if the inputs are exactly equal, 0 otherwise.
A 0 is also pushed if the values cannot be compared (e.g. integer and pubkey). </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than two items.</li>
</ul>
<h5 id="equalverify"><a class="header" href="#equalverify">EqualVerify</a></h5>
<p>Pops the top two items from the stack, and compares their values. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than two items. </li>
<li>Fails with <code>VerifyFailed</code> if the top two stack elements are not equal.</li>
</ul>
<h3 id="boolean-logic"><a class="header" href="#boolean-logic">Boolean logic</a></h3>
<h4 id="orn"><a class="header" href="#orn">Or(n)</a></h4>
<p>Pops <code>n</code> + 1 items from the stack. If the last item matches at least one of the first <code>n</code>
items, push 1 onto the stack, otherwise push 0 onto the stack. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than <code>n</code> + 1 items. </li>
<li>Fails with <code>InvalidInput</code> if <code>n</code> is not a valid 8-bit unsigned integer.</li>
</ul>
<h4 id="orverifyn"><a class="header" href="#orverifyn">OrVerify(n)</a></h4>
<p>Pops <code>n</code> + 1 items from the stack. If the last item matches at least one of the first n items,
continue. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than <code>n</code> + 1 items. </li>
<li>Fails with <code>VerifyFailed</code> the last item does not match at least one of the first <code>n</code> items. </li>
<li>Fails with <code>InvalidInput</code> if <code>n</code> is not a valid 8-bit unsigned integer.</li>
</ul>
<h3 id="cryptographic-operations"><a class="header" href="#cryptographic-operations">Cryptographic operations</a></h3>
<h5 id="hashblake256"><a class="header" href="#hashblake256">HashBlake256</a></h5>
<p>Pops the top element, hash it with the Blake256 hash function and push the result to the stack. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>InvalidInput</code> if the input is not a valid 32 byte hash value.</li>
</ul>
<h5 id="hashsha256"><a class="header" href="#hashsha256">HashSha256</a></h5>
<p>Pops the top element, hash it with the SHA256 hash function and push the result to the stack. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>InvalidInput</code> if the input is not a valid 32 byte hash value.</li>
</ul>
<h5 id="hashsha3"><a class="header" href="#hashsha3">HashSha3</a></h5>
<p>Pops the top element, hash it with the SHA-3 hash function and push the result to the stack. </p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty. </li>
<li>Fails with <code>InvalidInput</code> if the input is not a valid 32 byte hash value.</li>
</ul>
<h5 id="checksigmessage"><a class="header" href="#checksigmessage">CheckSig(Message)</a></h5>
<p>Pops the public key and then the signature from the stack. If signature validation using the 32-byte message
and public key succeeds , push 1 to the stack, otherwise push 0. </p>
<ul>
<li>Fails with <code>IncompatibleTypes</code> if Message is not a valid 32-byte sequence. </li>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than 2 items. </li>
<li>Fails with <code>InvalidInput</code> if the top stack element is not a PublicKey. </li>
<li>Fails with <code>InvalidInput</code> if the second stack element is not a Signature.</li>
</ul>
<h5 id="checksigverifymessage"><a class="header" href="#checksigverifymessage">CheckSigVerify(Message)</a></h5>
<p>Identical to <a href="RFC-0202_TariScriptOpcodes.html#checksigmsg"><code>CheckSig</code></a>, except that nothing is pushed to the stack if the signature is valid.</p>
<p>In addition to the failures mentioned:</p>
<ul>
<li>Fails with <code>VerifyFailed</code> if the signature is invalid.</li>
</ul>
<h5 id="checkmultisigm-n-vec-message"><a class="header" href="#checkmultisigm-n-vec-message">CheckMultiSig(m, n, Vec<PublicKey>, Message)</a></h5>
<p>Pops exactly <code>m</code> signatures from the stack. The multiple signature validation will not succeed if the <code>m</code>
signatures are not unique or if Vec<RistrettoPublicKey> contains a duplicate public key. Each signature is
validated using the 32-byte message and a public key that match. If signature validation for m unique
signatures succeeds, push 1 to the stack, otherwise push 0.</p>
<ul>
<li>Fails with <code>IncompatibleTypes</code> if either <code>m</code> or <code>n</code> is not a valid 8-bit unsigned integer, if Vec<RistrettoPublicKey> 
contains an invalid public key or if Message is not a valid 32-byte sequence.</li>
<li>Fails with <code>ValueExceedsBounds</code> if <code>m</code> == 0 or if <code>n</code> == 0 or if <code>m</code> &gt; <code>n</code> or if <code>n</code> &gt; <code>MAX_MULTISIG_LIMIT</code>
(32) or if the number of public keys provided != <code>n</code>.</li>
<li>Fails with <code>StackUnderflow</code> if the stack has fewer than m items.</li>
<li>Fails with <code>IncompatibleTypes</code> if any of the m signatures from the stack is not a valid signature.</li>
<li>Fails with <code>InvalidInput</code> if each of the top m elements is not a Signature.</li>
</ul>
<h5 id="checkmultisigverifym-n-vec-message"><a class="header" href="#checkmultisigverifym-n-vec-message">CheckMultiSigVerify(m, n, Vec<PublicKey>, Message)</a></h5>
<p>Identical to <a href="RFC-0202_TariScriptOpcodes.html#checkmultisigm-n-public-keys-msg"><code>CheckMultiSig</code></a>, except that nothing is pushed to the stack if the 
multiple signature validation is either valid or invalid. </p>
<p>In addition to the failures mentioned:</p>
<ul>
<li>Fails with <code>VerifyFailed</code> if any signature is invalid.</li>
</ul>
<h5 id="checkmultisigverifyaggregatepubkeym-n-public-keys-msg"><a class="header" href="#checkmultisigverifyaggregatepubkeym-n-public-keys-msg">CheckMultiSigVerifyAggregatePubKey(m, n, public keys, Msg)</a></h5>
<p>Identical to <a href="RFC-0202_TariScriptOpcodes.html#checkmultisigm-n-public-keys-msg"><code>CheckMultiSig</code></a>, except that the aggregate of the public keys is 
pushed to the stack if multiple signature validation succeeds. </p>
<p>In addition to the failures mentioned:</p>
<ul>
<li>Fails with <code>VerifyFailed</code> if any signature is invalid.</li>
</ul>
<h5 id="toristrettopoint"><a class="header" href="#toristrettopoint">ToRistrettoPoint</a></h5>
<p>Pops the top element from the stack (either a scalar or a hash), parses it canonically as a Ristretto secret key if possible, computes the corresponding Ristretto public key, and pushes this value to the stack.</p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty.</li>
<li>Fails with <code>IncompatibleTypes</code> if the stack item is not either a scalar or a hash.</li>
<li>Fails with <code>InvalidInput</code> if the stack item cannot be canonically parsed as a Ristretto secret key.</li>
</ul>
<h3 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h3>
<h5 id="return"><a class="header" href="#return">Return</a></h5>
<p>This opcode does nothing except that it always fails.</p>
<ul>
<li>Fails with <code>Return</code>.</li>
</ul>
<h5 id="if-then-else"><a class="header" href="#if-then-else">If-then-else</a></h5>
<p>Pops the top element of the stack into <code>pred</code>. If <code>pred</code> is 1, the instructions between <code>IfThen</code> and <code>Else</code> are
executed. If <code>pred</code> is 0, instructions are popped until <code>Else</code> or <code>EndIf</code> is encountered. If <code>Else</code> is
encountered, instructions are executed until <code>EndIf</code> is reached. <code>EndIf</code> is a marker opcode and a no-op.</p>
<ul>
<li>Fails with <code>StackUnderflow</code> if the stack is empty.</li>
<li>Fails with <code>InvalidInput</code> if pred is anything other than 0 or 1.</li>
<li>Fails with the corresponding failure code if any instruction during execution of the clause causes a failure.</li>
</ul>
<h5 id="else"><a class="header" href="#else">Else</a></h5>
<p>Marks the beginning of the <code>Else</code> branch.</p>
<h5 id="endif"><a class="header" href="#endif">EndIf</a></h5>
<p>Marks the end of the <code>IfThen</code> statement.</p>
<h2 id="serialisation-1"><a class="header" href="#serialisation-1">Serialisation</a></h2>
<p>TariScript and the execution stack are serialised into byte strings using a simple linear parser. Since all opcodes are
a single byte, it's very easy to read and write script byte strings. If an opcode has a parameter associated with it,
e.g. <code>PushHash</code> then it is equally known how many bytes following the opcode will contain the parameter.</p>
<p>The script input data is serialised in an analogous manner. The first byte in a stream indicates the type of data in the
bytes that follow. The length of each type is fixed and known <em>a priori</em>. The next <em>n</em> bytes read represent the data type.</p>
<p>As input data elements are read in, they are pushed onto the stack. This means that the <em>last</em> input element will 
typically be operated on <em>first</em>!</p>
<p>The types of input parameters that are accepted are:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Range / Value</th></tr></thead><tbody>
<tr><td style="text-align: left">Number</td><td style="text-align: left">64-bit signed integer</td></tr>
<tr><td style="text-align: left">Hash</td><td style="text-align: left">32-byte hash value</td></tr>
<tr><td style="text-align: left">Scalar</td><td style="text-align: left">32-byte scalar value</td></tr>
<tr><td style="text-align: left">Commitment</td><td style="text-align: left">32-byte homomorphic commitment (Pedersen commitment )</td></tr>
<tr><td style="text-align: left">PublicKey</td><td style="text-align: left">32-byte Ristretto public key</td></tr>
<tr><td style="text-align: left">Signature</td><td style="text-align: left">64-byte Ristretto Schnorr signature (32-byte nonce + 32-byte signature)</td></tr>
</tbody></table>
</div>
<h2 id="example-scripts"><a class="header" href="#example-scripts">Example scripts</a></h2>
<h3 id="anyone-can-spend"><a class="header" href="#anyone-can-spend">Anyone can spend</a></h3>
<p>The simplest script is an empty script, or a script with a single <code>NoOp</code> opcode. When faced with this script, the 
spender can supply any pubkey in her script input for which she knows the private key. The script will execute, leaving 
that public key as the result, and the transaction script validation will pass.</p>
<h3 id="one-sided-transactions"><a class="header" href="#one-sided-transactions">One-sided transactions</a></h3>
<p>One-sided transactions lock the input to a predetermined public key provided by the recipient; essentially the same
method that Bitcoin uses. The simplest form of this is to simply post the new owner's public key as the script:</p>
<pre><code class="language-text">PushPubkey(P_B)
</code></pre>
<p>To spend this output, Bob provides an empty input stack. After execution, the stack contains his public key.</p>
<p>An equivalent script to Bitcoin's P2PKH would be:</p>
<pre><code class="language-text">Dup HashBlake256 PushHash(PKH) EqualVerify
</code></pre>
<p>To spend this, Bob provides his public key as script input.
To illustrate the execution process, we show the script running on the left, and resulting stack on the right:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Initial script</th><th style="text-align: left">Initial Stack</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Dup</code></td><td style="text-align: left">Bob's Pubkey</td></tr>
<tr><td style="text-align: left"><code>HashBlake256</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>PushHash(PKH)</code></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><code>EqualVerify</code></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>Copy Bob's pubkey:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><code>Dup</code></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>HashBlake256</code></td><td style="text-align: left">Bob's Pubkey</td></tr>
<tr><td style="text-align: left"><code>PushHash(PKH)</code></td><td style="text-align: left">Bob's Pubkey</td></tr>
<tr><td style="text-align: left"><code>EqualVerify</code></td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<p>Hash the public key:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><code>HashBlake256</code></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>PushHash(PKH)</code></td><td style="text-align: left">H(Bob's Pubkey)</td></tr>
<tr><td style="text-align: left"><code>EqualVerify</code></td><td style="text-align: left">Bob's Pubkey</td></tr>
</tbody></table>
</div>
<p>Push the expected hash to the stack:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><code>PushHash(PKH)</code></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>EqualVerify</code></td><td style="text-align: left">PKH</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">H(Bob's Pubkey)</td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left">Bob's Pubkey</td></tr>
</tbody></table>
</div>
<p>Is <code>PKH</code> equal to the hash of Bob's public key?</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><code>EqualVerify</code></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"></td><td style="text-align: left">Bob's Pubkey</td></tr>
</tbody></table>
</div>
<p>The script has completed without errors, and Bob's public key remains on the stack.</p>
<h3 id="multiparty-time-locked-contract"><a class="header" href="#multiparty-time-locked-contract">Multiparty Time-locked contract</a></h3>
<p>Alice sends some Tari to Bob. If he doesn't spend it within a certain timeframe (up till block 4000), then she is also
able to spend it back to herself.</p>
<p>The spender provides their public key as input to the script.</p>
<pre><code class="language-text">Dup PushPubkey(P_b) CheckHeight(4000) GeZero IFTHEN PushPubkey(P_a) OrVerify(2) ELSE EqualVerify ENDIF
</code></pre>
<p>Let's run through this script assuming it's block 3990 and Bob is spending the UTXO. We'll only print the stack this
time:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Initial Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>Dup</code>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>PushPubkey(P_b)</code>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>CheckHeight(4000)</code>. The block height is 3990, so <code>3990 - 4000</code> is pushed to the stack:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">-10</td></tr>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>GeZero</code> pushes a 1 if the top stack element is positive or zero:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>IFTHEN</code> compares the top of the stack to 1. It is not a match, so it will execute the <code>ELSE</code> branch:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>EqualVerify</code> checks that <code>P_b</code> is equal to Bob's pubkey:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">Bob's pubkey</td></tr>
</tbody></table>
</div>
<p>The <code>ENDIF</code> is a no-op, so the stack contains Bob's public key, meaning Bob must sign to spend this transaction.</p>
<p>Similarly, if it is after block 4000, say block 4005, and Alice or Bob tries to spend the UTXO, the sequence is:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Initial Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>Dup</code> and <code>PushPubkey(P_b)</code> as before:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>CheckHeight(4000)</code> calculates <code>4005 - 4000)</code> and pushes 5 to the stack:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">5</td></tr>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>GeZero</code> pops the 5 and pushes a 1 to the stack:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
</tbody></table>
</div>
<p>The top of the stack is 1, so <code>IFTHEN</code> executes the first branch, <code>PushPubkey(P_a)</code>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>P_a</code></td></tr>
<tr><td style="text-align: left"><code>P_b</code></td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
</tbody></table>
</div>
<p><code>OrVerify(2)</code> compares the 3rd element, Alice's pubkey, with the 2 top items that were popped. There is a match, so the 
script continues.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Stack</th></tr></thead><tbody>
<tr><td style="text-align: left">Alice or Bob's pubkey</td></tr>
</tbody></table>
</div>
<p>If the script executes successfully, then either Alice's or Bob's public key is left on the stack, meaning only Alice
or Bob can spend the output.</p>
<h3 id="error-codes"><a class="header" href="#error-codes">Error codes</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Code</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>Return</code></td><td style="text-align: left">The script failed with an explicit Return</td></tr>
<tr><td style="text-align: left"><code>StackOverflow</code></td><td style="text-align: left">The stack exceeded 255 elements during script execution</td></tr>
<tr><td style="text-align: left"><code>NonUnitLengthStack</code></td><td style="text-align: left">The script completed execution with a stack size other than one</td></tr>
<tr><td style="text-align: left"><code>StackUnderflow</code></td><td style="text-align: left">Tried to pop an element off an empty stack</td></tr>
<tr><td style="text-align: left"><code>IncompatibleTypes</code></td><td style="text-align: left">An operand was applied to incompatible types</td></tr>
<tr><td style="text-align: left"><code>ValueExceedsBounds</code></td><td style="text-align: left">A script opcode resulted in a value that exceeded the maximum or minimum value</td></tr>
<tr><td style="text-align: left"><code>InvalidOpcode</code></td><td style="text-align: left">The script encountered an invalid opcode</td></tr>
<tr><td style="text-align: left"><code>MissingOpcode</code></td><td style="text-align: left">The script is missing closing opcodes (Else or EndIf)</td></tr>
<tr><td style="text-align: left"><code>InvalidSignature</code></td><td style="text-align: left">The script contained an invalid signature</td></tr>
<tr><td style="text-align: left"><code>InvalidInput</code></td><td style="text-align: left">The serialised stack contained invalid input</td></tr>
<tr><td style="text-align: left"><code>InvalidData</code></td><td style="text-align: left">The script contained invalid data</td></tr>
<tr><td style="text-align: left"><code>VerifyFailed</code></td><td style="text-align: left">A verification opcode failed, aborting the script immediately</td></tr>
<tr><td style="text-align: left"><code>InvalidDigest</code></td><td style="text-align: left"><code>as_hash</code> requires a Digest function that returns at least 32 bytes</td></tr>
</tbody></table>
</div>
<h3 id="credits-1"><a class="header" href="#credits-1">Credits</a></h3>
<p>Thanks to <a href="https://github.com/philipr-za">@philipr-za</a> and <a href="https://github.com/SWvheerden">@SWvheerden</a> for their input
and contributions to this RFC.</p>
<h1 id="change-log-15"><a class="header" href="#change-log-15">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 Aug 2020</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">11 Feb 2021</td><td style="text-align: left">Tari script proposal v3</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">16 Feb 2021</td><td style="text-align: left">Update TariScript OpCodes</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">08 Mar 2021</td><td style="text-align: left">Update RFC docs</td><td style="text-align: left">delta1</td></tr>
<tr><td style="text-align: left">12 Nov 2021</td><td style="text-align: left">Add CheckMultiSig/Verify</td><td style="text-align: left">delta1</td></tr>
<tr><td style="text-align: left">30 Jun 2021</td><td style="text-align: left">Add missing OP_CHECKMULTISIG/VERIFY and update error codes</td><td style="text-align: left">sdbondi</td></tr>
<tr><td style="text-align: left">11 Jan 2022</td><td style="text-align: left">Add ToRistrettoPoint opcode to TariScript</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">27 Sep 2022</td><td style="text-align: left">Add aggregate signatures to transaction inputs and outputs</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">28 Sep 2022</td><td style="text-align: left">Minor update to reflect implementation</td><td style="text-align: left">sdbondi</td></tr>
<tr><td style="text-align: left">11 Nov 2022</td><td style="text-align: left">Update for code review/audit</td><td style="text-align: left">hansieodendaal</td></tr>
<tr><td style="text-align: left">20 Nov 2023</td><td style="text-align: left">Update <code>ToRistrettoPoint</code> documentation</td><td style="text-align: left">AaronFeickert</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0204tariscriptexamples"><a class="header" href="#rfc-0204tariscriptexamples">RFC-0204/TariScriptExamples</a></h1>
<p>$$
\newcommand{\script}{\alpha} % utxo script
\newcommand{\input}{ \theta }
\newcommand{\cat}{\Vert}
\newcommand{\so}{\gamma} % script offset
\newcommand{\hash}[1]{\mathrm{H}\bigl({#1}\bigr)}
$$</p>
<h2 id="tariscript-examples"><a class="header" href="#tariscript-examples">TariScript Examples</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-18"><a class="header" href="#licence-18">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2020 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-20"><a class="header" href="#language-20">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-20"><a class="header" href="#disclaimer-20">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="tariscript-examples-1"><a class="header" href="#tariscript-examples-1">TariScript Examples</a></h2>
<h3 id="standard-mw-transaction"><a class="header" href="#standard-mw-transaction">Standard MW transaction</a></h3>
<p>For this use case we have Alice who sends Bob some Tari.
Bob's wallet is  online and is able to countersign the transaction.</p>
<p>Alice creates a new transaction spending \( C_a \) to a new output containing the commitment \( C_b \) (ignoring 
fees for now).</p>
<p>To spend \( C_a \), she provides:</p>
<ul>
<li>An input that contains \( C_a \).</li>
<li>The script input, \( \input_a \).</li>
<li>A valid script signature, \( s_{Si} \) as per (13),(14) proving that she owns the commitment 
\( C_a \), knows the private key, \( k_{Sa} \), corresponding to \( K_{Sa} \), the public key left on the stack 
after executing \( \script_a \) with \( \input_a \).</li>
<li>A sender offset public key, \( K_{Ob} \).</li>
<li>The sender portion of the public nonce, \( R_{MSi} )\, as per (10).</li>
<li>The script offset, \( \so\) with:
$$
\begin{aligned}
\so  = k_{Sa} - k_{Ob}
\end{aligned}
\tag{20}
$$</li>
</ul>
<p>Alice sends the usual first round data to Bob, but now because of TariScript also includes \( K_{Ob} \) and 
\( R_{MSi} \). Bob can then complete his side of the transaction as per the [standard Mimblewimble protocol] 
providing the commitment \(C_b\), its public blinding factor, its rangeproof and the partial transaction signature.
In addition, Bob also needs to provide a partial metadata signature as per (5) where he commits to all the transaction 
output metadata with a commitment signature. Because Alice is creating the transaction, she can suggest the script 
\( \script_b \) to use for Bob's output, similar to a [bitcoin transaction], but Bob can choose a different script 
\(\script_b\). However, in most cases the parties will agree on using something akin to a <code>NOP</code> script 
\(\script_b\). Bob has to return this consistent set of information back to Alice.</p>
<p>Alice verifies the information received back from Bob, check if she agrees with the script \( \script_b \) Bob signed, 
and calculates her portion of the <a href="Glossary.html#metadata-signature">metadata signature</a> \( s_{Mb} \) with: </p>
<p>$$
\begin{aligned}
s_{Mb} = r_{mb} + k_{Ob} \hash{ \script_b \cat F_b \cat R_{Mb} }
\end{aligned}
\tag{21}
$$</p>
<p>Alice then constructs the final aggregated metadata signature \(s_{Mb}\) as per (12) and replaces Bob's partial 
metadata signature in Bob's TransactionOutput.</p>
<p>She completes the transaction as per [standard Mimblewimble protocol] and also adds the script offset \( \so \), after 
which she sends the final transaction to Bob and broadcasts it to the network.</p>
<h4 id="transaction-validation"><a class="header" href="#transaction-validation">Transaction validation</a></h4>
<p>Base nodes validate the transaction as follows:</p>
<ul>
<li>They check that the usual Mimblewimble balance holds by summing inputs and outputs and validating against the excess
signature. This check does not change nor do the other validation rules, such as confirming that all inputs are in
the UTXO set etc.</li>
<li>The metadata signature \(s_{Ma}\) on Bob's output,</li>
<li>The input script must execute successfully using the provided input data; and the script result must be a valid 
public key,</li>
<li>The script signature on Alice's input is valid by checking:</li>
</ul>
<p>$$
\begin{aligned}
a_{Sa} \cdot H + b_{Sa} \cdot G = R_{Sa} + (C_a + K_{Sa})* \hash{ R_{Sa} \cat \alpha_a \cat \input_a \cat K_{Sa} \cat C_a}
\end{aligned}
\tag{22}
$$</p>
<ul>
<li>The script offset is verified by checking that the balance holds:</li>
</ul>
<p>$$
\begin{aligned}
\so \cdot{G} = K_{Sa} - K_{Ob}
\end{aligned}
\tag{23}
$$</p>
<p>Finally, when Bob spends this output, he will use \( K_{Sb} \) as his script input and sign it with his script 
private key \( k_{Sb} \). He will choose a new sender offset public key \( K_{Oc} \) to give to the recipient, and 
he will construct the script offset, \( \so_b \) as follows:</p>
<p>$$
\begin{aligned}
\so_b = k_{Sb} - k_{Oc}
\end{aligned}
\tag{24}
$$</p>
<h3 id="one-sided-payment"><a class="header" href="#one-sided-payment">One sided payment</a></h3>
<p>In this example, Alice pays Bob, who is not available to countersign the transaction, so Alice initiates a one-sided 
payment,</p>
<p>$$
C_a \Rightarrow  C_b
$$</p>
<p>Once again, transaction fees are ignored to simplify the illustration.</p>
<p>Alice owns \( C_a \) and provides the required script to spend the UTXO as was described in the previous cases.</p>
<p>Alice needs a public key from Bob, \( K_{Sb} \) to complete the one-sided transaction. This key can be obtained
out-of-band, and might typically be Bob's wallet public key on the Tari network.</p>
<p>Bob requires the value \( v_b \) and blinding factor \( k_b \) to claim his payment, but he needs to be able to 
claim it without asking Alice for them.</p>
<p>This information can be obtained by using Diffie-Hellman and Bulletproof rewinding. If the blinding factor \( k_b \) 
was calculated with Diffie-Hellman using the sender offset keypair, (\( k_{Ob} \),\( K_{Ob} \)) as the sender 
keypair and the script keypair, \( (k_{Sb} \),\( K_{Sb}) \) as the receiver keypair, the blinding factor 
\( k_b \) can be securely calculated without communication.</p>
<p>Alice uses Bob's public key to create a shared secret, \( k_b \) for the output commitment, \( C_b \), using
Diffie-Hellman key exchange.</p>
<p>Alice calculates \( k_b \) as</p>
<p>$$
\begin{aligned}
k_b = k_{Ob} * K_{Sb}
\end{aligned}
\tag{25}
$$</p>
<p>Next Alice uses Bulletproof rewinding, see <a href="RFCD-0180_BulletproofRewinding.html">RFC 180</a>, to encrypt the value 
\( v_b \) into the the Bulletproof for the commitment \( C_b \). For this she uses 
\( k_{rewind} =  \hash{k_{b}} \) as the rewind_key and \( k_{blinding} =  \hash{\hash{k_{b}}} \) as the blinding 
key.</p>
<p>Alice knows the script-redeeming private key \( k_{Sa}\) for the transaction input.</p>
<p>Alice will create the entire transaction, including generating a new sender offset keypair and calculating the 
script offset,</p>
<p>$$
\begin{aligned}
\so = k_{Sa} - k_{Ob}
\end{aligned}
\tag{26}
$$</p>
<p>She also provides a script that locks the output to Bob's public key, <code>PushPubkey(K_Sb)</code>.
This will only be spendable if the spender can provide a valid signature as input that demonstrates proof
of knowledge of \( k_{Sb}\) as well as the value and blinding factor of the output \(C_b\). Although Alice knowns 
the value and blinding factor of the output \(C_b\) only Bob knows \( k_{Sb}\).</p>
<p>Any base node can now verify that the transaction is complete, verify the signature on the script, and verify the 
script offset.</p>
<p>For Bob to claim his commitment he will scan the blockchain for a known script because he knowns that the script will 
be <code>PushPubkey(K_Sb)</code>. In this case, the script is analogous to an address in Bitcoin or Monero. Bob's wallet can scan 
the blockchain looking for scripts that he would know how to resolve.</p>
<p>When Bob's wallet spots a known script, he requires the blinding factor, \( k_b \) and the value \( v_b \). First he 
uses Diffie-Hellman to calculate \( k_b \). </p>
<p>Bob calculates \( k_b \) as</p>
<p>$$
\begin{aligned}
k_b = K_{Ob} * k_{Sb}
\end{aligned}
\tag{27}
$$</p>
<p>Next Bob's wallet calculates \( k_{rewind} \), using \( k_{rewind} = \hash{k_{b}}\) and 
(\( k_{blinding} = \hash{\hash{k_{b}}} \), using those to rewind the Bulletproof to get the value \( v_b \). </p>
<p>Because Bob's wallet already knowns the script private key \( k_{Sb} \), he now knows all the values required to 
spend the commitment \( C_b \)</p>
<p>For Bob's part, when he discovers one-sided payments to himself, he should spend them to new outputs using a traditional
transaction to thwart any potential horizon attacks in the future.</p>
<p>To summarise, the information required for one-sided transactions are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Transaction input</th><th>Symbols</th><th>Knowledge</th></tr></thead><tbody>
<tr><td>commitment</td><td>\( C_a = k_a \cdot G + v \cdot H \)</td><td>Alice knows the blinding factor and value.</td></tr>
<tr><td>features</td><td>\( F_a \)</td><td>Public</td></tr>
<tr><td>script</td><td>\( \alpha_a \)</td><td>Public</td></tr>
<tr><td>script input</td><td>\( \input_a \)</td><td>Public</td></tr>
<tr><td>script signature</td><td>\( s_{Sa} \)</td><td>Alice knows \( k_{Sa},\, r_{Sa} \) and \( k_{a},\, v_{a} \) of the commitment \(C_a\).</td></tr>
<tr><td>sender offset public key</td><td>\( K_{Oa} \)</td><td>Not used in this transaction.</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Transaction output</th><th>Symbols</th><th>Knowledge</th></tr></thead><tbody>
<tr><td>commitment</td><td>\( C_b = k_b \cdot G + v \cdot H \)</td><td>Alice and Bob know the blinding factor and value.</td></tr>
<tr><td>features</td><td>\( F_b \)</td><td>Public</td></tr>
<tr><td>script</td><td>\( \script_b \)</td><td>Script is public; only Bob knows the correct script input.</td></tr>
<tr><td>range proof</td><td></td><td>Alice and Bob know opening parameters.</td></tr>
<tr><td>sender offset public key</td><td>\( K_{Ob} \)</td><td>Alice knows \( k_{Ob} \).</td></tr>
<tr><td>metadata signature</td><td>\( s_{Mb} \)</td><td>Alice knows \( k_{Ob} \), \( (k_{b},\, v) \) and the metadata.</td></tr>
</tbody></table>
</div>
<h3 id="htlc-like-script"><a class="header" href="#htlc-like-script">HTLC-like script</a></h3>
<p>In this use case we have a script that controls where it can be spent. The script is out of scope for this example, but
has the following rules:</p>
<ul>
<li>Alice can spend the UTXO unilaterally after block <em>n</em>, <strong>or</strong></li>
<li>Alice and Bob can spend it together.</li>
</ul>
<p>This would be typically what a lightning-type channel requires.</p>
<p>Alice owns the commitment \( C_a \). She and Bob work together to create \( C_s\). But we don't yet know who can 
spend the newly created \( C_s\) and under what conditions this will be.</p>
<p>$$
C_a \Rightarrow  C_s \Rightarrow  C_x
$$</p>
<p>Alice owns \( C_a\), so she knows the blinding factor \( k_a\) and the correct input for the script's spending 
conditions. Alice also generates the sender offset keypair, \( (k_{Os}, K_{Os} )\).</p>
<p>Now Alice and Bob proceed with the standard transaction flow.</p>
<p>Alice ensures that the sender offset public key \( K_{Os}\) is part of the output metadata that contains commitment 
\( C_s\). Alice will fill in the script with her \( k_{Sa}\) to unlock the commitment \( C_a\). Because Alice 
owns \( C_a\) she needs to construct \( \so\) with:</p>
<p>$$
\begin{aligned}
\so = k_{Sa} - k_{Os}
\end{aligned}
\tag{28}
$$</p>
<p>The blinding factor, \( k_s\) can be generated using a Diffie-Hellman construction. The commitment \( C_s\) needs to 
be constructed with the script that Bob agrees on. Until it is mined, Alice could modify the script via double-spend and 
thus Bob must wait until the transaction is confirmed before accepting the conditions of the smart contract between 
Alice and himself.</p>
<p>Once the UTXO is mined, both Alice and Bob possess all the knowledge required to spend the \( C_s \) UTXO. It's only
the conditions of the script that will discriminate between the two.</p>
<p>The spending case of either Alice or Bob claiming the commitment \( C_s\) follows the same flow described in the 
previous examples, with the sender proving knowledge of \( k_{Ss}\) and &quot;unlocking&quot; the spending script.</p>
<p>The case of Alice and Bob spending \( C_s \) together to a new multiparty commitment requires some elaboration.</p>
<p>Assume that Alice and Bob want to spend  \( C_s \) co-operatively. This involves the script being executed in such a 
way that the resulting public key on the stack is the sum of Alice and Bob's individual script keys, \( k_{SsA} \) and 
\( k_{SaB} \).</p>
<p>The script input needs to be signed by this aggregate key, and so Alice and Bob must each supply a partial signature 
following the usual Schnorr aggregate mechanics, but one person needs to add in the signature of the blinding factor and 
value.</p>
<p>In an analogous fashion, Alice and Bob also generate an aggregate sender offset private key \( k_{Ox}\), each using
their own \( k_{OxA} \) and \( k_{OxB}\).</p>
<p>To be specific, Alice calculates her portion from</p>
<p>$$
\begin{aligned}
\so_A = k_{SsA} - k_{OxA}
\end{aligned}
\tag{29}
$$</p>
<p>Bob will construct his part of the \( \so\) with:</p>
<p>$$
\begin{aligned}
\so_B = k_{SsB} - k_{OxB}
\end{aligned}
\tag{30}
$$</p>
<p>And the aggregate \( \so\) is then:</p>
<p>$$
\begin{aligned}
\so = \so_A + \so_B
\end{aligned}
\tag{31}
$$</p>
<p>Notice that in this case, both \( K_{Ss} \) and \( K_{Ox}\) are aggregate keys.</p>
<p>Notice also that because the script resolves to an aggregate key \( K_s\) neither Alice nor Bob can claim the 
commitment \( C_s\) without the other party's key. If either party tries to cheat by editing the input, the script 
validation will fail.</p>
<p>If either party tries to cheat by creating a new output, the script offset will not validate correctly as it locks 
the output of the transaction.</p>
<p>A base node validating the transaction will also not be able to tell this is an aggregate transaction as all keys are 
aggregated Schnorr signatures. But it will be able to validate that the script input is correctly signed, thus the 
output public key is correct and that the \( \so\) is correctly calculated, meaning that the commitment \( C_x\) is 
the correct UTXO for the transaction.</p>
<p>To summarise, the information required for creating a multiparty UTXO is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Transaction input</th><th>Symbols</th><th>Knowledge</th></tr></thead><tbody>
<tr><td>commitment</td><td>\( C_a = k_a \cdot G + v \cdot H \)</td><td>Alice knows the blinding factor and value.</td></tr>
<tr><td>features</td><td>\( F_a \)</td><td>Public</td></tr>
<tr><td>script</td><td>\( \alpha_a \)</td><td>Public</td></tr>
<tr><td>script input</td><td>\( \input_a \)</td><td>Public</td></tr>
<tr><td>script signature</td><td>\( s_{Sa} \)</td><td>Alice knows \( k_{Sa},\, r_{Sa} \) and \( k_{a},\, v_{a} \) of the commitment \(C_a\).</td></tr>
<tr><td>sender offset public key</td><td>\( K_{Oa} \)</td><td>Not used in this transaction.</td></tr>
</tbody></table>
</div><br>
<div class="table-wrapper"><table><thead><tr><th>Transaction output</th><th>Symbols</th><th>Knowledge</th></tr></thead><tbody>
<tr><td>commitment</td><td>\( C_s = k_s \cdot G + v \cdot H \)</td><td>Alice and Bob know the blinding factor and value.</td></tr>
<tr><td>features</td><td>\( F_s \)</td><td>Public</td></tr>
<tr><td>script</td><td>\( \script_s \)</td><td>Script is public; Alice and Bob only knows their part of the  correct script input.</td></tr>
<tr><td>range proof</td><td></td><td>Alice and Bob know opening parameters.</td></tr>
<tr><td>sender offset public key</td><td>\( K_{Os} = K_{OsA} + K_{OsB}\)</td><td>Alice knows \( k_{OsA} \), Bob knows \( k_{OsB} \), neither party knows \( k_{Os} \).</td></tr>
<tr><td>metadata signature</td><td>\( (a_{Ms} , b_{Ms} , R_{Ms}) \)</td><td>Alice knows \( k_{OsA} \), Bob knows \( k_{OsB} \), both parties know \( (k_{s},\, v) \). Neither party knows \( k_{Os}\).</td></tr>
</tbody></table>
</div>
<p>When spending the multi-party input:</p>
<div class="table-wrapper"><table><thead><tr><th>Transaction input</th><th>Symbols</th><th>Knowledge</th></tr></thead><tbody>
<tr><td>commitment</td><td>\( C_s = k_s \cdot G + v_s \cdot H \)</td><td>Alice and Bob know the blinding factor and value.</td></tr>
<tr><td>features</td><td>\( F_s \)</td><td>Public</td></tr>
<tr><td>script</td><td>\( \alpha_s \)</td><td>Public</td></tr>
<tr><td>script input</td><td>\( \input_s \)</td><td>Public</td></tr>
<tr><td>script signature</td><td>\( (a_{Ss} ,b_{Ss} , R_{Ss}) \)</td><td>Alice knows \( (k_{SsA},\, r_{SsA}) \), Bob knows \( (k_{SsB},\, r_{SsB}) \), both parties know \( (k_{s},\, v_{s}) \), neither party knows \( k_{Ss}\).</td></tr>
<tr><td>sender offset public key</td><td>\( K_{Os} \)</td><td>As above, Alice and Bob each know part of the sender offset key.</td></tr>
</tbody></table>
</div>
<h3 id="multi-party-considerations"><a class="header" href="#multi-party-considerations">Multi-party considerations</a></h3>
<p>Multi-party in this context refers to <code>n-of-n</code> parties creating a single combined transaction output and <code>m-of-n</code> 
parties spending a single combined transaction input. We have some options to do this:</p>
<ul>
<li>using the <a href="RFC-0202_TariScriptOpcodes.html#checkmultisigverifyaggregatepubkeym-n-public-keys-msg">m-of-n script</a> TariScript without sharding the spending key;</li>
<li>combination of the <a href="RFC-0202_TariScriptOpcodes.html#checkmultisigverifyaggregatepubkeym-n-public-keys-msg">m-of-n script</a> TariScript and sharding the spending key;</li>
<li>sharding the spending key combined with the <a href="RFC-0202_TariScriptOpcodes.html#noop">NoOp script</a> TariScript;</li>
</ul>
<p>If the spending key \( k_i \) is sharded for any of these options the commitment definition changes to:</p>
<p>$$
\begin{aligned}
C_i = v_i \cdot H  + \sum_\psi (k_{i_\psi} \cdot G) \; \; \; \text{ for each receiver party } \psi
\end{aligned}
\tag{1b}
$$</p>
<p>The sender-receiver interaction can be categorized as follows, however, for simplicity we can assume that each
multi-party side will have a single party acting as the dealer:</p>
<ul>
<li>Multi-party senders can create the single output and send it to a single receiver.</li>
<li>A single sender can create the single output and send it to multi-party receivers.</li>
<li>Multi-party senders can create the single output and send it to multi-party receivers.</li>
</ul>
<p>The multi-party impact on the transaction output, transaction input and script offset is discussed below.</p>
<h4 id="multi-party-transaction-output"><a class="header" href="#multi-party-transaction-output">Multi-party transaction output</a></h4>
<p>If multiple senders and receiver parties need to create an aggregate <code>metadata_signature</code> for a single multi-party
transaction output, there are two secrets that warrant our attention; the script offset private key \( k_{Oi} \)
controlled by the senders and the spending key \( k_i \) controlled by the receivers. Depending on the protocol
design, one or both secrets may be sharded amongst all parties. </p>
<p><u>Sharding the script offset private key:</u></p>
<p>If the script offset private key \( k_{Oi} \) is sharded, the aggregate sender terms in (10) and (11) collected by 
the sender's dealer change to:</p>
<p>$$
\begin{aligned}
R_{MSi} &amp;= \sum_\omega (r_{{MSi_b}_\omega} \cdot G) \; \; \; \text{ for each sender party } \omega
\end{aligned}
\tag{10b}
$$</p>
<p>$$
\begin{aligned}
a_{MSi} &amp;= 0 \\
b_{MSi} &amp;= \sum_\omega (r_{{MSi_b}_\omega} + e \cdot k_{{Oi}_\omega}) \; \; \; \text{ for each sender party } \omega
\end{aligned}
\tag{11b}
$$</p>
<p><u>Sharding the spending key:</u></p>
<p>If the spending key \( k_i \) is sharded, the receiver's dealer needs to collect shards and combine them. The
aggregate receiver terms in (3) and (5) collected by the receiver's dealer change to:</p>
<p>$$
\begin{aligned}
R_{MRi} &amp;= r_{MRi_a} \cdot H + \sum_\psi ( r_{{MRi_b}_\psi} \cdot G ) \; \; \; \text{ for each receiver party } \psi
\end{aligned}
\tag{3b}
$$</p>
<p>$$
\begin{aligned}
a_{MRi} &amp;= r_{MRi_a} + e(v_{i}) \\
b_{MRi} &amp;= \sum_\psi ( r_{{MRi_b}_\psi} + e \cdot k_{i_\psi} ) \; \; \; \text{ for each receiver party } \psi
\end{aligned}
\tag{5b}
$$</p>
<h4 id="multi-party-transaction-input"><a class="header" href="#multi-party-transaction-input">Multi-party transaction input</a></h4>
<p>If multiple senders need to create an aggregate <code>script_signature</code> for a multi-party transaction input, again, there are
two secrets that warrant our attention, the script private key \( k_{Si} \) and the spending key \( k_i \).
Depending on the protocol design, one or both secrets may be sharded amongst all parties, with some limitations:</p>
<ul>
<li>Sharding the script private key will always be applicable for an <a href="RFC-0202_TariScriptOpcodes.html#checkmultisigverifyaggregatepubkeym-n-public-keys-msg">m-of-n script</a> TariScript.</li>
<li>Sharding the script private key will never be applicable for a <a href="RFC-0202_TariScriptOpcodes.html#noop">NoOp script</a> TariScript.</li>
</ul>
<p><u>Sharding only the script private key:</u></p>
<p>If only the script private key \( k_{Si} \) will be sharded the aggregate terms in (14) collected by the sender's 
dealer change to:</p>
<p>$$
\begin{aligned}
R_{Si} &amp;= r_{Si_a} \cdot H + \sum_\omega ( r_{{Si_b}_\omega} \cdot G ) \; \; \; \text{ for each sender party } \omega \\
a_{Si}  &amp;= r_{Si_a} +  e(v_{i}) \\
b_{Si} &amp;= \sum_\omega ( r_{{Si_b}_\omega} + e \cdot k_{{Si}_\omega} ) + e \cdot  k_i \; \; \; \text{ for each sender party } \omega \\
e &amp;= \hash{ R_{Si} \cat \alpha_i \cat \input_i \cat K_{Si} \cat C_i} \\
\end{aligned}
\tag{14b}
$$</p>
<p><u>Sharding the script private key and the spending key:</u></p>
<p>If both the script private key \( k_{Si} \) and the spending key \( k_i \) will be sharded the aggregate terms
in (14) collected by the sender's dealer change to:</p>
<p>$$
\begin{aligned}
R_{Si} &amp;= r_{Si_a} \cdot H + \sum_\omega ( r_{{Si_b}_\omega} \cdot G ) \; \; \; \text{ for each sender party } \omega \\
a_{Si}  &amp;= r_{Si_a} +  e(v_{i}) \\
b_{Si} &amp;= \sum_\omega ( r_{{Si_b}_\omega} + e \cdot (k_{{Si}_\omega} +  k_{i_\omega}) ) \; \; \; \text{ for each sender party } \omega \\
e &amp;= \hash{ R_{Si} \cat \alpha_i \cat \input_i \cat K_{Si} \cat C_i} \\
\end{aligned}
\tag{14c}
$$</p>
<p>It is worth noting that <code>m-of-n</code> treatment of the script private key \( k_{Si} \) and the spending key \( k_i \)
differs slightly. Only <code>m</code> of the original <code>n</code> parties need to create the script input, and the script will resolve to
the correct \( K_{Si} \), but all <code>n</code> parties need to be present to recreate the original \( k_i \). This can be
done with Pedersen Verifiable Secret Sharing (PVSS), similar to
<a href="https://tlu.tarilabs.com/protocols/mimblewimble-mb-bp-utxo#mimblewimble--mtext-of-n--multiparty-bulletproof-utxo"><strong>this example</strong></a>.
The dealer will reconstruct the \( k_{i_j} \) shards of the missing parties and add them to their shard before
combining.</p>
<p><u>Sharding only the spending key:</u></p>
<p>If only the spending key \( k_i \) will be sharded the aggregate terms in (14) collected by the sender's dealer 
change to:</p>
<p>$$
\begin{aligned}
R_{Si} &amp;= r_{Si_a} \cdot H + \sum_\omega ( r_{{Si_b}_\omega} \cdot G ) \; \; \; \text{ for each sender party } \omega \\
a_{Si}  &amp;= r_{Si_a} +  e(v_{i}) \\
b_{Si} &amp;= \sum_\omega ( r_{{Si_b}_\omega} + e \cdot  k_{i_\omega} ) + e \cdot k_{Si} \; \; \; \text{ for each sender party } \omega \\
e &amp;= \hash{ R_{Si} \cat \alpha_i \cat \input_i \cat K_{Si} \cat C_i} \\
\end{aligned}
\tag{14d}
$$</p>
<h4 id="multi-party-script-offset"><a class="header" href="#multi-party-script-offset">Multi-party script offset</a></h4>
<p>For multiple senders, aggregate terms are collected by the sender's dealer and (16) changes according to which of the
secrets have been sharded:</p>
<p><u>Sharding only the script private key:</u></p>
<p>$$
\begin{aligned}
\so = \sum_\omega \left( \sum_j\mathrm{k_{Sj}} \right) _\omega - \sum_i\mathrm{k_{Oi}} \; \; \text{for each input}, j,\, \text{and each output}, i \; \text{ for each sender party } \omega
\end{aligned}
\tag{16b}
$$</p>
<p><u>Sharding only the script offset private key:</u></p>
<p>$$
\begin{aligned}
\so = \sum_j\mathrm{k_{Sj}} - \sum_\omega \left( \sum_i\mathrm{k_{Oi}} \right) _\omega \; \; \text{for each input}, j,\, \text{and each output}, i \; \text{ for each sender party } \omega
\end{aligned}
\tag{16c}
$$</p>
<p><u>Sharding the script private key and the script offset private key:</u></p>
<p>$$
\begin{aligned}
\so = \sum_\omega \left( \sum_j\mathrm{k_{Sj}} - \sum_i\mathrm{k_{Oi}} \right) _\omega \; \; \text{for each input}, j,\, \text{and each output}, i \; \text{ for each sender party } \omega
\end{aligned}
\tag{16d}
$$</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">11 Nov 2022</td><td style="text-align: left">Move out of RFC 0201</td><td style="text-align: left">stringhandler</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0203stealth-addresses"><a class="header" href="#rfc-0203stealth-addresses">RFC-0203/Stealth addresses</a></h1>
<h2 id="stealth-addresses"><a class="header" href="#stealth-addresses">Stealth addresses</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-19"><a class="header" href="#licence-19">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-21"><a class="header" href="#language-21">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-21"><a class="header" href="#disclaimer-21">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-20"><a class="header" href="#goals-20">Goals</a></h2>
<p>This Request for Comment (RFC) presents a design for a one-time (stealth) address protocol useful for one-sided payments
to improve recipient privacy for payments on the Tari base layer.</p>
<h2 id="related-requests-for-comment-17"><a class="header" href="#related-requests-for-comment-17">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
</ul>
<h2 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h2>
<p>The Tari protocol extends the <a href="./Glossary.html#mimblewimble">Mimblewimble</a> protocol to include scripting in the form of <a href="./Glossary.html#tariscript">TariScript</a>. One of the 
first features implemented using <a href="./Glossary.html#tariscript">TariScript</a> was <a href="./RFC-0201_TariScript.html#one-sided-payment">one-sided payments</a>. These are payments to a recipient that do not 
require an interactive negotiation in the same way a standard <a href="./Glossary.html#mimblewimble">Mimblewimble</a> transaction does. One of the main downsides
of the current implementation of <a href="./RFC-0201_TariScript.html#one-sided-payment">one-sided payments</a> is that the script key used is the public key of the recipient's 
wallet. This public key is embedded in the <a href="./Glossary.html#tariscript">TariScript</a> of the <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a> created by the sender. The issue is that it becomes
very easy for a third party to scan the blockchain to look for one-sided transaction outputs being sent to a given wallet. 
In order to alleviate this privacy leak, this RFC proposes the use of one-time (stealth) addresses to be used as the script
key when sending a one-sided payment.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Stealth addresses were first proposed on the Bitcoin Talk forum by user <a href="https://bitcointalk.org/index.php?topic=5965.0">Bytecoin</a>. The concept was further refined by
<a href="https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03613.html">Peter Todd</a>, using a design similar to the <a href="https://en.bitcoin.it/wiki/BIP_0032">BIP-32</a> style of address generation. In this approach, the sender can use an
ephemeral public key (derived from a nonce) to perform a non-interactive Diffie-Hellman exchange with the recipient's
public key, and use this to derive a one-time public key to which only the recipient can derive the corresponding private
key. This reduces on-chain linkability (but, importantly, does not eliminate it).</p>
<p>The approach was further extended in the <a href="https://cryptonote.org/whitepaper.pdf">CryptoNote</a> whitepaper to support a dual-key design, whereby a separate scanning
key is also used in the one-time address construction; this enables identification of outputs, but requires the spending
key to derive the private key required to spend the output.</p>
<p>It is important to note that while one-time addresses are not algebraically linkable, it is possible to observe transactions
that consume multiple such outputs and infer common ownership of them.</p>
<p>For use in Tari, single-key one-time addresses are supported.</p>
<h2 id="one-time-stealth-addresses"><a class="header" href="#one-time-stealth-addresses">One-time (stealth) addresses</a></h2>
<p>Single-key one-time stealth addresses require only that a recipient possess a private key \( a \) and corresponding public
key \( A = a \cdot G \), and distribute the public key out of band to receive <a href="./RFC-0201_TariScript.html#one-sided-payment">one-sided payments</a> in a non-interactive
manner.</p>
<p>The protocol that a sender will use to make a payment to the recipient is as follows:</p>
<ol>
<li>Generate a random nonce \( r \) and use it to produce an ephemeral public key \( R = r \cdot G \).</li>
<li>Compute a Diffie-Hellman exchange to obtain the shared secret \( c = H( r \cdot A ) \), where \( H \) is a cryptographic
hash function.</li>
<li>Include \( K_S = c \cdot G + A \) as the last public key in a <a href="./RFC-0201_TariScript.html#one-sided-payment">one-sided payment</a> script in a transaction.</li>
<li>Include \( R \) in the script for use by the recipient, but <code>DROP</code> it so that it is not used in script execution.
This changes the script for a <a href="./RFC-0201_TariScript.html#one-sided-payment">one-sided payment</a> from <code>PushPubkey(K_S)</code> to <code>PushPubkey(R) Drop PushPubkey(K_S)</code>.</li>
</ol>
<p>To identify <a href="./RFC-0201_TariScript.html#one-sided-payment">one-sided payments</a>, the recipient scans the blockchain for outputs containing a <a href="./RFC-0201_TariScript.html#one-sided-payment">one-sided payment</a> script. It
then does the following to test for ownership:</p>
<ol>
<li>Extract the ephemeral public key \( R \) from the script.</li>
<li>Compute a Diffie-Hellman exchange to obtain the shared secret \( c = H( a \cdot R ) \).</li>
<li>Compute \( K_S' = c \cdot G + A \).
If \( K_S' = K_S \) is included in the script, the recipient can produce the required script signature using the corresponding
one-time private key \( c + a \).</li>
</ol>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation notes</a></h2>
<ul>
<li>Stealth addresses were included in the Tari Console Wallet as of version v0.35.0 (2022-08-11).</li>
<li>The FFI (used in Aurora) uses stealth addresses by default as of libwallet-v0.35.0 (2022-08-11).</li>
</ul>
<h1 id="change-log-16"><a class="header" href="#change-log-16">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">01 Jun 2022</td><td style="text-align: left">First draft</td><td style="text-align: left">philip-za</td></tr>
<tr><td style="text-align: left">26 Oct 2022</td><td style="text-align: left">Stabilise RFC</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0205hardware-transactions"><a class="header" href="#rfc-0205hardware-transactions">RFC-0205/Hardware transactions</a></h1>
<h2 id="hardware-transactions"><a class="header" href="#hardware-transactions">Hardware transactions</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/swvheerden">SW van Heerden</a></p>
<h1 id="licence-20"><a class="header" href="#licence-20">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2023 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-22"><a class="header" href="#language-22">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-22"><a class="header" href="#disclaimer-22">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-21"><a class="header" href="#goals-21">Goals</a></h2>
<p>This Request for Comment (RFC) presents a design for a hardware wallet with MimbleWimble</p>
<h2 id="related-requests-for-comment-18"><a class="header" href="#related-requests-for-comment-18">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="RFC-0203_StealthAddress.html">RFC-0203: Stealth Address</a></li>
</ul>
<h2 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h2>
<p>Hardware wallets are secure physical devices used to protect crypto assets and funds by requiring user interaction from the device.
These devices are used to sign for transactions by keeping all the secrets from the transactions on the hardware device. If
the host machines that run the wallets are compromised by malware the secrets from the transactions are still safe as they are not
kept on the machine as with regular wallets. The devices are very low power and only feature a very limited processing power. MimbleWimble 
has intensive crypto operations that are in some instances very slow or not able to run on the hardware wallet at all. This RFC describes a way to 
get around these limitations to have fully functional secure hardware wallet integration. </p>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<p>Vanilla <a href="./Glossary.html#mimblewimble">Mimblewimble</a> only has a single secret per <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>, the blinding factor (\( k_i \) ). The Tari protocol extends the <a href="./Glossary.html#mimblewimble">Mimblewimble</a> protocol to include scripting in the form of <a href="./Glossary.html#tariscript">TariScript</a>. This adds a second secret per <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a> called the script_key (\( k_s \) ). In practical terms this means that while vanilla <a href="./Glossary.html#mimblewimble">Mimblewimble</a> only requires that a wallet wishing to spend an <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>, prove knowledge of (\( k_i \) ) by producing the kernel signature, this is not sufficient for Tari. A Tari wallet must also prove knowledge of the script key (\( k_s \) ), by producing the script signature. </p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>To properly implement hardware wallets we need the following requirements to be met:</p>
<ul>
<li>No UTXO can be spent without a user physically approving the transaction on the hardware wallet.</li>
<li>Users need to verify transaction properties when signing for transactions.</li>
<li>The user must be able to receive transactions without having to authorize them on the hardware wallet.</li>
<li>The user must be able to receive transactions without having the Hardware wallet attached.</li>
<li>The hardware device implementation should comply with the best practices and/or security recommendations of the provider.</li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="entities"><a class="header" href="#entities">Entities</a></h3>
<p>Normal transactions have only a single entity, the wallet which controls all secrets and transactions. But with hardware wallets, we need to define two distinct entities:</p>
<ul>
<li>Signer: This is the entity that keeps the secrets for the transactions and approves them, aka the hardware wallet.</li>
<li>Helper: This entity is the program that helps the signer construct the transaction, send it over the network and scan the network, aka wallet.</li>
</ul>
<h3 id="process-overview"><a class="header" href="#process-overview">Process Overview</a></h3>
<p>By splitting the ownership of the <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>'s secrets by assigning knowledge of only the script key (\( k_s \) ) to the signer, we can lift much of the heavy cryptography like bulletproof creation to the helper device by exposing (\( k_i \) ) to it. By looking at how <a href="./RFC-0203_StealthAddresses.html">one-sided-stealth</a> transactions are created, we can construct the script key in such a way that the helper can calculate the public script key, but cannot calculate the private script key.</p>
<p>All hardware wallet created <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>s will contain a script <code>PushPubkey(K_S)</code>. The key (\( k_s \) ) is created as follows:
$$
\begin{align}
k_S &amp;= H(k_i) + a \\
K_S &amp;= H(k_i) \cdot G + A
\end{align}
$$</p>
<p>The blinding factor (\( k_i \) ) is used as a random nonce when creating the script key. This means the helper can create the public key without the signer present, and the signer can then at a later stage create the private key from the nonce. The key pair (\( a, A \) ) is the master key pair from the signer. The private key (\( a \) ) is kept secret by the signer at all times.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>Adding a hardware wallet to a wallet (helper) we need to ensure that all keys are only derived from a single seed phrase provided by the hardware wallet. </p>
<p>Helper asks signer for master helper key (\( k_H \) ). 
This key is derived from the signer seed phrase.</p>
<h3 id="transaction-receiving"><a class="header" href="#transaction-receiving">Transaction receiving</a></h3>
<p>When a transaction is received the helper constructs the new <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a> with its Rangeproof. Choosing a new ( \( k_i \) ) for the <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>, it calculates a new \( K_S \). It attaches the script <code>PushPubkey(K_S)</code> to output.</p>
<h3 id="transaction-sending"><a class="header" href="#transaction-sending">Transaction sending</a></h3>
<p>When the user wants to send a transaction, the helper retrieves the desired <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>. The helper asks the signer to sign the transaction. 
The signer calculates \( k_s \) to sign the transaction. 
The signer creates a random nonce \( k_O \) to use for the script_offset. It produces the metadata signature with \( k_O \), and supplies the script_offset to the helper. 
The helper can attach the correct signatures to the <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>s and ship the transaction.</p>
<h3 id="receiving-normal-one-sided-transaction"><a class="header" href="#receiving-normal-one-sided-transaction">Receiving normal one-sided transaction</a></h3>
<p>This can be done by the helper asking the signer for a public key. And advertising this public key as the destination public key for a 1-sided transaction. 
The helper can scan the blockchain for this public key. </p>
<h3 id="receiving-one-sided-stealth"><a class="header" href="#receiving-one-sided-stealth">Receiving one-sided-stealth</a></h3>
<p>Not yet possible with this this design.</p>
<h3 id="output-recovery"><a class="header" href="#output-recovery">Output recovery</a></h3>
<p>When creating outputs the wallet encrypts the blinding factor \(k_i \) and value \( v \) with \( k_H \). This is encrypted using extended-nonce AEAD using a random nonce and authenticated decryption.
Because the key \( k_H \)  is calculated from the seed phrase of the signer, this will be the same each time. The helper can try to decrypt each scanned output, when it is successful it knows it has found its own output. 
The helper can validate that the commitment is correct using the blinding factor \(k_i \) and value \( v \). It can also validate (\( K_S)\) corresponds to (\( k_i, A \) )</p>
<h2 id="security"><a class="header" href="#security">Security</a></h2>
<p>Because the script key is required for spending, it is the only key that needs to be kept secret. 
The following table explains what an attacker can do upon learning a key from the helper</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">key</th><th style="text-align: left">Worst case scenario</th></tr></thead><tbody>
<tr><td style="text-align: left">\( k_H \)</td><td style="text-align: left">Can view all transactions and values made by the wallet</td></tr>
<tr><td style="text-align: left">\( k_i \)</td><td style="text-align: left">Can try and brute force the value of the transaction</td></tr>
</tbody></table>
</div>
<p>The keys ( \( a, k_S, k_O \) ) are only known to the signer, and should never leave the hardware wallet.</p>
<h1 id="change-log-17"><a class="header" href="#change-log-17">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 May 2023</td><td style="text-align: left">First draft</td><td style="text-align: left">swvheerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0250covenants"><a class="header" href="#rfc-0250covenants">RFC-0250/Covenants</a></h1>
<h2 id="covenants"><a class="header" href="#covenants">Covenants</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-21"><a class="header" href="#licence-21">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-23"><a class="header" href="#language-23">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-23"><a class="header" href="#disclaimer-23">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-22"><a class="header" href="#goals-22">Goals</a></h2>
<p>This Request for Comment (RFC) presents a proposal for introducing <em>covenants</em> into the Tari base layer protocol. Tari
Covenants aims to provide restrictions on the <em>future</em> spending of subsequent transactions to enable a number of powerful
use-cases, such as</p>
<ul>
<li><a href="https://hackingdistributed.com/2016/02/26/how-to-implement-secure-bitcoin-vaults/">vaults</a></li>
<li>side-chain checkpointing transactions,</li>
<li>commission on NFT transfers, and</li>
<li>many others not thought of here.</li>
</ul>
<h2 id="related-requests-for-comment-19"><a class="header" href="#related-requests-for-comment-19">Related Requests for Comment</a></h2>
<ul>
<li><a href="BaseLayerExtensions.html">RFC-0200: Base Layer Extensions</a></li>
<li><a href="RFCD-0300_DAN.html">RFC-0300: The Tari Digital Assets Network</a></li>
</ul>
<h2 id="introduction-7"><a class="header" href="#introduction-7">Introduction</a></h2>
<p>The Tari protocol already provides programmable consensus, through <a href="./Glossary.html#tariscript">TariScript</a>, that restricts whether a <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>
may be included as an input to a transaction (a.k.a spent). The scope of information within <a href="./Glossary.html#tariscript">TariScript</a> is inherently limited,
by the <a href="./RFC-0202_TariScriptOpcodes.html">TariScript Opcodes</a> and the input data provided by a spender. Once the requirements of the script are met,
a spender may generate <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>s of their choosing, within the constraints of <a href="./Glossary.html#mimblewimble">MimbleWimble</a>.</p>
<p>This RFC expands the capabilities of Tari protocol by adding <em>additional requirements</em>, called covenants
that allow the owner(s) of a <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a> to control the composition of a <em>subsequent</em> transaction.</p>
<p>Covenants are not a new idea and have been proposed and implemented in various forms by others.</p>
<p>For example,</p>
<ul>
<li><a href="https://maltemoeser.de/paper/covenants.pdf">Bitcoin-NG covenants</a> put forward the <code>CheckOutputVerify</code> script opcode.</li>
<li><a href="https://handshake.org/files/handshake.txt">Handshake</a> has implemented covenants to add the <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a> state of their auctioning process.</li>
<li><a href="https://blockstream.com/2016/11/02/en-covenants-in-elements-alpha/">Elements Covenants</a></li>
</ul>
<h2 id="covenants-in-mimblewimble"><a class="header" href="#covenants-in-mimblewimble">Covenants in MimbleWimble</a></h2>
<p>In blockchains like Bitcoin, a block contains discrete transactions containing inputs and outputs. A covenant
in Bitcoin would be able to interrogate those outputs <em>belonging to the input</em> to ensure that they adhere to rules.</p>
<p>In <a href="./Glossary.html#mimblewimble">MimbleWimble</a>, the body of a block and transaction can be expressed in an identical data structure. This
is indeed the case in the <a href="https://github.com/tari-project/tari">Tari codebase</a>, which defines a structure called <code>AggregateBody</code> containing inputs
and outputs (and kernels) for transactions and blocks. This is innate to <a href="./Glossary.html#mimblewimble">MimbleWimble</a>, so even if we were
to put a &quot;box&quot; around these inputs/outputs there is nothing to stop someone from including inputs and
outputs from other boxes as long as balance is maintained.</p>
<p>This results in an interesting dilemma: how do we allow rules that dictate how future outputs look only armed with
the knowledge that the rule must apply to one or more outputs?</p>
<p>In this RFC, we detail a covenant scheme that allows the <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a> originator to express a <em>filter</em> that must be
satisfied for a subsequent spending transaction to be considered valid.</p>
<h2 id="assumptions-3"><a class="header" href="#assumptions-3">Assumptions</a></h2>
<p>The following assumptions are made:</p>
<ol>
<li>Duplicate commitments within a block are disallowed by consensus <em>prior</em> to covenant execution,</li>
<li>all outputs in the output set are valid, and</li>
<li>all inputs are valid spends, save for covenant checks.</li>
</ol>
<h2 id="protocol-modifications"><a class="header" href="#protocol-modifications">Protocol modifications</a></h2>
<p>Modifications to the existing protocol and consensus are as follows:</p>
<ul>
<li>the covenant is recorded in the transaction <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a>,</li>
<li>the covenant is committed to in the output and input hashes to prevent malleability,</li>
<li>transactions with covenants entering the mempool MUST be validated, and</li>
<li>each covenant in a block must be validated before being included in the block chain.</li>
</ul>
<h3 id="transaction-input-and-output-changes"><a class="header" href="#transaction-input-and-output-changes">Transaction input and output changes</a></h3>
<p>A <code>covenant</code> field would need to be added to the <code>TransactionOutput</code> and <code>TransactionInput</code> structs
and committed to in their hashes.</p>
<h3 id="covenant-definition"><a class="header" href="#covenant-definition">Covenant definition</a></h3>
<p>We define a clear notation for covenants that mirrors the <a href="https://medium.com/blockstream/miniscript-bitcoin-scripting-3aeff3853620">miniscript</a> project.</p>
<h4 id="execution-context-and-scope"><a class="header" href="#execution-context-and-scope">Execution Context and Scope</a></h4>
<p>Covenants execute within a limited read-only context and scope. This is both to reduce complexity (and therefore
the possibility of bugs) and maintain reasonable performance.</p>
<p>A covenant's context is limited to:</p>
<ul>
<li>an immutable reference to the current input,</li>
<li>a vector of immutable <em>references</em> to outputs in the current block/transaction (called the output set),</li>
<li>the current input's mined height, and</li>
<li>the current block height.</li>
</ul>
<p>Each output's covenant is executed with this context, filtering on the output set and returning the result.
The output set given to each covenant at execution MUST be the same set for all covenants and MUST never be
influenced by other covenants. The stateless and immutable nature of this scheme has the benefit of being
able to execute covenants in parallel.</p>
<p>A covenant passes if at least one output in the set is matched. Allowing more than one output to match allows for
covenants that restrict the characteristics of multiple outputs. A covenant that matches zero outputs <em>fails</em>
which invalidates the transaction/block.</p>
<p>If a covenant is empty (zero bytes) the <code>identity</code> operation is implied and therefore, no actual execution need occur.</p>
<h4 id="argument-types"><a class="header" href="#argument-types">Argument types</a></h4>
<pre><code class="language-rust ignore">enum CovenantArg {
    // byte code: 0x01
    // data size: 32 bytes
    Hash([u8; 32]),
    // byte code: 0x02
    // data size: 32 bytes
    PublicKey(RistrettoPublicKey),
    // byte code: 0x03
    // data size: 32 bytes
    Commitment(PedersonCommitment),
    // byte code: 0x04
    // data size: variable
    TariScript(TariScript),
    // byte code: 0x05
    // data size: &lt;= 4096 bytes
    Covenant(Covenant),
    // byte cide: 0x06
    // data size: variable
    Uint(u64),
    // byte cide: 0x07
    // data size: variable
    OutputField(OutputField),
    // byte cide: 0x08
    // data size: variable
    OutputFields(OutputFields),
    // byte cide: 0x09
    // data size: variable
    Bytes(Vec&lt;u8&gt;),
    // byte cide: 0x0a
    // data size: 1 bytes
    OutputType(OutputType),
}</code></pre>
<h5 id="output-field-tags"><a class="header" href="#output-field-tags">Output field tags</a></h5>
<p>Fields from each output in the output set may be brought into a covenant filter.
The available fields are defined as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Tag Name</th><th>Byte Code</th><th>Returns</th></tr></thead><tbody>
<tr><td><code>field::commitment</code></td><td>0x00</td><td>output.commitment</td></tr>
<tr><td><code>field::script</code></td><td>0x01</td><td>output.script</td></tr>
<tr><td><code>field::sender_offset_public_key</code></td><td>0x02</td><td>output.sender_offset_public_key</td></tr>
<tr><td><code>field::covenant</code></td><td>0x03</td><td>output.covenant</td></tr>
<tr><td><code>field::features</code></td><td>0x04</td><td>output.features</td></tr>
<tr><td><code>field::features_output_type</code></td><td>0x05</td><td>output.features.output_type</td></tr>
<tr><td><code>field::features_maturity</code></td><td>0x06</td><td>output.features.maturity</td></tr>
<tr><td><code>field::features_metadata</code></td><td>0x07</td><td>output.features.metadata</td></tr>
<tr><td><code>field::features_sidechain_features</code></td><td>0x08</td><td>output.features.sidechain_features</td></tr>
</tbody></table>
</div>
<p>Each field tag returns a consensus encoded byte representation of the value contained in the field.
How those bytes are interpreted depends on the covenant. For instance, <code>filter_fields_hashed_eq</code> will
concatenate the bytes and hash the result whereas <code>filter_field_eq</code> will interpret the bytes as a
little-endian 64-bit unsigned integer.</p>
<h4 id="set-operations"><a class="header" href="#set-operations">Set operations</a></h4>
<h5 id="identity"><a class="header" href="#identity">identity()</a></h5>
<p>The output set is returned unaltered. This rule is implicit for an empty (0 byte) covenant.</p>
<p>op_byte: 0x20<br>
args: []</p>
<h5 id="anda-b"><a class="header" href="#anda-b">and(A, B)</a></h5>
<p>The intersection (\(A \cap B\)) of the resulting output set for covenant rules \(A\) and \(B\).</p>
<p>op_byte: 0x21<br>
args: [Covenant, Covenant]</p>
<h5 id="ora-b"><a class="header" href="#ora-b">or(A, B)</a></h5>
<p>The union (\(A \cup B\)) of the resulting output set for covenant rules \(A\) and \(B\).</p>
<p>op_byte: 0x22<br>
args: [Covenant, Covenant]</p>
<h5 id="xora-b"><a class="header" href="#xora-b">xor(A, B)</a></h5>
<p>The symmetric difference (\(A \triangle B\)) of the resulting output set for covenant rules \(A\) and \(B\).
This is, outputs that match either \(A\) or \(B\) but not both.</p>
<p>op_byte: 0x23<br>
args: [Covenant, Covenant]</p>
<h5 id="nota"><a class="header" href="#nota">not(A)</a></h5>
<p>Returns the compliment of <code>A</code>. That is, all the elements of <code>A</code> are removed from the
resultant output set.</p>
<p>op_byte: 0x24<br>
args: [Covenant]</p>
<h4 id="filters"><a class="header" href="#filters">Filters</a></h4>
<h5 id="filter_output_hash_eqhash"><a class="header" href="#filter_output_hash_eqhash">filter_output_hash_eq(hash)</a></h5>
<p>Filters for a single output that matches the hash. This filter only returns zero or one outputs.</p>
<p>op_byte: 0x30<br>
args: [Hash]</p>
<h5 id="filter_fields_preservedfields"><a class="header" href="#filter_fields_preservedfields">filter_fields_preserved(fields)</a></h5>
<p>Filter for outputs where all given fields in the input are preserved in the output.</p>
<p>op_byte: 0x31<br>
args: [Fields]</p>
<h5 id="filter_fields_hashed_eqfields-hash"><a class="header" href="#filter_fields_hashed_eqfields-hash">filter_fields_hashed_eq(fields, hash)</a></h5>
<p>op_byte: 0x32<br>
args: [Fields, VarInt]</p>
<h5 id="filter_field_eqfield-int"><a class="header" href="#filter_field_eqfield-int">filter_field_eq(field, int)</a></h5>
<p>Filters for outputs whose field value matches the given integer value. If the given field cannot be cast
to an unsigned 64-bit integer, the transaction/block is rejected.</p>
<p>op_byte: 0x33<br>
args: [Field, VarInt]</p>
<h5 id="filter_absolute_heightheight"><a class="header" href="#filter_absolute_heightheight">filter_absolute_height(height)</a></h5>
<p>Checks the block height that the current <a href="./Glossary.html#unspent-transaction-outputs">UTXO</a> (i.e. the current input) is greater than or
equal to the <code>HEIGHT</code> block height. If so, the <code>identity()</code> is returned.</p>
<p>op_byte: 0x34<br>
args: [VarInt]</p>
<h4 id="encoding--decoding"><a class="header" href="#encoding--decoding">Encoding / Decoding</a></h4>
<p>Covenants can be encoded to/decoded from bytes as a token stream. Each token is consumed and interpreted serially
before being executed.</p>
<p>For instance,</p>
<pre><code class="language-ignore">xor(
    filter_output_hash_eq(Hash(0e0411c70df0ea4243a363fcbf161ebe6e2c1f074faf1c6a316a386823c3753c)),
    filter_relative_height(10),
)
</code></pre>
<p>is represented in hex bytes as <code>23 30 01 a8b3f48e39449e89f7ff699b3eb2b080a2479b09a600a19d8ba48d765fe5d47d 35 07 0a</code>.
Let's unpack that as follows:</p>
<pre><code class="language-ignore">23 // xor - consume two covenant args
30 // filter_output_hash_eq - consume a hash arg
01 // 32-byte hash
a8b3f48e39449e89f7ff699b3eb2b080a2479b09a600a19d8ba48d765fe5d47d // data
// end filter_output_hash_eq
35 // 2nd covenant - filter_absolute_height
07 // varint
0A // 10
// end varint, filter_absolute_height, xor
</code></pre>
<p>Some functions can take any number of arguments, such as <code>filter_fields_hashed_eq</code> which defines the <code>Fields</code> type.
This type is encoded first by its byte code <code>34</code> followed by a varint encoded number that indicates the number
of field identifiers to consume. To mitigate misuse, the maximum allowed arguments are limited.</p>
<h3 id="covenant-validation"><a class="header" href="#covenant-validation">Covenant Validation</a></h3>
<p>A covenant and therefore the block/transaction MUST be regarded as invalid if:</p>
<ol>
<li>an unrecognised bytecode is encountered</li>
<li>the end of the byte stream is reached unexpectedly</li>
<li>there are bytes remaining on the stream after interpreting</li>
<li>an invalid argument type is encountered</li>
<li>the <code>Fields</code> type encounters more than 9 arguments (i.e. the number of fields tags available)</li>
<li>the depth of the calls exceeds 16.</li>
</ol>
<h3 id="consensus-changes"><a class="header" href="#consensus-changes">Consensus changes</a></h3>
<p>The covenant is executed once all other validations, including <a href="./Glossary.html#tariscript">TariScript</a>, are complete. This ensures that
invalid transactions in a block cannot influence the results.</p>
<h2 id="considerations"><a class="header" href="#considerations">Considerations</a></h2>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<p>This introduces additional validation complexity. We avoid stacks, loops, and conditionals (covenants are basically
one conditional), there are overheads both in terms of complexity and performance as a trade-off for the
power given by covenants.</p>
<p>The worst case complexity for covenant validation is <code>O(num_inputs*num_outputs)</code>, although as mentioned above
validation for each input can be executed in parallel. To compensate for the additional workload the network
encounters, use of covenants should incur heavily-weighted fees to discourage needlessly using them.</p>
<h3 id="cut-through"><a class="header" href="#cut-through">Cut-through</a></h3>
<p>The same arguments made in the <a href="./RFC-0201_TariScript.html#cut-through">TariScript RFC</a> for the need to prevent
<a href="https://tlu.tarilabs.com/protocols/grin-protocol-overview/MainReport.html#cut-through">cut-through</a> apply to covenants.</p>
<h3 id="chain-analysis"><a class="header" href="#chain-analysis">Chain analysis</a></h3>
<p>The same arguments made in the <a href="./RFC-0201_TariScript.html#fodder-for-chain-analysis">TariScript RFC</a> apply.</p>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<p>As all outputs in a block are in the scope of an input to be checked, any unrelated/malicious output in a block
<em>could</em> pass an unrelated covenant rule if given the chance. A secure covenant is one that <em>uniquely</em> identifies
one or more outputs.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="now-or-never"><a class="header" href="#now-or-never">Now or never</a></h3>
<p>Spend by block 10 or burn</p>
<pre><code class="language-ignore">not(filter_absolute_height(10))
</code></pre>
<p>Note, this covenant may be valid when submitted to the mempool, but invalid by the time it is put in a block for
the miner.</p>
<h3 id="side-chain-checkpointing"><a class="header" href="#side-chain-checkpointing">Side-chain checkpointing</a></h3>
<pre><code class="language-ignore">and(
   filter_field_eq(field::feature_flags, 16) // SIDECHAIN CHECKPOINT = 16
   filter_fields_preserved([field::features, field::covenant, field::script])
)
</code></pre>
<h3 id="restrict-spending-to-a-particular-commitment-if-not-spent-by-block-100"><a class="header" href="#restrict-spending-to-a-particular-commitment-if-not-spent-by-block-100">Restrict spending to a particular commitment if not spent by block 100</a></h3>
<pre><code class="language-ignore">or(
   not(filter_absolute_height(100)),
   filter_fields_hashed_eq([field::commmitment], Hash(xxxx))
)
</code></pre>
<h3 id="output-must-preserve-covenant-features-and-script-or-be-burnt"><a class="header" href="#output-must-preserve-covenant-features-and-script-or-be-burnt">Output must preserve covenant, features and script or be burnt</a></h3>
<pre><code class="language-ignore">xor(
    filter_fields_preserved([field::features, field::covenant, field::script]),
    and(
        filter_field_eq(field::features_flags, 128), // FLAG_BURN = 128
        filter_fields_hashed_eq([field::commitment, field::script], Hash(...)),
    ),
)
</code></pre>
<h3 id="commission-for-nft-transfer"><a class="header" href="#commission-for-nft-transfer">Commission for NFT transfer</a></h3>
<pre><code class="language-ignore">// Must be different outputs
xor(
    and(
        // Relavant input fields preserved in subsequent output
        filter_fields_preserved([fields::features, fields::covenant, fields::script]),
        // The spender must obtain the covenent for the subsequent output
        filter_fields_hashed_eq([fields::covenant], Hash(xxxx)),
    ),
    // The spender must obtain and submit the output that matches this hash
    filter_output_hash_eq(Hash(xxxx)),
)
</code></pre>
<h3 id="other-potential-covenants"><a class="header" href="#other-potential-covenants">Other potential covenants</a></h3>
<ul>
<li><code>filter_script_eq(script)</code></li>
<li><code>filter_covenant_eq(covenant)</code></li>
<li><code>filter_script_match(&lt;pattern&gt;)</code></li>
<li><code>filter_covenant_match(&lt;pattern&gt;)</code></li>
</ul>
<h1 id="change-log-18"><a class="header" href="#change-log-18">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 Oct 2021</td><td style="text-align: left">First draft</td><td style="text-align: left">sbondi</td></tr>
<tr><td style="text-align: left">08 Oct 2022</td><td style="text-align: left">Stable update</td><td style="text-align: left">brianp</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0303danoverview"><a class="header" href="#rfc-0303danoverview">RFC-0303/DanOverview</a></h1>
<h2 id="digital-assets-network-1"><a class="header" href="#digital-assets-network-1">Digital Assets Network</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>,<a href="https://github.com/SWvheerden">S W van Heerden</a></p>
<h1 id="licence-22"><a class="header" href="#licence-22">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-24"><a class="header" href="#language-24">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-24"><a class="header" href="#disclaimer-24">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-23"><a class="header" href="#goals-23">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the key elements of the Tari second layer, also known as the 
Digital Assets Network (DAN).</p>
<h2 id="related-requests-for-comment-20"><a class="header" href="#related-requests-for-comment-20">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0111_BaseNodeArchitecture.html">RFC-0111: Base Node Architecture</a></li>
</ul>
<h2 id="description-12"><a class="header" href="#description-12">Description</a></h2>
<p>The Tari DAN is based on a sharded BFT consensus mechanism called <a href="https://arxiv.org/abs/2008.04450">Cerberus</a>. </p>
<p>One particular note is that Tari has chosen Hotstuff as the base BFT consensus algorithm over pBFT mentioned in the paper.</p>
<p>The core idea of Cerberus is that instead of dividing work up between validator nodes according to the contracts 
they are managing (as per Tari DANv1, Polkadot, Avalanche, etc.), Cerberus distributes nodes evenly over a set of 
shard addresses. Any time an instruction modifies the state of a contract, it will affect one or more shard 
addresses, and only those nodes that are responsible for covering those addresses will reach consensus on the correct 
state changes.</p>
<p>This means that nodes have to be prepared to execute instructions on any contract in the network. This 
does create a data synchronisation burden, but the added benefit of a highly scalable, decentralised DAN significantly 
outweighs this trade-off.</p>
<h2 id="key-actors"><a class="header" href="#key-actors">Key actors</a></h2>
<p>There are several components on both the Tari Digital Assets Network (DAN) and base layer that interoperate to 
collectively enable scalable smart contracts on Tari.</p>
<p>These components include:</p>
<ul>
<li>Minotari base layer - Enforces Tari monetary policy and plays the role of global registrar.</li>
<li>Templates - Reusable smart contract components.</li>
<li>Contracts - Self-contained pieces of code that describe the behaviour of a smart contract. They are compiled and 
executed in the Tari VM.</li>
<li>Validator Nodes - VNs validate smart contracts and earn fees for doing so.</li>
<li>Cerberus consensus engine - highly scalable, high-speed sharded BFT consensus engine.</li>
<li>Tari Virtual Machine - Runs smart contracts in a secure sandbox.</li>
<li>Tari - the token that fuels the Tari Network a.k.a DAN.</li>
</ul>
<p>The remainder of this document describes these elements in a little more detail and how they relate to each other.</p>
<h2 id="the-minotari-base-layer"><a class="header" href="#the-minotari-base-layer">The Minotari Base Layer</a></h2>
<p>Obviously, the most important role of the Minotari base layer (formerly, Tari base layer) is to issue and secure the 
base Tari token.</p>
<p>As it relates to the DAN, the base layer also serves as an immutable global registry for several key pieces of data:</p>
<ul>
<li>It maintains the register of all validator nodes.</li>
<li>It provides the only means of minting more [Tari] into the DAN economy.</li>
<li>It maintains the register of all DAN contract templates.</li>
</ul>
<p>The base layer also forces the DAN to make progress in the case of a Byzantine stoppage.</p>
<h3 id="templates"><a class="header" href="#templates">Templates</a></h3>
<p>Templates are parameterised smart contracts. Templates are intended to be well-tested, secure, reusable components 
for building and running smart contracts on the DAN.</p>
<p>For example, an NFT template would allow a user to populate a few fields, such as name, number of tokens, media 
locations, and then launch a new NFT series without having to write any actual code.</p>
<p>Templates are stored and managed on the base layer. You can think of the Tari base layer as a type of <em>git</em> for 
smart contracts. Templates will also have version control features and a smooth upgrade path for existing contracts.</p>
<h3 id="contracts"><a class="header" href="#contracts">Contracts</a></h3>
<p>Tari smart contracts are the meat of the Tari ecosystem. Usually, a smart contract will be comprised of one or more 
Tari templates, glue code, and initialisation code.</p>
<p>The contracts are always executed in the Tari Virtual machines. The input and output of every contract instruction 
is validated by validator nodes that reach consensus using the Cerberus consensus engine.</p>
<h3 id="validator-nodes"><a class="header" href="#validator-nodes">Validator Nodes</a></h3>
<p>Validator Nodes (VNs) execute and reach consensus on DAN contract instructions. VNs must register on the base layer 
and lock up funds (the registration deposit) in order to participate in the DAN. </p>
<p>With this in place, every base node has an up-to-the-minute list of all active validator nodes and their metadata. The 
registration deposit also serves as a Sybil prevention mechanism.</p>
<p>Validator nodes are the bridge between the consensus layer and the Tari Virtual Machine (TVM).</p>
<p>VNs are required to re-register periodically as a proof-of-liveness mechanism.</p>
<p>Validator nodes must be able to</p>
<ol>
<li>interpret the instructions they receive from clients, identifying the contract code that the instruction refers,</li>
<li>retrieve and deserialize the relevant input state,</li>
<li>compute the output state that result from applying the contract logic to the input state, and</li>
<li>reach consensus with its peers.</li>
</ol>
<p>Steps 1 - 3 are carried out in the Tari Virtual Machine (TVM).
Step 4 is achieved by communicating with peers via the DAN consensus layer.</p>
<p><a href="RFC-0303_DanOverview.html#tari-and-the-turbine-model">Tari</a> exists at the Validator node level, and VNs earn fees, in Tari, for each 
instruction -- in aggregate -- that it aids in getting finalised.</p>
<h3 id="dan-consensus-layer"><a class="header" href="#dan-consensus-layer">DAN consensus layer</a></h3>
<p>The Cerberus BFT consensus algorithm runs on the consensus layer. This layer is completely ignorant of the 
semantics of DAN smart contracts.</p>
<p>This layer only cares that:</p>
<ul>
<li><em>only</em> VNs that have registered on the base layer are participating in consensus.</li>
<li>VNs are self-organising into VN committees and are carrying out the rules of Cerberus
correctly.</li>
</ul>
<p>In particular, the consensus layer has <em>no idea</em> whether an instruction's output is correct. If two-thirds (plus one)
of the committee agree on the results, then consensus has been reached and the consensus layer is happy.</p>
<p>For example, if consensus decides that 2 + 2 = 5, then for the purposes of this contract, that is the case. </p>
<h3 id="the-tari-virtual-machine"><a class="header" href="#the-tari-virtual-machine">The Tari Virtual Machine</a></h3>
<p>The TVM is a WASM-based virtual machine designed to run Tari contracts.
Contracts are composed of one or more Tari templates, glue code and a state schema. Tari Labs provides a Rust 
implementation for TVM contracts, but in principle, other languages could implement the specification as well.</p>
<p>The TVM is able to</p>
<ul>
<li>load a contract.</li>
<li>provide a list of methods that the contract exposes.</li>
<li>Execute calls on the contract.</li>
<li>Initiate retrieval and persistence of the state of the contract. The state itself is not stored in the VM, but by 
Indexers.</li>
</ul>
<h3 id="tari-and-the-turbine-model"><a class="header" href="#tari-and-the-turbine-model">Tari and the turbine model</a></h3>
<p>Tari is used to power the DAN's economic 
engine. Tari is minted via a one-way perpetual peg as described in <a href="RFC-0320_TurbineModel.html">RFC-0320</a>. Briefly, Minotari are burnt to create 
Tari, which are used to pay for the execution of instructions on the DAN. A portion of instruction fees are burnt 
with every instruction to provide a constant source of demand for Tari in the DAN.</p>
<p>There is no peg out back to the base layer for Tari. The reason for this is explained in <a href="RFC-0320_TurbineModel.html">RFC-0320</a>. 
Tari holders wishing to convert back to Tari will be able to perform a submarine swap with a Tari seller. 
We also anticipate that exchanges will list the Tari-Minotari pair to enable easy conversion of Tari back to Minotari.</p>
<h1 id="change-log-19"><a class="header" href="#change-log-19">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">23 Oct 2023</td><td style="text-align: left">Thaum -&gt; Tari</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">1 Nov 2022</td><td style="text-align: left">High-level overview</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">26 Oct 2022</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvHeerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-313vn-registration"><a class="header" href="#rfc-313vn-registration">RFC-313/VN Registration</a></h1>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">stringhandler</a>, <a href="https://github.com/SWvheerden">SW van heerden</a> and <a href="https://github.com/sdbondi">sdbondi</a></p>
<h1 id="licence-23"><a class="header" href="#licence-23">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-25"><a class="header" href="#language-25">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-25"><a class="header" href="#disclaimer-25">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-24"><a class="header" href="#goals-24">Goals</a></h2>
<p>The goal of this RFC is to outline the <a href="RFC-0303_DanOverview.html">DAN</a> validator node registration requirements and define a set of procedures that allow permissionless participation
in the <a href="RFC-0303_DanOverview.html">DAN</a>. This includes defining the interaction between the validator and base node, new base layer validations, and validator shard key allocation.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Building on the <a href="./RFC-0303_DanOverview.html">RFC-0303</a>, we define the mechanism that allows <a href="RFC-0303_DanOverview.html">DAN</a> validators to register on the <a href="RFC-0303_DanOverview.html">DAN</a> network.</p>
<p>Each validator requires a connection to a trusted <a href="./Glossary.html#base-node">base-layer node</a> that provides a canonical view of the blockchain. The blockchain
serves as a shared logical clock for the <a href="RFC-0303_DanOverview.html">DAN</a>. </p>
<p>In this RFC, we will show that the validators can leverage the strong <em>liveness</em> guarantees of proof-of-work while providing a scheme that mitigates
the effects of weak <em>safety</em> guarantees (namely, reorgs) on the <a href="Glossary.html#base-layer">base layer</a>.</p>
<h2 id="requirements-and-definitions"><a class="header" href="#requirements-and-definitions">Requirements and Definitions</a></h2>
<ol>
<li>To participate in <a href="RFC-0303_DanOverview.html">DAN</a> BFT consensus, a validator node MUST be registered on the Layer 1 Tari blockchain.</li>
<li>Each registration expires after a number of epochs, at which point the validator may no longer participate in <a href="RFC-0303_DanOverview.html">DAN</a> consensus.</li>
<li>A validator MAY re-register before or after the expiration epoch is reached to allow continued participation in <a href="RFC-0303_DanOverview.html">DAN</a> consensus.</li>
<li>A validator registration MUST be submitted as a base layer <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> signed by the <code>VN_Public_Key</code></li>
<li>A validator MUST be assigned a deterministic but randomized <code>VN_Shard_Key</code> that can be verified at any epoch by other validators by inspecting the base layer.</li>
<li>The <code>VN_Shard_Key</code> MUST be periodically reassigned/shuffled to prevent prolonged control over a particular <a href="RFC-0304-DanGlossarymd#Consensus-level">shard space</a>.</li>
<li>A validator MUST be able to generate a Merkle proof that it is registered for the epoch that it is currently participating.</li>
<li>The validator set for any given epoch MUST be unambiguous between validators or anyone observing the <a href="Glossary.html#base-layer">base layer</a> chain.</li>
<li>Base layer reorgs MUST NOT negatively affect the <a href="RFC-0303_DanOverview.html">DAN</a> layer. </li>
</ol>
<p>We define the following validator variables:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Name</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">$V_i$</td><td style="text-align: left"><code>VN_Public_Key</code></td><td style="text-align: left">The $i$th public validator node key</td></tr>
<tr><td style="text-align: left">$S_i$</td><td style="text-align: left"><code>VN_Shard_Key</code></td><td style="text-align: left">The $i$th 256-bit VN shard key.</td></tr>
<tr><td style="text-align: left">$\epsilon_i$</td><td style="text-align: left"><code>Epoch</code></td><td style="text-align: left">The $i$th epoch. An epoch is <code>EpochLength</code> blocks.</td></tr>
</tbody></table>
</div>
<p>An epoch $\epsilon$ is defined by the <a href="Glossary.html#base-layer">base layer</a> block height $h$, where $\epsilon_i = \lfloor \frac{h}{\text{EpochLength}} \rfloor$,
and spans all blocks from the start of the epoch up to but excluding the start of the next epoch.</p>
<p><em>Base layer consensus constants</em> (all values TBD):</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>EpochLength</code></td><td style="text-align: left">60 Blocks (~2h)</td><td style="text-align: left">The number of blocks in an epoch</td></tr>
<tr><td style="text-align: left"><code>VNRegistrationValidityPeriod</code></td><td style="text-align: left">20 Epochs (~40hrs)</td><td style="text-align: left">The number of epochs that a validator node registration is valid</td></tr>
<tr><td style="text-align: left"><code>VNRegDepositAmount</code></td><td style="text-align: left">TBD Tari</td><td style="text-align: left">The minimum amount that must be spent to create a valid <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a></td></tr>
<tr><td style="text-align: left"><code>VNRegLockHeight</code></td><td style="text-align: left">10 Epochs</td><td style="text-align: left">The lock height that must be set on every <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a></td></tr>
<tr><td style="text-align: left"><code>VNShardShuffleInterval</code></td><td style="text-align: left">100 Epochs</td><td style="text-align: left">The interval that a validator node shard key is shuffled</td></tr>
</tbody></table>
</div>
<p><em>Validator node consensus constants:</em></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>VNConfirmationPeriod</code></td><td style="text-align: left">1000 Blocks</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h2 id="validator-registration"><a class="header" href="#validator-registration">Validator Registration</a></h2>
<p>A validator node operator wishing to participate in <a href="RFC-0303_DanOverview.html">DAN</a> consensus MUST generate a <a href="https://ristretto.group/">Ristretto</a> keypair <code>&lt;VN_Public_Key, VN_Secret_Key&gt;</code> that serves as a stable <a href="RFC-0303_DanOverview.html">DAN</a> identity and a signing key for L2 consensus messages.
The <code>VN_Public_Key</code> MUST be registered on the base layer by submitting a <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> which allows the validator to participate in <a href="RFC-0303_DanOverview.html">DAN</a> consensus for <code>VNRegistrationValidityPeriod</code>.</p>
<p>The published <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> has these requirements:</p>
<ol>
<li>MUST contain a valid <a href="https://tlu.tarilabs.com/cryptography/introduction-schnorr-signatures">Schnorr signature</a> that proves knowledge of the <code>VN_Secret_Key</code> 
<ul>
<li>The signature challenge is defined as $e = H(P \mathbin\Vert R \mathbin\Vert m)$</li>
<li>$R$ is a public nonce, $P$ is the public <code>VN_Public_Key</code> </li>
<li>$m$ is the <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> commitment</li>
</ul>
</li>
<li>the <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>'s <code>minimum_value</code> must be at least <code>VNRegDepositAmount</code> to mitigate spam/Sybil attacks,</li>
<li>the <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> lock-height must be set to <code>VNRegLockHeight</code>.</li>
<li>A script which burns the validator node registration funds if the validator does not reclaim it for a long period after the lock height expires.</li>
</ol>
<pre><code class="language-text">OP_PUSH_INT(N) OP_COMPARE_HEIGHT OP_LTE_ZERO OP_IF_THEN 
    NOP
OP_ELSE
    OP_RETURN
OP_END_IF
</code></pre>
<p>By submitting this <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> the validator node operator is committing to providing a highly-available node from the next epoch
after the validator node registration was submitted to <code>VNRegistrationValidityPeriod</code> epochs after that.</p>
<p>A validator node operator MAY re-register their <code>VN_Public_Key</code> before the <code>VNRegistrationValidityPeriod</code> epoch is reached, OPTIONALLY 
spending the previous <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>. If the previous <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> has not expired and
a new <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> is submitted, the new <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> supersedes the previous one.</p>
<blockquote>
<p>The validator node may implement auto re-registration to ensure that the validator node continues 
to be included in the current VN set without constant manual intervention.</p>
</blockquote>
<p>A validator MAY deregister by spending their <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>. This will remove the validator from the current VN set
in the next epoch.</p>
<h3 id="base-layer-consensus-1"><a class="header" href="#base-layer-consensus-1">Base-layer consensus</a></h3>
<p>The base layer performs the following additional validations for <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s:</p>
<ol>
<li>The <code>VN_Registration_Signature</code> MUST be valid for the given <code>VN_Public_Key</code> and challenge</li>
<li>The <code>minimum_value</code> field MUST be at least <code>VNRegDepositAmount</code>. The existing <code>minumum_value</code> validation ensures the committed value is correct.</li>
</ol>
<p>Additionally, we introduce a new <a href="Glossary.html#block-header">block header</a> field <code>validator_node_mr</code> that contains a Merkle root committing to all validator 
<code>Vn_Shard_Key</code>s in the current epoch.
The <code>validator_node_mr</code> needs to be recalculated at every <code>EpochSize</code> blocks to account for departing and arriving nodes.
The <code>validator_node_mr</code> MUST remain unchanged for blocks between epochs, that is, blocks that are not multiples of <code>EpochSize</code>.</p>
<blockquote>
<p>A validator generates a Merkle proof that proves its <code>VN_Shard_Key</code> is included in the validator set for any given epoch. This proof is provided in layer 2 Quorum Certificates.</p>
</blockquote>
<p>The <code>validator_node_mr</code> is calculated for each block as follows:</p>
<ol>
<li>if the current block height is a multiple of <code>EpochSize</code>
<ul>
<li>then fetch the VN set for the epoch</li>
<li>build a merkle tree from the VN set, each node is $H(V_i \mathbin\Vert S_i)$</li>
</ul>
</li>
<li>otherwise, fetch the previous block's <code>validator_node_mr</code> and return it</li>
</ol>
<h2 id="epoch-transitions"><a class="header" href="#epoch-transitions">Epoch transitions</a></h2>
<p>The <a href="RFC-0303_DanOverview.html">DAN</a> BFT consensus protocol relies on a shared and consistent &quot;source of truth&quot; from the <a href="Glossary.html#base-layer">base layer</a> chain that defines
the current epoch and validator set as well as <a href="./RFCD-0306_DANTemplateRegistration.html">templates</a>.</p>
<p>As briefly mentioned in the <a href="RFC-0313_VNRegistration.html#overview">overview</a>, any PoW <a href="Glossary.html#base-layer">base layer</a> chain is prone to <a href="Glossary.html#chain-reorganization">reorg</a>s. The question arises, how do we 
achieve a shared, consistent view of the chain when the data can disappear from underneath you?</p>
<p>We define a <code>VNConfirmationPeriod</code> as is a network-wide constant that specifies the number confirmations (blocks) that a block must have 
before a validator will recognise it as final. The chosen value for <code>VNConfirmationPeriod</code> must be large enough to make reorgs beyond that 
point practically impossible. Validators simply ignore <a href="Glossary.html#base-layer">base layer</a> <a href="Glossary.html#chain-reorganization">reorg</a>s with a depth <em>less than</em> <code>VNConfirmationPeriod</code> deep as the 
data they have extracted is still valid. This means that the <em>point of finality</em> is not always <code>VNConfirmationPeriod</code> blocks away from the
tip and is non-decreasing/monotonic which effectively negates <a href="Glossary.html#chain-reorganization">reorg</a> &quot;noise&quot; from the chain tip. </p>
<p>However, this does not address <a href="Glossary.html#base-layer">base layer</a> latency delays where a single huge block or multi-block reorgs may take seconds to be received 
and processed by all <a href="Glossary.html#base-node">base node</a>s. Moreover, the validators may poll the base layer only every few seconds, further increasing the latency for 
validators to become aware of the state. This means a single strict validator epoch change-over point will almost always cause liveness failures at 
and after the epoch transition.</p>
<p>To address this, we define a <code>VNEpochGracePeriod</code> where both the previous and current epoch are accepted. This value, in blocks, must allow enough
time for all validators to become aware of the <a href="Glossary.html#base-layer">base layer</a> state for the epoch.</p>
<p>To illustrate, consider the following view of a <a href="Glossary.html#base-layer">base layer</a> chain. We mark 3 views of the chain.</p>
<pre><code class="language-text">                                      (a) (b) (c)                
                                       |   |   |                                         {noisy}
------ | --x------------ | --x------------ | --x------------ | --x------------ | --- .... ------&gt; tip
  |  ϵ10       |   |    ϵ11       |      ϵ12       |       ϵ13               ϵ14
 V_1          V_2 V_3   V_4      V_5              V_6                      
Key:
x - Epoch transition point
ϵn - Epoch n
V_n - Validator registrations 
</code></pre>
<p>Point (a)</p>
<ul>
<li>the validator node set is incomplete for epoch 12.</li>
<li>the active epoch is 11.</li>
<li>the validator MUST reject instructions for epoch 12.</li>
</ul>
<p>Point (b) - the start of epoch 12: </p>
<ul>
<li>the validator node set is final for epoch 12.</li>
<li>the active epoch remains at 11. This is because validators may not have reached epoch 12/point (b) and therefore will only accept epoch 11.</li>
<li>a validator MUST accept instructions from epoch 11 and 12.</li>
<li>a validator may receive a leader proposal for epoch 11 and 12, however a well-behaved validator MUST only vote for one of these proposals.</li>
</ul>
<p>Point (c) - the transition point for epoch 12:</p>
<ul>
<li>the active epoch is now 12</li>
<li>the validator MUST reject instructions from 11.</li>
<li>it is assumed at this point that almost all (at least $2f + 1$) nodes will accept epoch 12</li>
</ul>
<h4 id="validator-node-set-definition"><a class="header" href="#validator-node-set-definition">Validator Node Set Definition</a></h4>
<p>The function $\text{get_vn_set}(\epsilon_\text{start}, \epsilon_\text{end}) \rightarrow \vec{S}$ that returns an ordered 
vector $\vec{S}$ of <code>VN_Shard_Key</code>s that are registered for the epoch $\epsilon_n$. The validator node set is ordered by <code>VN_Shard_Key</code>.</p>
<h5 id="data-indexes"><a class="header" href="#data-indexes">Data Indexes</a></h5>
<p>The following additional indexes are recommended to allow efficient retrieval of the VN set, shard key mappings and to produce a valid <code>validator_node_mr</code>:</p>
<ul>
<li>$I_\text{primary} = \{ (h_i, V_i, C_i) \rightarrow (V_i, S_i) \}$ </li>
<li>$I_\text{shard} = \{ (V_i, h_i, C_i) \rightarrow S_i \}$</li>
<li>$C_i$ is the $i$th <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> commitment </li>
</ul>
<p>Database index $I_\text{primary}$ that maintains a mapping from the next epoch after the registration to all the 
<code>&lt;VN_Public_Key, VN_Shard_Key&gt;</code> tuples for all <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s. This allows efficient retrieval 
from a particular height onwards, optionally for a particular validator node public key.</p>
<p>The index entry is <em>not</em> removed whenever the <code>ValidatorNodeRegistration</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> is spent or expires. This is to allow
state to be rewound for reorgs.
If a validator adds two or more validator registration <a href="Glossary.html#unspent-transaction-outputs">UTXOS</a> in the same block, the index will order them by commitment, that is, 
the same canonical ordering as the Tari block body. The <code>get_vn_set</code> function MUST return the last registration 
public key and shard key tuple only, according to this canonical ordering.</p>
<h4 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h4>
<p>The function $\text{get_vn_set}$ is defined as follows:</p>
<ol>
<li>Iterate on index $I_\text{primary}$, starting from where the key is between (inclusive) the equivalent block height for 
$\epsilon_\text{start}$ and $\epsilon_\text{end}$:
<ul>
<li>Add to the set, and</li>
<li>if the validator node public key is already in the set, remove the previous entry.</li>
</ul>
</li>
</ol>
<p>For this example, we say that there have been no registrations prior to <code>V_1</code>; we define 
<code>VNRegistrationValidityPeriod = 2 epochs</code>.</p>
<pre><code class="language-text">                                    (a)            (b)            (c)
                                     |              |              |                      {noisy}
------ | --x------------ | --x------------ | --x------------ | --x------------ | --- .... ------&gt; tip
  |   ϵ10       |   |    ϵ11       |      ϵ12  |    |       ϵ13               ϵ14
 V_1           V_2 V_3  V_4       V_5         V_2  V_6         
 
Key:
x - Epoch transition point
ϵn - Epoch n
V_n - Validator Node Registration UTXO n
</code></pre>
<ul>
<li>Point (a) $\text{get_vn_set}(\epsilon_11) -&gt; [V_1, V_2, V_3]$</li>
<li>Point (b):
<ul>
<li>In: $[V_2, V_3, V_4, V_5]$, out: $[V_1]$</li>
<li>$\text{get_vn_set}(\epsilon_12) -&gt; [V_2, V_3, V_4, V_5]$</li>
</ul>
</li>
<li>Point (c):
<ul>
<li>In: $[V_6]$, out: $[]$</li>
<li>$\text{get_vn_set}(\epsilon_13) -&gt; [V_2, V_4, V_5, V_6]$</li>
</ul>
</li>
</ul>
<h3 id="shard-key-and-shuffling"><a class="header" href="#shard-key-and-shuffling">Shard Key and Shuffling</a></h3>
<p>The <code>VN_Shard_Key</code> is a deterministic 256-bit random number that is assigned to a validator node by the base layer for a given epoch, and
maps onto the 256-bit <a href="RFC-0304-DanGlossarymd#Consensus-level">shard space</a>. </p>
<p>The <a href="RFC-0303_DanOverview.html">DAN</a> network needs to agree on and maintain a mapping between each participant's <code>VN_Public_Key</code> and the corresponding <code>VN_Shard_Key</code> for the 
current epoch. </p>
<p>Over time, an adversary may gain excessive control over a particular shard space. To mitigate this, we introduce a shuffling mechanism that
periodically and randomly reassigns <code>VN_Shard_Key</code>s within the network.</p>
<p>We define the function $\text{generate_shard_key}(V_n, \eta) \rightarrow S$ that generates the <code>VN_Shard_Key</code> from the inputs.
$S = H_\text{shard}(V_n \mathbin\Vert \eta)$ where $H_\text{shard}$ is a domain-separated <a href="https://github.com/tari-project/tari-crypto/blob/fa042e498be144d8d2af7b96efe805c5af0b2d4f/src/hash/blake2.rs">Blake256</a> hash function, $V_n$ is the public <code>VN_Public_Key</code> and $\eta$ is some entropy.</p>
<p>And we define the function $\text{derive_shard_key}(S_{n-1}, V_n, \epsilon_n, \hat{B}) \rightarrow S$ that deterministically derives the <code>VN_Shard_Key</code> for
epoch $\epsilon_n$ from the public <code>VN_Public_Key</code> $V_n$, $\hat{B}$ the block hash at height $\epsilon_n * \text{EpochSize} - 1$ (the block before the epoch block).</p>
<p>The function $\text{derive_shard_key}$ is defined as follows:</p>
<ol>
<li>Given:
<ul>
<li>$S_{n-1}$ the previous <code>VN_Shard_Key</code> </li>
<li>$V$ the <code>VN_Public_Key</code></li>
<li>$\epsilon_n$ the epoch number to generate a <code>VN_Shard_Key</code> for</li>
<li>$\hat{B}$ the previous block hash </li>
</ul>
</li>
<li>If the previous shard key $S_{n-1}$ is not null, 
<ul>
<li>Check $(V + \epsilon_n) \bmod \text{ShufflePeriod} == 0$.</li>
<li>If true, generate a new shard key using $\text{generate_shard_key}(V, \hat{B})$.</li>
<li>If false, return $S_{n-1}$.</li>
</ul>
</li>
<li>If the previous shard key $S_{n-1}$ is null, 
<ul>
<li>generate a new shard key using $\text{generate_shard_key}(V, \hat{B})$.</li>
</ul>
</li>
</ol>
<p>Only a random fraction of validators will be re-assigned shard keys per epoch and that fraction will not be shuffled again
for <code>VNShardShuffleInterval</code> epochs. Although the exact number of validators that shuffle per epoch varies, on average 
the <code>VNShardShuffleInterval</code> should aim to shuffle around 5% of the network at every epoch. This is to ensure that the
number of shuffling validators is much less than $\frac{1}{3}$ of the validator set, as this could break liveness and safety 
guarantees. </p>
<p>The <code>prev_shard_key</code> is the last <code>VN_Shard_Key</code> that was assigned to the validator node within the <code>VNRegistrationValidityPeriod</code>.
Should <code>VNRegistrationValidityPeriod</code> elapse without a renewed registration, a new <code>VN_Shard_Key</code> is assigned. 
This means that a validator may be assigned a different <code>VN_Shard_Key</code> after each <code>VNRegistrationValidityPeriod</code>, 
sooner than <code>VNShardShuffleInterval</code>. The validator has nothing to gain from this, on the contrary, they will have 
to re-sync their state and spend time not participating in the network, losing out on fees.</p>
<h1 id="change-log-20"><a class="header" href="#change-log-20">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">12 Oct 2022</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvHeerden</td></tr>
<tr><td style="text-align: left">08 Nov 2022</td><td style="text-align: left">Updates</td><td style="text-align: left">sdbondi</td></tr>
<tr><td style="text-align: left">18 Nov 2022</td><td style="text-align: left">Implementation updates</td><td style="text-align: left">sdbondi</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0320turbinemodel"><a class="header" href="#rfc-0320turbinemodel">RFC-0320/TurbineModel</a></h1>
<h2 id="the-dan-peg-in-mechanism-or-turbine-model"><a class="header" href="#the-dan-peg-in-mechanism-or-turbine-model">The DAN peg-in mechanism, or Turbine model</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-24"><a class="header" href="#licence-24">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-26"><a class="header" href="#language-26">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-26"><a class="header" href="#disclaimer-26">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-25"><a class="header" href="#goals-25">Goals</a></h2>
<p>Tari is used to power the DAN's economic engine.</p>
<p>This RFC describes the motivation and mechanism of the Minotari to DAN peg-in mechanism. </p>
<h2 id="related-requests-for-comment-21"><a class="header" href="#related-requests-for-comment-21">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0111_BaseNodeArchitecture.html">RFC-0111: Base Node Architecture</a></li>
<li><a href="RFC-0303_DanOverview.html">RFC-0303: Digital Assets Network</a></li>
</ul>
<h2 id="description-13"><a class="header" href="#description-13">Description</a></h2>
<p>Side-chains are related to their parent chains via a pegging mechanism. In general, peg-in transactions (transferring
value to the side-chain) are straightforward. One locks value up on the parent chain, which can be referenced by the
side-chains. However, the reverse transaction is fraught with difficulty, since the parent chain must know almost
nothing about the transaction particulars of the side chain. We know this is the case, otherwise the entire
side-chain + parent-chain system are forced to work in lock-step and the two chains are really just one larger, more 
complicated chain.</p>
<p>Peg outs are particularly difficult if the participants change on the side-chain (as opposed to say, payment 
channels, like the Lightning Network, where the same parties peg-in and -out).</p>
<p>There are several proposals to develop a reliable two-way peg, including <a href="https://www.youtube.com/watch?v=N2ow4Q34Jeg">space-chains</a>, <a href="https://www.drivechain.info/">drive-chains</a> and federated
side-chains, like <a href="https://elementsproject.org/how-it-works">elements</a>. All of them have particular trade-offs and difficulties.</p>
<p>For Tari, we propose a slightly different approach: A one-way peg with persistent 2nd-layer burn.</p>
<p>Because the operating principle is quite similar to that of a gas turbine, we call this approach the <em>turbine model</em>.
Fuel (Minotari) is fed into the turbine, which is burnt (also burnt :)) which produces a hot, motive gas (Tari) that 
drives the engine (the DAN). The exhaust gas is ejected from the rear of the turbine (a portion of the instruction 
fees are burnt).</p>
<h3 id="an-aside---the-monetary-policy-trilemma"><a class="header" href="#an-aside---the-monetary-policy-trilemma">An aside - the monetary policy trilemma</a></h3>
<p>The <a href="https://www.investopedia.com/terms/t/trilemma.asp">monetary policy trilemma</a> states that you <em>cannot
control all 3 of these things simultaneously</em>:</p>
<ol>
<li>exchange rate</li>
<li>monetary policy (i.e. minting and burning to control supply)</li>
<li>flow of capital (money leaving or entering the system)</li>
</ol>
<p>Let's briefly consider the trilemma from the point of view of the DAN.</p>
<h4 id="monetary-policy"><a class="header" href="#monetary-policy">Monetary policy</a></h4>
<p>We are effectively forced to control monetary policy.
Or put another way, we can't let people freely mint their own Tari. Unfortunately, even though we have &quot;chosen&quot; to
control supply, it's difficult for us to control the Tari supply in practice. In the physical world, the money 
supply is typically managed by a central bank, with the emphasis on &quot;central&quot;.</p>
<p>The designers of a decentralised monetary system have precious few levers available to control supply and no simple ones.</p>
<h4 id="capital-flow"><a class="header" href="#capital-flow">Capital flow</a></h4>
<p>Allowing free capital flow would require a reliable and efficient peg-out mechanism from the DAN back to the base layer.
However, I argue that this is an Achilles heel. <em>Any</em> peg-out system you can devise that is coupled with a burn-type 
peg-in mechanism is an existential threat to the base layer.</p>
<p>Why? Because the peg-out necessarily requires creation of coins on the base layer by <em>trusting</em> some mechanism 
external to it. Note that we're not bringing UTXOs that were pegged-in back into circulation (in this 
case they would not be burned, merely locked-up as in a traditional peg). Therefore, the base layer accounting simply 
has to accept these mints as valid. </p>
<p>Consequently, <em>any bug whatsoever on the DAN related to the minting process' authenticity</em>  could lead to undetectable 
inflation on the base layer. </p>
<p>A central axiom of side-chain design, if there is such a thing, is that the side-chain should pose <em>zero</em> risk to the 
security of the base layer. For this reason, the burn mechanism effectively <em>excludes the possibility of peg ins</em>.</p>
<p>So essentially, we cannot allow the free flow of capital either.</p>
<h4 id="exchange-rate"><a class="header" href="#exchange-rate">Exchange rate</a></h4>
<p>Since we have already picked two legs of the trilemma, we cannot do anything about the third, and must allow the change 
rate to float.</p>
<h3 id="the-turbine-model"><a class="header" href="#the-turbine-model">The turbine model</a></h3>
<p>This is actually not as terrible as it sounds. The trilemma doesn't force you to sit at the vertex of the monetary
policy triangle. If you allow <em>partial</em> freedoms in supply and capital flow, then the exchange rate will move, but
will tend to remain range-bound.</p>
<p>Although capital flow here is not free, it's not completely restricted either:</p>
<ol>
<li>Peg-ins are completely unrestricted.</li>
<li>Submarine-swaps allow people to remove money from the system on the micro-level (albeit not on the macro level).</li>
</ol>
<p>And the money supply can be tuned, if not controlled. This all leads to the proposal of a new mechanism, the turbine 
model:</p>
<p><img src="./assets/turbine.png" alt="turbine" /></p>
<p>The DAN Tari supply is increased by user peg-in deposits, and any other mechanism that we may want to enforce, 
such as asset issuer financing. </p>
<p>To prevent the eventual collapse of the Tari price to zero, there must be an exhaust mechanism that continually 
removes Tari from the system..</p>
<p>The simplest exhaust mechanism is to simply burn a fraction of Tari fees from every transaction! These can be very
low. Presumably, over the long-run the burn rate should approximately match the Minotari blockchain tail emission.</p>
<p>The exhaust places a permanent upward pressure on the Tari exchange rate; but it will never exceed 1:1 with Minotari,
since any premium will be immediately arbitraged away. This is because anyone can <em>always</em> burn as much Minotari as they 
wish and mint Tari at a 1:1 ratio on the DAN and then sell them for a risk-free profit. This action will increase 
the supply of Tari and drive the price back down to parity.</p>
<p>If the exhaust is temporarily insufficient to hold the peg, the Tari price will drop below 1 XTR. This will 
immediately shut off deposits because submarine swaps will a be cheaper route to obtaining Tari than burning 
Minotari (which are always 1:1). Since the exhausts upward price pressure is a constant force, the Tari price will 
eventually approach 1:1 again.</p>
<p>Over time, we expect this mechanism to provide a somewhat stable peg between Tari and Minotari with the Tari price 
occasionally dropping below parity and possibly remaining there for some time. As secondary markets for the 
Tari-Minotari pair matures, this event will immediately create a bid on Tari, since -- in the absence of catastrophic 
failure -- speculators know that the Tari price will eventually return to parity, causing upward pressure to come into 
play quickly and efficiently.</p>
<h1 id="change-log-21"><a class="header" href="#change-log-21">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">23 Nov 2023</td><td style="text-align: left">Thaum -&gt; Tari</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">1 Nov 2022</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0350tarivm"><a class="header" href="#rfc-0350tarivm">RFC-0350/TariVM</a></h1>
<h2 id="the-tari-virtual-machine-1"><a class="header" href="#the-tari-virtual-machine-1">The Tari Virtual Machine</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-25"><a class="header" href="#licence-25">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2023 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-27"><a class="header" href="#language-27">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-27"><a class="header" href="#disclaimer-27">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-26"><a class="header" href="#goals-26">Goals</a></h2>
<p>This RFC describes the design goals and rationale for the Tari Virtual Machine (TVM).</p>
<h2 id="related-requests-for-comment-22"><a class="header" href="#related-requests-for-comment-22">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0303_DanOverview.html">RFC-0303: Digital Assets Network</a></li>
<li><a href="RFC-0305_Consensus.html">RFC-305: The Tari Network Consensus Layer</a></li>
</ul>
<h2 id="description-14"><a class="header" href="#description-14">Description</a></h2>
<p>The Consensus Layer for the Tari network, described in <a href="RFC-0305_Consensus.html">RFC-0305</a>, is responsible for
distributed and trust-minimised decision-making in the Tari digital assets network (DAN).</p>
<p>The consensus layer is blind to any notions of smart contracts, NFTs or stablecoins. It merely enforces that
decision made by honest nodes are propagated to the rest of the network.</p>
<p>Business logic is encapsulated in the Tari Logic layer.</p>
<p>The relationship between the logic and the consensus layers is best illustrated by the transaction flow, from client
to resolution. This flow is diagrammed in Figure 1.</p>
<p>The client creates a transaction using a <a href="RFC-0350_TariVM.html#the-transaction-manifest">transaction manifest</a>. The manifest collates
every contract, function call and log entry that the client wants to execute into a single bundle. The manifest is then
submitted to an indexer that will collect all the input state required for the transaction pre-emptively. This is a
deviation from the Cerberus and Chainspace papers and allows the indexer to perform a dry-run of the transaction before
submitting it to a validator node.</p>
<p>The advantage of this is that the client can be notified of any errors before submitting the transaction to the
network and incurring fees.</p>
<p>On the other hand, the indexer commits to the given set of inputs when submitting the transaction to the validator node.
If the indexer is mistaken, or lagging in its updates, it is possible that the transaction will be aborted due to
attempting to use expired inputs.</p>
<p>However, this is not expected to happen often, and assuming everything is in order, the validator node will confirm
the correct version of all the input states by collecting all local and foreign substates involved in the transaction.</p>
<p>If these are satisfactory and match what was provided by the indexer, the validator node will pass the transaction
manifest data along with the input state to the Tari Engine for execution.</p>
<p>The Tari Engine will determine which WASM modules are required to perform this work, load them into a WASM runtime,
and execute the functions. The Tari engine makes use of several services to help it in this task, including the
template manager, the Tari SDK, and Tari runtime wrapper.</p>
<p>The execution result (whether successful or not) is returned to the validator node, which then compares the results
with its peers via Hotstuff consensus to achieve agreement on the final result. If consensus is achieved, the affected
substates are updated (see <a href="RFC-0330_Cerberus.html">RFC-330</a>) and the result is relayed to the indexer who passes it
on to the client.</p>
<p>A key point here is that the consensus layer delegates <em>all</em> business logic to the logic layer. However, <em>only</em> the
consensus layer has the ability to make changes to the state of the network, after reaching consensus.</p>
<pre class="mermaid">flowchart LR
    Cl((Client)) -------&gt; |tx
    'Transfer JPG to Bob'| Ix1
    Ix1 -.-&gt; |returns result| Cl
    
    subgraph Indexer
        TM --&gt; Ix1([Indexer])
        Ix1 &lt;-.-&gt; |reads| SS1[(Substates)]
        Ix1 &lt;-.-&gt; |requests| VN1[[VNC]]    
        Ix1 &lt;-.-&gt; |dry run| VM1[[TariVM]]
    end
    Ix1 --&gt;|submits with\nlocked inputs| C
    
 
    subgraph Logic Layer
      T[Template manager]
      W[Wasm compiler]
      ABI[Contract interface]
      E[Tari engine]
      RT[WASM Runtime]
      SDK[Tari SDK]
      E &lt;--&gt; RT
    end

    C --&gt; |calls| E
    E --&gt; |returns new substates| C
    subgraph Consensus Layer
        C[Validator node]
        C &lt;-.-&gt; |reads/writes| SS[(Local substates)] 
        C &lt;-.-&gt; |foreign state\nrequests| VNC[[VNC]]
        EM[Epoch management]
        VNCm[Validator committee\n management]
        HS[Cerberus-Hotstuff]
    end
</pre>
<p>The Tari Logic layer comprises several submodules:</p>
<ul>
<li><strong>The Tari engine</strong>. The Tari engine is responsible for the transaction execution process and fee disbursements.</li>
<li><strong>The Template manager</strong>. The template manager polls the Minotari base layer looking for template registration
transactions.</li>
<li><strong>The Tari runtime</strong>. The Tari runtime wraps a <a href="RFC-0350_TariVM.html#why-web-assembly">WASM virtual machine</a> that executes the compiled
contract code. The runtime is able to calculate the total compute requirements for every instruction, which determines
the transaction fee.</li>
<li><strong>The contract interface (ABI)</strong>. This is a list of functions, their arguments and return values that a particular
contract is able to execute. The ABI is generated when the contract template is compiled.</li>
<li><strong>The transaction manifest</strong>. This is a high-level set of instructions that a client application generates to achieve
some user goal.</li>
</ul>
<h3 id="the-tari-engine"><a class="header" href="#the-tari-engine">The Tari engine</a></h3>
<p>The Tari engine is responsible for the transaction execution process and fee disbursements. It communicates with
other actors in the Tari network via JSON-RPC. Transactions can be submitted to be executed via the
<code>submit_transaction</code> procedure call.</p>
<p>A transaction contains the following information:</p>
<ul>
<li>A list of input substate that will be downed (spent).</li>
<li>A list of input substates that are used as references, but their state is not altered.</li>
<li>The list of instructions to execute (call method, claim funds, emit logs etc.).</li>
<li>Signatures</li>
<li>Network metadata</li>
</ul>
<p>Transaction execution proceeds via the following high-level flow:</p>
<ul>
<li>The engine determines the total fee for the transaction by charging for every operation executed within the WASM
runtime, as per the <a href="RFC-0350_TariVM.html#the-tari-fee-schedule">fee schedule</a>.</li>
<li>The engine initializes a WASM runtime, which executes the instructions embedded in the transaction. For each
instruction, a [template provider] will attempt to provide the WASM, or other compatible binary, to execute the
instruction with the given input parameters. See also the <a href="RFC-0350_TariVM.html#base-node-scanner">base node scanner</a>. For now, only
WASM modules are supported, but in future, additional runtimes could be supported by the Tari Engine, including
Zero-Knowledge contracts, or the EVM.</li>
<li>The result of execution -- the execution status, and the set of outputs -- is passed back to the consensus layer.
Note that outside of the vanishingly small chance of an output substate collision, even a failed execution attempt is
a 'positive' (i.e. <code>COMMIT</code>ted) result in terms of consensus, as long as the super-majority of nodes agree that
&quot;failure&quot; is the consensus result!</li>
</ul>
<h4 id="template-manager"><a class="header" href="#template-manager">Template manager</a></h4>
<p>The Tari engine maintains a service that scans the Minotari chain every few minutes that among other things, looks
for template registration transactions.</p>
<p>When a new template is registered, the template manager will locate the registered WASM module, validate it, and
store it in the local database.</p>
<p>The template manager abstracts away issues such as template versioning, whether the module is stored in IPFS, or a
centralised repository. It can also request binaries from a peer to reduce the load on external services.</p>
<p>In future, the template manager might also be able to retrieve source code, and make use of reproducible builds to
compile audited source code and add it to the local WASM repository.</p>
<h3 id="the-tari-runtime"><a class="header" href="#the-tari-runtime">The Tari runtime</a></h3>
<p>The Tari runtime is a wrapper that provides common functionality for executing arbitrary smart contracts in WASM<br />
modules. Functionality includes:</p>
<ul>
<li>calling a function,</li>
<li>calling a method,</li>
<li>emitting a log entry,</li>
<li>pushing an object into the workspace.</li>
</ul>
<p>In combination with a contract's ABI, the runtime is able to execute almost any contract code.</p>
<p>Tari uses the <a href="https://wasmer.io/">wasmer</a> runtime to actually load and execute Web Assembly inside a secure,
sandboxed environment.</p>
<h2 id="the-contract-interface-abi"><a class="header" href="#the-contract-interface-abi">The contract interface (ABI)</a></h2>
<p>Rust is strongly-typed, yet we need to be able to call an unlimited variety of functions and methods from arbitrary
contracts in a unified, consistent way. This is where the ABI comes in. It defines all the public methods and
their arguments that a contract exposes.</p>
<p>The ABI is generated when a contract template is compiled from Rust source.</p>
<h2 id="the-transaction-manifest"><a class="header" href="#the-transaction-manifest">The transaction manifest</a></h2>
<p>When a client wants to interact with the DAN, it is often the case that she wants to invoke multiple functions
across multiple contracts simultaneously. For example, Alice may want to buy a monkey NFT from Bob. Her transaction
might lock funds in a cryptographic escrow (in the Tari contract) until she has proof that the NFT has landed in her
NFT account (which is in a different contract).</p>
<p>The transaction manifest collects all the information necessary to achieve this goal, including the contract(s)
function(s) to call, their arguments, fee information and all the necessary signature and witness data to authorise the
transaction. The transaction manifest is compiled into an abstract syntax tree (AST) that can be consumed by a
validator node.</p>
<p>Internally, A manifest is simply a list of manifest <em>intents</em> that are bundled together into an atomic whole.</p>
<p>An intent is typically one of the following:</p>
<ul>
<li>A template invocation or component invocation, indicating that the user wants to execute a function on a contract,
supplying the necessary input arguments.</li>
<li>A log entry, providing the log level and message.</li>
</ul>
<h2 id="why-web-assembly"><a class="header" href="#why-web-assembly">Why Web Assembly?</a></h2>
<p>The Smart contract execution environment is incredibly hostile. The runtime is effectively tasked to run <em>arbitrary
code</em> on a global system that has potentially billions of dollars of value at stake.</p>
<p>It is therefore critical that the execution environment does not affect state in the broader network that it is
not entitled to, but also, the code cannot be allowed to jailbreak the execution environment of the validator node
itself and wreak havoc on the host system.</p>
<p>Thus, the runtime environment should</p>
<ul>
<li>be strictly sandboxed,</li>
<li>support multiple concurrent VM without being a resource hog,</li>
<li>have no access to the host system internals, including disk storage, camera, microphones, etc.</li>
<li>be ephemeral and support rapid cold starts.</li>
</ul>
<p>Given these onerous requirements, rather than reinvent the wheel, we considered several existing solutions, including</p>
<ul>
<li>WebAssembly (<a href="https://webassembly.org/">WASM</a>)</li>
<li>Extended Berkeley Packet Filter (<a href="https://en.wikipedia.org/wiki/EBPF">eBPF</a>)</li>
<li>Full virtualisation, such as <a href="https://www.linux-kvm.org/page/Main_Page">KVM</a> or
<a href="https://www.vmware.com/products/workstation-player.html">VmWare</a></li>
</ul>
<p>Full virtualisation was quickly discarded as being too heavy-weight. Validator nodes will be required to swap out
contracts constantly, and so cold-starting a runtime environment must be as lightweight and as fast as possible.</p>
<p>Surprisingly, there were very few options remaining, with eBPF and Wasm being the most mature and closest to our
needs. In fact both runtimes are used in smart-contract execution environments today. WASM is used in Stellar, Near,
Cosmos, Polkadot, Radix and a host of others. eBPF is used in Solana.</p>
<p>We chose WASM for the following reasons:</p>
<ul>
<li>WASM is a mature, well-supported standard. It is supported by the major browsers, which means that trillion-dollar
companies like Google, Microsoft and Apple have a vested interest in its success.</li>
<li>WASM was designed from the ground-up to be a highly performant, lightweight, sandboxed runtime.</li>
<li>There is fantastic tooling to convert Rust, C, Go, and [insert favorite language here] into WASM.</li>
<li>WASM can run almost anywhere, but especially in the browser. Thus, the path to running Dapps safely in the browser
is likely much easier.</li>
</ul>
<p>On the other hand, eBPF was originally design as a packet-filter to protect networks from malicious data packets.
It has since been extended to support a full-blown virtual machine, but it still feels a little like a square peg
being banged into a round hole.</p>
<p>Ultimately, it was a fairly straightforward decision to go forward with WASM.</p>
<p>Independently, <a href="https://stellar.org/blog/developers/project-jump-cannon-choosing-wasm">Stellar</a> reached the same
conclusion, for much the same reasons.</p>
<p>In contrast, while Polkadot does use WASM, there is an
<a href="https://forum.polkadot.network/t/announcing-polkavm-a-new-risc-v-based-vm-for-smart-contracts-and-possibly-more/3811">active discussion</a>
to replace Wasm with RISC-V. This VM is being designed explicitly for smart-contract environments and is worth
watching.</p>
<p>For the time-being, WebAssembly is a pretty clear winner.</p>
<h1 id="change-log-22"><a class="header" href="#change-log-22">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">20 Dec 2023</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0305consensus"><a class="header" href="#rfc-0305consensus">RFC-0305/Consensus</a></h1>
<h2 id="the-tari-network-consensus-layer"><a class="header" href="#the-tari-network-consensus-layer">The Tari Network Consensus Layer</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>,<a href="https://github.com/stringhandler">stringhandler</a></p>
<h1 id="licence-26"><a class="header" href="#licence-26">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-28"><a class="header" href="#language-28">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-28"><a class="header" href="#disclaimer-28">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-27"><a class="header" href="#goals-27">Goals</a></h2>
<p>This Request for Comment (RFC) describe the consensus mechanism known as Cerberus as it is implemented in Tari.
Tari implements the Cerberus variant known as Pessimistic Cerberus, for the most part, with Hotstuff BFT replacing
pBFT as described in the Cerberus paper.</p>
<p>This RFC serves to document any deviations from the academic paper as well as finer-grained details of the
implementation.</p>
<h2 id="related-requests-for-comment-23"><a class="header" href="#related-requests-for-comment-23">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0303_DanOverview.html">RFC-303: Digital Assets Network</a></li>
</ul>
<h2 id="introduction-8"><a class="header" href="#introduction-8">Introduction</a></h2>
<p>The Tari DAN is based on a sharded BFT consensus mechanism called <a href="https://arxiv.org/abs/2008.04450">Cerberus</a>.</p>
<p>One particular note is that Tari has chosen Hotstuff as the base BFT consensus algorithm over pBFT mentioned in the
paper.</p>
<p>The core idea of Cerberus is that instead of dividing work up between validator nodes according to the contracts
they are managing (as per Tari DANv1, Polkadot, Avalanche, etc.), Cerberus distributes nodes evenly over a set of
state slots. Any time an instruction modifies the state of a contract, it will affect one or more state
slot, and only those nodes that are responsible for covering those addresses will reach consensus on the correct
state changes.</p>
<p>This means that nodes have to be prepared to execute instructions on any contract in the network. This
does create a data synchronisation burden, but the added benefit of a highly scalable, decentralised DAN significantly
outweighs this trade-off.</p>
<h2 id="the-consensus-layer-is-logic-agnostic"><a class="header" href="#the-consensus-layer-is-logic-agnostic">The consensus layer is logic agnostic</a></h2>
<p>The first key point to make about the Cerberus layer is that it is <em>logic agnostic</em>. The consensus layer does not
know anything about Tari, about digital assets, or smart contracts. It has one job:</p>
<blockquote>
<p>Ensure that a super-majority of participating nodes agree on the state transition for every Tari transaction.</p>
</blockquote>
<p>Defining the consensus layer in this way allows us to separate the concerns of the consensus layer from the concerns
of the smart contract layer. This is important because it reduces the attack surface of the consensus layer, and allows
us to develop the consensus layer in isolation from the smart contract, or &quot;business logic&quot; layer.</p>
<p>To be clear, if 67% percent of nodes decide that $1 + 1 = 3$ then that is the truth as far as the consensus layer is
concerned.</p>
<p>This job can be subdivided into several smaller, co-ordinated tasks:</p>
<ol>
<li>Deterministic distribution of validator nodes across the state space, to form <strong>validator committees</strong>.</li>
<li>Periodically re-distributing validator nodes across the state space to reduce the likelihood and opportunity for
collusion.</li>
<li>Efficient transmission of consensus messages to the rest of the network.</li>
<li>Identifying and removing malicious nodes from the network.</li>
<li>Correct identification of nodes participating in cross-shard consensus.</li>
<li>Requesting and responding to state requests from other nodes.</li>
<li>Reaching consensus on the state transition for a given transaction.</li>
<li>Effective leader rollover in the case of a faulty leader.</li>
<li>Guaranteeing liveness in the face of a Byzantine stoppage.</li>
</ol>
<h2 id="distribution-of-validator-nodes"><a class="header" href="#distribution-of-validator-nodes">Distribution of validator nodes</a></h2>
<p>Validator node selection and distribution is described in <a href="./RFC-0314_VNCSelection.html">RFC-314</a>. RFC-314 also covers
the periodic re-distribution of validator nodes across the state space.</p>
<h2 id="efficient-transmission-of-consensus-messages-to-the-rest-of-the-network"><a class="header" href="#efficient-transmission-of-consensus-messages-to-the-rest-of-the-network">Efficient transmission of consensus messages to the rest of the network</a></h2>
<p>The Tari communications layer is used to transmit consensus messages to the rest of the network.
The Comms layer is described in <a href="./RFC-0170_NetworkCommunicationProtocol.html">RFC-170</a> and related sub-RFCs.</p>
<div class="note">
TODO:
<ul>
    <li> Describe differences in configuration between the Tari and Minotari networks.</li>
    <li> Describe how VNC members find each other and how they keep in touch.</li>
    <li> Describe how banning or other sanctioning behaviour works.</li> 
    <li> How client messages are propagated and routed to the correct nodes in the network.</li>
    <li> How consensus messages are communicated across the network.</li>
</ul>  
</div>
<h2 id="identifying-and-removing-malicious-nodes-from-the-network"><a class="header" href="#identifying-and-removing-malicious-nodes-from-the-network">Identifying and removing malicious nodes from the network</a></h2>
<p>In the current proposal, malicious nodes are not actively removed from the network. Instead, they can be banned by
peers, as described above, and then de-registered as validator nodes at an epoch transition.</p>
<p>This is still an indirect punishment, since a substantial deposit is required to register as a validator node. After
de-registration, the deposit is locked up for a significant period (3-6 months). Therefore, a serial offender running
bad validator nodes will incur a significant opportunity cost over time.</p>
<p>However, the community is open to other proposals, both game-theoretic and technical, for dealing with malicious
nodes.</p>
<p>Many proof-of-stake systems utilise &quot;slashing&quot; to punish non-cooperative nodes. Slashing mechanisms sound good at
first, but in fact, there are many edge cases that can result in honest-but-poorly-configured nodes being punished.
We are somewhat sceptical that slashing will achieve their intended goals.</p>
<p>Slashing introduces
<a href="https://hedera.com/blog/why-is-there-no-slashing-in-hederas-proof-of-stake">significant additional complexity</a>,<br />
including the need for additional tuning parameters, the need for 'watchtowers' to police the VN
set's behaviour (which is a centralising force), the need for trustless fraud-proofs (a non-trivial problem), and
the fact that software bugs don't follow the rules of economic game-theory (in other words, they're not rational).</p>
<p>Furthermore, slashing is less relevant in a BFT process where safety and liveness is <em>guaranteed</em> as long as 67% of
the committee is honest. The motivation for punishing malicious nodes in Tari is essentially two-fold:</p>
<ul>
<li>to reduce the chance that a critical mass of 1/3 malicious nodes accumulate on the network.</li>
<li>to deter nodes from colluding to try and achieve 33% (to break liveness) or 67% (to break safety).</li>
</ul>
<p>One alternative to slashing os to make <em>all</em> VN deposits non-refundable. Therefore, a malicious node will
implicitly have their deposit slashed once they are banned. Banning can also be made temporary, depending on the
offense. Honest nodes will need to run for a period of time before they become profitable, akin to an 
apprenticeship, or 'paying your dues'. VN fees would be increased to compensate for this mechanism.</p>
<p>Overall, this strategy is very similar to slashing, but is simpler to implement and police.</p>
<p>Another option is to make use of the auditability and fraud-proof properties of Cerberus (See Section
<a href="https://arxiv.org/pdf/1708.03778.pdf">V.B</a> of the Chainspace paper). This would allow retroactive punitive actions
against malicious nodes, and in particular, colluding nodes that act together to subvert an entire validator node
committee. This is an avenue worth exploring, since it's quite clear from the experience of incumbent
proof-of-stake networks, controlling hundreds of billions of dollars of value, that essentially <em>all</em>
slashing events are due to configuration errors or intentional bugs, rather than intentional attempts to bring the
network down.</p>
<h2 id="identification-of-nodes-participating-in-cross-shard-consensus"><a class="header" href="#identification-of-nodes-participating-in-cross-shard-consensus">Identification of nodes participating in cross-shard consensus.</a></h2>
<p>Every validator node is registered on the base layer. Therefore, anyone with a synchronised Minotari node will be in
possession of the current set of validator nodes running the Tari network.</p>
<p>The rules for assigning a given validator node (with its public key) to a Tari shard are deterministic and described
in <a href="./RFC-0314_VNCSelection.html">RFC-314</a>.</p>
<p>It therefore follows that every validator node must also run a Minotari node (or connect to one that they trust).
This will provide all the information that they need to determine which VNs are part of every committee and
therefore which nodes to contact when participating in cross-shard consensus.</p>
<h2 id="requesting-and-responding-to-state-requests-from-other-nodes"><a class="header" href="#requesting-and-responding-to-state-requests-from-other-nodes">Requesting and responding to state requests from other nodes.</a></h2>
<p>State requests come from two primary sources:</p>
<ol>
<li>Other validator nodes requesting state that they need to process an instruction. They will typically request this
state from peers in the braided consensus group as part of a consensus round, although there are opportunities to 
optimise this process through caching and pre-fetching via an Indexer.</li>
<li>Clients (wallets, dApp users etc.) will usually request state from an Indexer that is following the history of a
set of contracts on interest. Indexers are a trusted party. Users wanting to operate in a trustless environment
will need to run their own indexer. Indexers are described in <a href="./RFC-0331_Indexers.html">RFC-331</a>.</li>
</ol>
<h2 id="reaching-consensus-on-the-state-transition-for-a-given-transaction"><a class="header" href="#reaching-consensus-on-the-state-transition-for-a-given-transaction">Reaching consensus on the state transition for a given transaction.</a></h2>
<p>Tari uses Cerberus in conjunction with HotStuff BFT to achieve consensus on substate transitions. This process is
described in detail in <a href="RFC-0330_Cerberus.html">RFC-330</a>.</p>
<h2 id="effective-leader-rollover-in-the-case-of-a-faulty-leader"><a class="header" href="#effective-leader-rollover-in-the-case-of-a-faulty-leader">Effective leader rollover in the case of a faulty leader.</a></h2>
<p>Leader rollover is also covered in  <a href="RFC-0330_Cerberus.html">RFC-330</a>.</p>
<h2 id="guaranteeing-liveness-in-the-face-of-a-byzantine-stoppage"><a class="header" href="#guaranteeing-liveness-in-the-face-of-a-byzantine-stoppage">Guaranteeing liveness in the face of a Byzantine stoppage.</a></h2>
<div class="note">
The final design for liveness guarantees is still under active discussion.
</div>
<p>A liveness break will only occur if at least a third of nodes in a single VNC are actively or passively colluding to
prevent consensus being reached. Successive leader rollovers will have failed to resolve the issue, and the
transaction will become stuck.</p>
<p>Eventually, the entire network will stop functioning even though the network is sharded, because probabilistically,
every contract will eventually produce a state change that required the Byzantine committee to be part of the
consensus.</p>
<p>Therefore, it's critical that liveness can be forced relatively quickly and efficiently.</p>
<p>The basic strategy is that enough nodes vote to force an epoch change. Nodes need to provide proof of recent
activity in order to participate in the new epoch. Nodes that cannot provide proof will be banned and de-registered
as validator nodes.</p>
<p>The epoch change causes a validator node shuffle, and any remaining nodes that may have been preparing to collude
will be assigned new shards.</p>
<h1 id="change-log-23"><a class="header" href="#change-log-23">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">16 Dec 2023</td><td style="text-align: left">Second draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">30 Oct 2023</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-314vnc-selection"><a class="header" href="#rfc-314vnc-selection">RFC-314/VNC Selection</a></h1>
<h2 id="validator-node-committee-selection"><a class="header" href="#validator-node-committee-selection">Validator node committee selection</a></h2>
<p><img src="theme/images/status-outofdate.svg" alt="status: out of date" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">stringhandler</a> and <a href="https://github.com/SWvheerden">SW van heerden</a></p>
<h1 id="licence-27"><a class="header" href="#licence-27">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-29"><a class="header" href="#language-29">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-29"><a class="header" href="#disclaimer-29">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-28"><a class="header" href="#goals-28">Goals</a></h2>
<p>The goal of this RFC is to describe the process for allocating Validator Nodes (VNs) to Validator Node Committees (VNCs)</p>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<p>Validator nodes will have to group themselves into Validator Node Committees (VNC) for transactions/shard processing.
Committees will be formed for each new transaction/shard processing. This committee needs to be determined
pseudo-randomly, and we use the VN_Key as this changes periodically and is pseudorandom. Each VN will be allocated a
unique and individual shard space to serve in as a VNC member.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<p>In order to ensure that VNCs are selected securely and can operate successfully, we pin down the following requirements:</p>
<ol>
<li>A percentage of the nodes must change to a new shard space every epoch (e.g. exactly 25%)</li>
<li>A VN must not be able to determine its own shard space location ahead of time, i.e. the VN only knows it's new
location once the block with the new epoch is mined.</li>
<li>It must be easy, e.g. 𝓞(log n), to calculate the VN set. (You should have to replay all shuffles to calculate the
current VN set).</li>
<li>A VN must be able to be part of a committee for a certain period to allow time to sync state, before being
penalised (if applicable) for not participating in consensus.</li>
<li>Open Question: Should there be a limit (e.g. 10%) in the number of nodes that can join per epoch</li>
</ol>
<h2 id="vn-key-expiry"><a class="header" href="#vn-key-expiry">VN-key expiry</a></h2>
<p>Each new VN will get a <a href="RFC-0313_VNRegistration.html#XXXX">VN-key</a> on registration. This key will expire on some pseudorandom height. This is calculated as
follows:</p>
<p>$$
\begin{aligned}
\text{Expire height} = \text{(Current block height)} + \text{(min expire height)} + \text{new VN-pubkey } MOD \text{ (
max expire height)}
\end{aligned}
$$</p>
<p>Every time a new VN-Key is assigned a new expiry date is calculated. Because the [miner]s calculate the VN-key, they
also calculate the new VN-key every time
it expires.</p>
<h1 id="process-of-choosing-committees-when-an-instruction-needs-to-be-processed"><a class="header" href="#process-of-choosing-committees-when-an-instruction-needs-to-be-processed">Process of choosing committees when an instruction needs to be processed</a></h1>
<p>For each instruction, the substates involved in this instruction <strong>MUST</strong> be known before they can be processed.
For each involved substate, the address of the substate is mapped to a shard. For each shard, the VN committee is
constructed from <code>COMMITTEE_SIZE/2</code> VNs to the left and right of the shard,
in the [VNKey Merkle tree].</p>
<p>Thus, a single instruction will have a maximum N * <code>COMMITTEE_SIZE</code> validator nodes processing it, when N is the number
of involved substates.</p>
<h2 id="committee-creation"><a class="header" href="#committee-creation">Committee Creation</a></h2>
<div class="note">
This section is out of date
</div>
<p>Because we have the base layer where each VN needs to publish a registration transaction, we can get base_node and
miners to keep track of all active VNs. We represent all VNs in a (balanced) Merkle tree with the VN_keys as leaves. We
declare a constant <code>COMMITTEE_SIZE</code> which can be changed in the consensus constants.</p>
<p>For the sake of simplicity, <code>COMMITTEE_SIZE</code> MUST be an even positive integer.</p>
<p>As per the Cerberus algorithm, validator nodes are responsible for managing <em>sub-states</em>, rather than contract
semantics.
A given instruction may involve dozens of sub-states, meaning that there are potentially dozens of non-overlapping
committees that are required to reach a braided consensus.</p>
<p>Each committee is determined independently. For each sub-state, a committee is formed by taking the
first  <code>COMMITTEE_SIZE / 2</code> VN_keys to the left and <code>COMMITTEE_SIZE / 2</code> VN_Keys to the right of the sub-state's shard
address in the merkle tree.</p>
<p>This makes it very easy to determine what shard space a VN needs to serve, which states the VN needs to sync from peers,
and who has them. Because the
second layer has a delayed view of the network. VNs can also know beforehand and prep to ensure they are ready when new
block heights appear.</p>
<p>An important edge case here that is implied but not listed, is that if the whole network is less or equal to
the <code>COMMITTEE_SIZE</code>, then the whole network participates in the VNC.</p>
<h2 id="committee-proofs"><a class="header" href="#committee-proofs">Committee proofs</a></h2>
<p>We construct the balanced Merkle tree from all active VN registration transactions and prune away all inactive ones.
Because the <a href="Glossary.html#base-node">base node</a>s have to keep track
of the entire unspent UTXO set, it becomes easy for them to track and validate all active VN registration UTXOs. This
means we can keep <a href="Glossary.html#base-node">base node</a>s
responsible for validating and constructing the Merkle tree. We commit this Merkle tree per block as a Merkle root
inside the block's header as the <code>validator_node_set_root</code>.</p>
<p>This Merkle root in the header always lags by one block, meaning that the Merkle root is for the state of the VN's
before the start of the block it's mined in.
When a VN registers, that new VN key will only appear inside the Merkle tree in the next block. The reason for this is
that header_hash is used in the
the calculation process of the VN_key.</p>
<h3 id="option-2-for-committee-proofs"><a class="header" href="#option-2-for-committee-proofs">Option 2 for Committee proofs</a></h3>
<p>The VN_key needs some random entropy that's not minable to ensure that a VN cannot choose its VN_key. This random
entropy is currently the block hash of the
block the VN registration was mined in. Hence the reason for the Merkle root lagging by one block. If we change this
entropy value be another source of
randomness, such as the <code>utxo_merkle_root</code>, then we don't have to do the lag by 1, and it can all be calculated in the
single block.</p>
<h2 id="leader-selection"><a class="header" href="#leader-selection">Leader selection</a></h2>
<p>The VNC leader should not be decided beforehand and must be chosen pseudorandomly only when a tx is published. We also
need to select an order of leaders
in the case, the first leader is offline/and or not responsive.</p>
<p>$$
\begin{aligned}
vn_position_hash(vn, tx) = Hash(vn.signing_key || hash(tx))
\end{aligned}
$$</p>
<p>This will give a sortable list we use to order the VNs for leader selection.</p>
<h1 id="change-log-24"><a class="header" href="#change-log-24">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">11 Oct 2022</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvHeerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0321processingforeignproposals"><a class="header" href="#rfc-0321processingforeignproposals">RFC-0321/ProcessingForeignProposals</a></h1>
<h2 id="processing-foreign-proposals"><a class="header" href="#processing-foreign-proposals">Processing Foreign Proposals</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">stringhandler</a></p>
<h1 id="licence-28"><a class="header" href="#licence-28">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-30"><a class="header" href="#language-30">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-30"><a class="header" href="#disclaimer-30">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-29"><a class="header" href="#goals-29">Goals</a></h2>
<p>This RFC describes the process of distributing and processing foreign proposals in the Tari DAN Cerberus Model</p>
<p>Across the entire network transactions must be processed or time out. When a transaction is started on a shard, it locks up substates, preventing other transactions from completing. Therefore if a transaction is started on a shard, it
should complete or be aborted in a timely manner to release the resources.</p>
<h2 id="related-requests-for-comment-24"><a class="header" href="#related-requests-for-comment-24">Related Requests for Comment</a></h2>
<!-- * [RFC-0111: Base Node Architecture](./RFC-0111_BaseNodeArchitecture.md) -->
<p>None</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li>Block - A second layer block, consisting of ordered commands</li>
<li>Command - Command can either be Prepare, LocalPrepared, Accept, and moves a transaction into that state.</li>
</ul>
<h2 id="description-15"><a class="header" href="#description-15">Description</a></h2>
<p>To solve the above problems, we'll use reliable broadcast between shards and process foreign evidence in order.</p>
<p>In a local shard committee, the proposed block <strong>must</strong> include a reliable broadcast counter for each other shard. If the proposal includes transactions that involve other shards, this counter <strong>must</strong> be incremented.
At the beginning of each epoch, all reliable broadcast counters must be reset.</p>
<p>When the proposed block becomes committed locally (i.e. it has a chain of 3 QCs validating it), the block <strong>must</strong> be broadcast to each involved shard that was incremented, along with evidence of being committeed (The chain of QCs must be included).</p>
<p>To ensure this, <code>f+1</code> nodes in the local committee will forward this committed block to each relevant committee, along with a 3 chain of QC's proving it was committeed.</p>
<p>As a local committee member, when I receive a foreign proposal, if it is valid I will queue up a special command ForeignProposal(number, QC_Hash) that I must propose
when I am next leader (if it has not been proposed already). I also <strong>should</strong> request all transaction hashes that I have not seen from involved_shards for each transaction in the proposal, and add them to my mempool for execution.</p>
<p>When processing transactions from a foreign, there are two methodologies we can try.</p>
<ol>
<li>Strict ordering</li>
<li>Relaxed ordering</li>
</ol>
<h3 id="strict-ordering"><a class="header" href="#strict-ordering">Strict ordering</a></h3>
<p>In strict ordering, before transactions in the <code>N+1</code>th foreign proposal for a shard, all transactions in the <code>N</code>th foreign proposal for that shard must be sequenced into the local chain as either a ABORT(reason = Timeout) or a LOCALPREPARE(TxId, ForeignShardId).
This means that if a transaction is going to timeout, it will hold up all transactions in future proposals. While timeouts are expected to be rare when at least one honest node is able to provide the transaction, this approach could lead to
really long finalization times, slowing down all cross shard transactions. In addition, there may be potential for deadlocks, where state is locked for a long time while transactions wait to timeout.</p>
<h3 id="relaxed-ordering"><a class="header" href="#relaxed-ordering">Relaxed ordering</a></h3>
<p>In relaxed ordering, transactions from foreign proposals can be processed in any order, but transactions must still timeout if they are not processed after a certain number of blocks from the FOREIGN_PROPOSAL command. This could lead to some
strange behaviour where a transaction can be aborted due to double spends, even though the double spend happens much later in one shard. This however could happen even with strict ordering if the transactions arrive at different times.</p>
<p>Given the above, we shall use relaxed ordering unless future development reveals other problems.</p>
<p>NOTE: ForeignProposal commands can be proposed in between a previous ForeignProposal and LocalPrepare/Timeout commands, but commands from the ForeignProposal <strong>must</strong> only be proposed after all transactions in the first ForeignProposal have been sequenced.
The TIMEOUT_TIME block is counted from the height where the ForeignProposal is sequenced.</p>
<p>ForeignProposal commands <strong>must</strong> appear in strict ascending order in the blockchain, but do not have to be in sequential blocks. In other words, for shard <em>s</em>, the block containing ForeignProposal(<em>s</em>, 1) must have a height lower than ForeignProposal(<em>s</em>, 2). Also, if a chain contains ForeignProposal(<em>s</em>, 1) and ForeignProposal(<em>s</em>, 3), then it <strong>must</strong> also contain ForeignProposal(<em>s</em>, 2).</p>
<p>If a node receives a foreign proposal (not the command), and it has not received
the previous foreign proposal, then it should ask the committee to provide it to them.</p>
<h1 id="change-log-25"><a class="header" href="#change-log-25">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 Nov 2023</td><td style="text-align: left">First draft</td><td style="text-align: left">stringhandler</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0325danepochmanagement"><a class="header" href="#rfc-0325danepochmanagement">RFC-0325/DanEpochManagement</a></h1>
<h2 id="epochs-and-time-management"><a class="header" href="#epochs-and-time-management">Epochs and time management</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/SWvheerden">SW van Heerden</a></p>
<h1 id="licence-29"><a class="header" href="#licence-29">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-31"><a class="header" href="#language-31">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-31"><a class="header" href="#disclaimer-31">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-30"><a class="header" href="#goals-30">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the role of Epochs and time management on the DAN.</p>
<h2 id="related-requests-for-comment-25"><a class="header" href="#related-requests-for-comment-25">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0303_DanOverview.html">RFC-0303: The Digital Assets Network Overview</a></li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>For stability and security in the <a href="RFC-0314_VNCSelection.html#Intro">VNC</a>s we have the following requirements:</p>
<ul>
<li>We need to know who the valid and active <a href="RFC-0XXX.html">VN</a>s are.</li>
<li><a href="RFC-0314_VNCSelection.html#Intro">VNC</a>s need to be periodically shuffled to prevent shard targeting attacks.</li>
<li><a href="RFC-0314_VNCSelection.html#Intro">VNC</a> members cannot be swapped on a whim and need to be stable to allow members to vote on and process instructions.</li>
<li>Chain re-organisations on the Minotari chain should not have an effect on the <a href="RFC-0314_VNCSelection.html#Intro">VNC</a> distribution.</li>
<li>When swapping <a href="RFC-0XXX.html">VN</a>s from one [shard] to another, the <a href="RFC-0XXX.html">VN</a> has enough time to sync the required state before the
swapping takes effect.</li>
<li>When swapping <a href="RFC-0XXX.html">VN</a>s from one [shard] to another, the <a href="RFC-0314_VNCSelection.html#Intro">VNC</a> must retain enough members so as to keep functioning.</li>
</ul>
<h2 id="dan-lag"><a class="header" href="#dan-lag">DAN Lag</a></h2>
<p>Because the <a href="Glossary.html#base-layer">Minotari</a> chain influences the DAN layer and is used as a timing mechanism for the DAN, we need to ensure
that the DAN has a stable view of the <a href="Glossary.html#base-layer">Minotari</a>.</p>
<p>The <a href="Glossary.html#base-layer">Minotari</a> is built on Proof-of-Work and this means that chain might undergo re-organisation. We need to ensure
that re-orgs do cause a <a href="RFC-0314_VNCSelection.html#Intro">VNC</a> reshuffle. We introduce a concept called <code>DAN Lag</code> which is an offset between when a
<a href="RFC-0314_VNCSelection.html#Intro">VNC</a> change is recorded on the Minotari chain and when it takes effect.</p>
<p>For example, if we define <code>DAN Lag</code> as 720 blocks, or a day. Then when a VN registers and that transaction is
mined in the <a href="Glossary.html#base-layer">Minotari</a> at height 1000 then only at height 1720 will the DAN Layer recognise the <a href="RFC-0XXX.html">VN</a> as being
registered.</p>
<p>This <code>DAN Lag</code> allows the <a href="Glossary.html#base-layer">Minotari</a> chain to have small re-orgs of less than the <code>DAN Lag</code> without it having any
effect on the DAN Layer.
An added benefit of this is that the DAN Layer knows all changes in advance of when it will happen, so when a <a href="RFC-0XXX.html">VN</a> is
swapped to a new <a href="RFC-0304-DanGlossarymd#Consensus-level">shard space</a> it will give it the <code>DAN Lag</code> period to sync the required state.</p>
<h2 id="dan-grace-time"><a class="header" href="#dan-grace-time">DAN Grace Time</a></h2>
<p>Minotari nodes are decentralized. Thus, we don't have a single point of view of the state of the chain.</p>
<p>The DAN operates in ms timeframes, while the <a href="Glossary.html#base-layer">Minotari</a> chain runs at the minute timeframe, averaging 2 minutes per
block. These blocks also take a few seconds to process and propagate through the network.</p>
<p>This means that for some <a href="RFC-0XXX.html">VN</a>s the <a href="Glossary.html#base-layer">Minotari</a> block height might be 999, while for others it might be 1000. The
practical problem for this is that we cannot base consensus decisions on the block height if the <a href="RFC-0XXX.html">VN</a>s cannot come to
some consensus as to what the <a href="Glossary.html#base-layer">Minotari</a> height is.</p>
<p>We define <code>DAN Grace Time</code> or DGT as the number of blocks in the past or future of the <a href="RFC-0XXX.html">VN</a>'s own current block height,
that it will accept. This is very similar to the <a href="RFC-0120_Consensus.html#FTL">FTL</a> concept concerning the timestamp in the block header.</p>
<p>In example of this would be, that we have <code>VN_1</code> whose <a href="Glossary.html#base-node">base node</a> is on height 999 and <code>VN_2</code> whose <a href="Glossary.html#base-node">base node</a> is on
height 1000. We have set the DGT as 1.
An instruction has specified that from height 1000 the <a href="RFC-0314_VNCSelection.html#Intro">VNC</a> that must process it contain both <code>VN_1</code> and <code>VN_2</code>, but
before that it is only <code>VN_1</code>. From this it can be seen that <code>VN_1</code> thinks only it must be in the <a href="RFC-0314_VNCSelection.html#Intro">VNC</a> but <code>VN_2</code>
thinks they both need to be. But using the DGT of 1 block, <code>VN_1</code> will accept <code>VN_2</code> as part of the <a href="RFC-0314_VNCSelection.html#Intro">VNC</a>
because it is withing the DGT period and it assumes that its own <a href="Glossary.html#base-node">base node</a> is simply lagging 1 block.</p>
<p>The DGT has the additional benefit of allowing a <a href="RFC-0XXX.html">VN</a> to finish processing an instruction after a block height has been
reached.</p>
<p>With the example mentioned above if <code>VN_1</code> has to stop processing an instruction at height 1000, but it started the
instruction at height 999. When height 1000 comes
along it can still continue to process the instruction till height 1001.</p>
<h2 id="vn-epoch"><a class="header" href="#vn-epoch">VN Epoch</a></h2>
<p>We define <code>VN Epoch</code> as the time period a <a href="RFC-0XXX.html">VN</a> must serve in a single [shard] before being moved to a different
[shard]. The purpose of this shuffling is to prevent having a single <a href="RFC-0314_VNCSelection.html#Intro">VNC</a> cover the same shard for an extended
period of time and thus reduce the risk of VN collusion.</p>
<p>The shuffling algorithm can be linked to the <a href="RFC-0XXX.html">VN registration</a> hash. This provides a random and uniformly 
distributed seed that allows us to shuffle the <a href="RFC-0XXX.html">VN</a>s around the <a href="RFC-0304-DanGlossarymd#Consensus-level">shard space</a> in a deterministic way. The algorithm 
can also be constructed such that a minority of nodes are shuffled at every epoch, while still maintaining 
equal-sized VNCs.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>VNs must re-register periodically. This is to ensure that the <a href="RFC-0XXX.html">VN</a>s are still active and to prevent a <a href="RFC-0XXX.html">VN</a> from
registering once and then never being removed from the VN registry. A new <a href="RFC-0304-DanGlossarymd#Consensus-level">shard key</a> is generated each time that a 
VN re-registers. </p>
<p>(Open question: Is the re-registration fee cheaper than the initial registration fee? Is it zero?)</p>
<p>VNs that miss their re-registration deadline will automatically be de-registered. (Open question: Is the 
registration deposit lost in this case?)
Therefore it is always possible to maintain a list of recently active VNs.</p>
<p>The <code>DAN Lag</code> gives <a href="RFC-0XXX.html">VN</a>s enough time to sync their new shard's state. </p>
<p><a href="RFC-0XXX.html">VN</a> are shuffled periodically, but a minority of nodes are shuffled every epoch.</p>
<h2 id="tuning-the-values"><a class="header" href="#tuning-the-values">Tuning the values</a></h2>
<p>We need to ensure that all the consensus values defined in the RFC needs to be tuned with the following in mind:</p>
<h3 id="dan-lag-1"><a class="header" href="#dan-lag-1">DAN Lag</a></h3>
<p>The <code>DAN Lag</code> must be long enough that small frequent re-orgs dont have an effect on the DAN layer. This must also be
long enough to give any new <a href="RFC-0XXX.html">VN</a> ample time to download any required state for [shard] it will cover.</p>
<h3 id="dan-grace-time-1"><a class="header" href="#dan-grace-time-1">DAN Grace Time</a></h3>
<p>This must be only a block or two. This is just to handle the edge case of what happens if a <a href="RFC-0XXX.html">VN</a>'s node has not yet seen
a new height, or the height changes while processing an instruction</p>
<h3 id="vn-epoch-1"><a class="header" href="#vn-epoch-1">VN Epoch</a></h3>
<p>This must be long enough so that <a href="RFC-0XXX.html">VN</a>s don't flood the network with sync requests and are able to spend most of their 
time processing instructions. 
It must clearly be longer than the <code>DAN Lag</code>. </p>
<p>It must be short enough that we don't allow <a href="RFC-0XXX.html">VN</a>s to collude and carry out sharding attacks. </p>
<p>The epoch must also be short enough that we can effectively remove inactive <a href="RFC-0XXX.html">VN</a>s from the <a href="RFC-0XXX.html">VN</a> registry.</p>
<h2 id="change-log-26"><a class="header" href="#change-log-26">Change Log</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">19 Oct 2022</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvHeerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0330cerberus"><a class="header" href="#rfc-0330cerberus">RFC-0330/Cerberus</a></h1>
<h2 id="the-tari-cerberus-hotsuff-consensus-algorithm"><a class="header" href="#the-tari-cerberus-hotsuff-consensus-algorithm">The Tari Cerberus-Hotsuff Consensus Algorithm</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>,<a href="https://github.com/stringhandler">stringhandler</a></p>
<h1 id="licence-30"><a class="header" href="#licence-30">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-32"><a class="header" href="#language-32">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-32"><a class="header" href="#disclaimer-32">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-31"><a class="header" href="#goals-31">Goals</a></h2>
<p>This Request for Comment (RFC) describe the consensus mechanism known as Cerberus as it is implemented in Tari.
Tari implements the Cerberus variant known as Optimistic Cerberus, for the most part, with Hotstuff BFT replacing
pBFT as described in the Cerberus paper.</p>
<p>This RFC serves to document any deviations from the academic paper as well as finer-grained details of the
implementation.</p>
<h2 id="related-requests-for-comment-26"><a class="header" href="#related-requests-for-comment-26">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0303_DanOverview.html">RFC-303: Digital Assets Network</a></li>
</ul>
<h2 id="introduction-9"><a class="header" href="#introduction-9">Introduction</a></h2>
<p>The Tari DAN is based on a sharded BFT consensus mechanism called <a href="https://arxiv.org/abs/2008.04450">Cerberus</a>.</p>
<p>One particular note is that Tari has chosen Hotstuff as the base BFT consensus algorithm over pBFT mentioned in the
paper.</p>
<p>The core idea of Cerberus is that instead of dividing work up between validator nodes according to the contracts
they are managing (as per Tari DANv1, Polkadot, Avalanche, etc.), Cerberus distributes nodes evenly over a set of
state slots, called substates. Any time an instruction modifies the state of a contract, it will affect one or more
substates, and only those nodes that are responsible for covering those addresses will reach consensus on the correct
state changes.</p>
<p>This means that nodes have to be prepared to execute instructions on any contract in the network. This
does create a data synchronisation burden, but the added benefit of a highly scalable, decentralised DAN significantly
outweighs this trade-off.</p>
<h2 id="shards-substates-and-state-addresses"><a class="header" href="#shards-substates-and-state-addresses">Shards, substates and state addresses</a></h2>
<p>The central idea of Cerberus is that all possible state objects are assigned a unique address, deterministically.
Know the provenance of the state, know the address <sup class="footnote-reference"><a href="#1">1</a></sup>. The state space is incredibly large, with 2^256 possible 
substate addresses;
which is way more than the number of atoms in our galaxy.
The chance of any two pieces of state ever trying to occupy the same substate is vanishingly small.</p>
<p>The state space is also evenly divided into contiguous sections, called shards. Each shard covers a set of
non-overlapping substate addresses and the full set of shards covers the entire state space.</p>
<p>Each validator node registered on the base layer is randomly assigned a shard to cover. The number of shards
depends on the total number of validator nodes in the network.</p>
<p>Collectively, all the nodes covering the same shard are known as a <em>validator (node) committee</em> (VNC).</p>
<p>Broadly speaking, the shard-assignment algorithm will try to arrange things in a way that every shard has the same
number of validator nodes covering it.</p>
<p>The number of nodes in a VNC is set system-wide. The final number has not been determined yet, but it will be a
value, 3n+1, where n is an integer between 8 and 33, giving a committee size of between 25 and 100 nodes.</p>
<p>As nodes continue to join the network, the target committee size stays fixed, whereas the shard size will shrink.
This is what will allow the Tari network to scale to achieve
<a href="https://www.tari.com/updates/2023-09-11-update-117">thousands of transactions per second</a>.</p>
<p>Every substate slot can only be used once. The substate lifecycle is</p>
<ul>
<li><code>Empty</code>. No state has ever been stored in this slot.</li>
<li><code>Up</code>. A transaction output has resulted in some object being stored in this substate slot.</li>
<li><code>Down</code>. The state in this slot has changed. We mark the substate as 'down' to indicate that the state is no longer
valid. Once a substate is down, it can never be used again <sup class="footnote-reference"><a href="#2">2</a></sup>.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This is a simplification to convey the general idea. The address derivation procedure is explained in full below.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>It's possible that substates could be reset, decades in the future, if substate address collisions
become a risk. For now, we treat all down substates as permanently unusable.</p>
</div>
<h2 id="braided-consensus"><a class="header" href="#braided-consensus">Braided consensus</a></h2>
<p>A question that naturally arises whenever sharded distributed networks are discussed is, what happens when
cross-shard communication happens. With Cerberus, the procedure is that affected shards come together to form a
temporary Hotstuff consensus group, and reach agreement on the correct outcome of the instruction.</p>
<p>A correct outcome is one of:</p>
<ul>
<li><code>Abort</code>: The instruction was invalid, and any state changes are rolled back such that the instruction never happened.</li>
<li><code>Commit</code>: All input substates for the instruction will be set to <code>Down</code>, and at least one new substate will be
marked to <code>Up</code> (from <code>Empty</code>).</li>
</ul>
<p>Achieving this outcome entails a fairly complicated dance between the participating nodes<sup class="footnote-reference"><a href="#3">3</a></sup>:</p>
<ul>
<li>When nodes receive an instruction that affects contract state, the nodes determine the <em>input substates</em> that will
be consumed in the instruction. This substates MUST currently <em>all</em> be in an <code>Up</code> state. If any input state is
<code>Empty</code>, or <code>Down</code>, the nodes can immediately vote <code>Abort</code> on the instruction.</li>
<li>Assuming all input states are valid, nodes will then <em>pledge</em> these substates, effectively marking them as pending
<code>Down</code>.</li>
<li>Then we have cross-shard exchange. Every leader for the round will forward the instruction and the pledged states
to all other nodes in the wider consensus group.</li>
<li>Nodes wait until they have received the transaction and pledges from all the other committee leaders. Otherwise
they time-out, and ???.</li>
<li>Once this is complete, and all pledges have been received, nodes decide within their local committee whether to
<code>Commit</code> or <code>Abort</code>. This procedure proceeds via Hotstuff consensus rules and takes several rounds of
communication between the local leader and the committee members.</li>
</ul>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>For a more formal treatment, refer to Pessimistic-Cerberus in the
<a href="https://arxiv.org/abs/2008.04450">Cerberus paper</a>.</p>
</div>
<h2 id="cerberus-consensus---a-diagram"><a class="header" href="#cerberus-consensus---a-diagram">Cerberus consensus - a diagram</a></h2>
<p>Transaction processing for Pessimistic Cerberus follows the following broad algorithm:</p>
<ol>
<li>A client broadcasts a transaction to multiple validator nodes, ensuring that at least one node from every shard
that covers the inputs for the transaction receives the transaction. In practice, this can be achieved by
communicating with a single node, and the node shoulders the responsibility of broadcasting the transaction to
the rest of the network, including to every node in the node's local VNC.</li>
<li>When a transaction is received by a validator node, it checks to see if at least one input for the transaction is
in the node's shard space. If not, it may ignore the transaction. Otherwise, it forwards the message to the
current round leader.</li>
<li>Soon, every round leader for the shards that contain affected inputs will have received the transaction.</li>
<li>The affected shards then begin the <em>local consensus</em> phase. This consists of a full Hotstuff consensus chain with
the leader proposing a new block containing the transaction, and the committee members voting on the block.</li>
<li>At the same time, all local inputs (the subset of transaction inputs covered by the local shard) are marked as
<code>Pledged</code>. If any input is already marked as <code>Pledged</code>, the transaction immediately resolves as <code>Abort</code>. This step
prevents double-spending of inputs across concurrent transactions in separate shards. Note that if a double-spend
is attempted by submitting the two transactions to different shards, then <em>both</em> transactions will be aborted, since
Cerberus does not have a way to determine which transaction was 'first'.</li>
<li>If <em>every</em> input is in a single shard, then the local consensus is sufficient to finalise the outcome of the
transaction (proceeding to execution phase as described below), and the result can be broadcast to the client.</li>
<li>Otherwise, the leader of the round broadcasts the transaction, some metadata, and the local input state to the
other shards leaders involved in the transaction. Notice that up until this point, <em>execution</em> of the transaction is
impossible in a multi-shard transaction because no node has all the input state it needs to run the transaction
instruction. The local consensus phase is solely to determine the validity of the transaction from an input and
double-spend perspective.</li>
<li>When every shard leader has received a message from every other shard leader participating the transaction, and
none of the messages received was <code>Abort</code>, then the shards can begin the <em>global consensus</em> phase.</li>
<li>Round leaders transmit the received messages to the rest of their VNC.</li>
<li>Each VN checks that the state received from each foreign shard corresponds to the inputs in the transaction. If
not, the VN can immediately vote <code>Abort</code>.</li>
<li>At this point, the shard leaders have all the state they need to execute the transaction. Execution is handed off
to the TariVM which returns a new set of state objects as output. It is important to note that if a transaction
<em>execution</em> returns an error (because someone tried to spend more than they have, for example), then this _does
not lead to an <code>Abort</code> decision!`</li>
<li>Each shard executes the transaction independently, and another Hotstuff consensus chain is produced to achieve
consensus on the resulting output set. If the transaction is <code>Abort</code>, then all pledged inputs are rolled back.
Otherwise, the decision is <code>Commit</code>, and the pledged inputs are marked as <code>Down</code>. Any output objects that belong
in the current shard can be marked as <code>Up</code>, and the transaction result is broadcast to the client as well as
other shards that need to mark new substates as <code>Up</code> as a result of the transaction output.</li>
</ol>
<p>A mermaid flow diagram of the above process is shown below:</p>
<pre class="mermaid">
flowchart TD
    A[Client] --&gt; B([Broadcast transaction])
    B --&gt; C{Any tx inputs in my shard?}
    C --&gt; |Yes| D[Forward to leader]
    C --&gt; |No| E[Ignore transaction]
    D -.-&gt; L
    
    L[Leader] ==&gt; BL([ Broadcast message to VNC ])
    BL -.-&gt; |PREPARE| LN[VNC nodes]
    subgraph Local_Consensus
        LN --&gt; G{Any inputs already pledged?}    
        G --&gt; |Yes. 
        Vote PREPARED_ABORT | LC
        
        G --&gt; |No| I[Pledge inputs]
        I --&gt; |Vote PREPARED_COMMIT| LC[[Consensus on pledges]]
        LC --&gt; LCD{Consensus on PREPARED?}
        LCD --&gt; |No| LocalStall[Local liveness break!]
    end
        
    
    LCD --&gt; |Yes| Pledge[Pledge inputs]
    Pledge --&gt; SS{ Single shard tx? }
    SS --&gt; |Yes| EX1[[Execute transaction]]
    EX1 --&gt; SSC[[Consensus on result]]
    SSC --&gt; GCD
    
    ssCommit --&gt; |No| Abort[Abort!] 
    ssCommit --&gt; |Yes| createSubstates[[Substate creation]]
    
    SS -.-&gt; |No| BLC([ Send LOCAL_PREPARED_*
     &amp; local state to other Leaders ])
    BLC -.-&gt; Leaders
    Leaders -.-&gt; |Forward to VNC| Fwd[Validator node]
    
    subgraph Global_consensus
        Fwd --&gt; wait{Are ANY messages 
        LOCAL_PREPARED_ABORT or
        timed out? }
        wait --&gt; |Yes
        Vote SOMEPREPARED_ABORT| globalConsensus
        wait --&gt; |No| EX[[Execute transaction]]
        
        EX --&gt; |Vote ACCEPT_*| globalConsensus[[Intershard Consensus on result]]
    end
    globalConsensus --&gt; GCD{Consensus on ACCEPT_*?}
    GCD --&gt; |No.| Stall[Abandon block!]
    GCD--&gt; |Yes| ssCommit{Decision == ACCEPT_COMMIT?}
</pre>
<p>The process above describes PCerberus in general, with some modifications from <a href="https://arxiv.org/pdf/1708.03778.pdf" title="Chainspace whitepaper">Chainspace</a>. There are a few details
that need some additional explanation. In particular, this includes substate address derivation and state
synchronisation.</p>
<h2 id="substate-address-derivation"><a class="header" href="#substate-address-derivation">Substate address derivation</a></h2>
<p>A substate contains two pieces of information:</p>
<ul>
<li>The value of the substate object,</li>
<li>The version number of the substate object.</li>
</ul>
<p>The <em>substate address</em> is the universal location of the substate in the 256-bit state space. Most substate addresses
are derived from a hash of their id, the provenance of which depends on the substate value type, and their version.</p>
<p>The substate value depends on the type of data the value represents. It is exactly one of the following:</p>
<ul>
<li>Component - A component is an instantiation of a <a href="RFC-0303_DanOverview.html#templates">contract template</a>.</li>
<li>Resource - A resource represents a token. Tokens can be fungible, non-fungible, or confidential. The <code>Resource</code>
substate does not store the tokens themselves, but serves as the global identifier for the resource. The tokens
themselves are kept in <code>Vaults</code>, or <code>NonFungible</code> substates.</li>
<li>Vault - Resources are stored in Vaults. Vaults provide generalised functionality for depositing and withdrawing
their resources from the vaults into Buckets.</li>
<li>NonFungible - A substate representing a singular non-fungible item. Non-fungible items are always associated with
their associated non-fungible <code>Resource</code>.</li>
<li>NonFungibleIndex - A substate that holds a reference to another substate.</li>
<li>UnclaimedConfidentialOutput - A substate representing funds that were burnt on the Minotari layer and are yet to
be claimed in the Tari network.</li>
<li>TransactionReceipt - A substate recording the result of a transaction.</li>
<li>FeeClaim - To prevent a proliferation of dust-like value transfers for every transaction due to fees, a fee claim is
generated instead that allows VNs to aggregate fees and claim them in a single batched transaction at a later time.
Fee claims remain in the up state forever to prevent double claims.</li>
</ul>
<p>Substate ids are domain-separated hashes of their identifying data, which depends on substate type as follows:</p>
<ul>
<li>Component - Component addresses are derived from the hash of the component's contract template id and a component
id. The component id is typically a hash of the origin transaction's hash and a counter.</li>
<li>Resource - Generally a unique, random 256-bit integer, derived from the hash of the transaction hash and a counter.
Some ids for special resources are hard-coded.</li>
<li>Vault - Vault ids are a unique, random 256-bit integer, derived from the hash of the transaction hash and a counter.</li>
<li>NonFungible - The id of a non-fungible item is derived from the item's resource address, and its id. The id
depends on the specifics of the NFT, and could be an integer, a string, a hash, or a uuid.</li>
<li>NonFungibleIndex - Non-fungible index ids are derived from the resource they are pointing to and an index offset.</li>
<li>UnclaimedConfidentialOutput - The UCO id is derived from the burn commitment on the Minotari layer.</li>
<li>TransactionReceipt - The id of a transaction receipt is the hash of the associated transaction.</li>
<li>FeeClaim - The id of a fee claim is derived from the epoch number and the validator's public key.</li>
</ul>
<h2 id="state-synchronisation"><a class="header" href="#state-synchronisation">State synchronisation</a></h2>
<h1 id="change-log-27"><a class="header" href="#change-log-27">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 Dec 2023</td><td style="text-align: left">Second draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">30 Oct 2023</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0304consensus"><a class="header" href="#rfc-0304consensus">RFC-0304/Consensus</a></h1>
<h2 id="the-tari-network-consensus-layer-1"><a class="header" href="#the-tari-network-consensus-layer-1">The Tari Network Consensus Layer</a></h2>
<p><img src="theme/images/status-raw.svg" alt="status: raw" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">stringhandler</a>, <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-31"><a class="header" href="#licence-31">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-33"><a class="header" href="#language-33">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-33"><a class="header" href="#disclaimer-33">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-32"><a class="header" href="#goals-32">Goals</a></h2>
<p>This Request for Comment (RFC) describes operation of Tari network Indexers. Indexers are a key actor in providing
rapid, up-to-date and accurate information about the state of Tari contracts to client applications.</p>
<h2 id="related-requests-for-comment-27"><a class="header" href="#related-requests-for-comment-27">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0303_DanOverview.html">RFC-303: Digital Assets Network</a></li>
</ul>
<h2 id="introduction-10"><a class="header" href="#introduction-10">Introduction</a></h2>
<p>Since the Tari network is designed to scale to hundreds of thousands of contracts, and millions of transactions per
hours, having a global state tracking system, like Etherscan, is neither feasible nor advisable. Instead, client
applications (wallets, ticket apps, exchange front-ends etc) will run an <em>Indexer</em> that follows the state of a
finite set of contracts of interest all across the shard-space.</p>
<div class="note">
A note on nomenclature: This RFC is primarily focused on the role of <code>indexer_lib</code> in the DAN source 
code. 
<p>The indexer application has additional functionality (such as a copy of the Tari engine for executing dry runs of
transactions) that is outside the domain of what the indexer is responsible for: maintaining a database of contract
state, and delivering that state to client applications.
</div>
<p>You can think of Validator nodes as staying in position and managing the state of a fixed set of addresses, possibly
having to operate instructions for thousands of different contracts, while Indexers are constantly hopping around the
shard-space, following the progress of a fixed set of contracts wherever their state goes.</p>
<p>Figure 1 illustrates this dynamic:</p>
<p><img src="./assets/indexer_vs_vn.jpg" alt="Figure 1: Validator and Indexer" /></p>
<p>The indexer library work via three inter-oparting modules: substate scanning, substate decoding, and the substate 
cache.</p>
<h3 id="substate-scanning"><a class="header" href="#substate-scanning">Substate scanning</a></h3>
<p>Given a substate address, the indexer will obtain the state for that substate, if it exists, using the following
algorithm:</p>
<ol>
<li>If the substate is in the cache, retrieve the cached value. Query the network for the next version, and if it
does not exist, return the cached version.</li>
<li>If the cache misses, or the network indicates that the cache is stale because the next version does exist then:
<ol>
<li>If the next substate version's state is <code>UP</code>, update the cache and return the substate.</li>
<li>Otherwise, if the next substate version's state is <code>DOWN</code>, query the network until the current version is found.</li>
<li>If the cache misses, and the network indicates that the substate does not exist, then the substate address is
not valid.</li>
</ol>
</li>
<li>After retrieving the latest version from the network, update the cache before returning the substate.</li>
</ol>
<h3 id="substate-decoding"><a class="header" href="#substate-decoding">Substate decoding</a></h3>
<p>The substate decoding module decodes the state at a given substate address, and collects any referenced substate
addresses contained within. This is done recursively until all substates have been decoded.</p>
<p>This is the primary mechanism for discovering the state of a contract, and allowing it to solely track updates to 
the state of contracts the indexer is interested in. This is a key aspect of Tari's scalability. Without this, we 
would fall back into the trap of having a global state machine, which axiomatically, does not scale.</p>
<h3 id="substate-cache"><a class="header" href="#substate-cache">Substate cache</a></h3>
<p>The substate cache reduces the amount of network traffic by storing the state of substates of interest. When a
request for a substate is made, the cache is checked first. If the substate is not in the cache, the network is
queried for the substate, potentially making many queries to find the latest version of the substate.</p>
<p>If the substate is in the cache, the cache may be checked to see if the substate is stale. Sometimes (e.g. for
transaction dry runs), we may simply be optimistic and accept the cached value as the latest version.</p>
<p>For consensus, the approach is more conservative and the network is consulted to verify the freshness of the cached
value.</p>
<p>The current implementation of the substate cache uses a
<a href="https://docs.rs/cacache/12.0.0/cacache/">local file-based cache</a> and is highly performant and designed
with concurrency in mind.</p>
<h1 id="change-log-28"><a class="header" href="#change-log-28">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">20 Dec 2023</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">23 Oct 2023</td><td style="text-align: left">Placeholder text</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="proposals"><a class="header" href="#proposals">Proposals</a></h1>
<p>RFC documents in this section are not part of the Tari specification, and for this reason are not placed in the 
preceding sections. However, they describe useful <em>applications</em> of the Tari protocol that may be built on top of 
the core technology.</p>
<p>RFCs in this section will remain in <img src="theme/images/status-draft.svg" alt="draft" /> status until they are implemented in 
some fashion in a wallet, standalone application, or in the RPC protocols, at which point they can be marked as 
<img src="theme/images/status-stable.svg" alt="stable" />.</p>
<p>If the underlying protocol changes to the point that an application is no longer implementable in its current state, 
it must be updated to <img src="theme/images/status-outdated.svg" alt="outdated" /> or else deprecated and moved to the 
<a href="deprecated.html">Deprecated RFCs</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0123replayattacks"><a class="header" href="#rfc-0123replayattacks">RFC-0123/ReplayAttacks</a></h1>
<h2 id="mitigating-one-sided-payment-replay-attacks"><a class="header" href="#mitigating-one-sided-payment-replay-attacks">Mitigating One-sided payment replay attacks</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a> and <a href="https://github.com/SWvheerden">S W van heerden</a></p>
<h1 id="licence-32"><a class="header" href="#licence-32">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-34"><a class="header" href="#language-34">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-34"><a class="header" href="#disclaimer-34">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-33"><a class="header" href="#goals-33">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe ways we can block replay attacks related to one-sided payments using TariScript.</p>
<h2 id="related-requests-for-comment-28"><a class="header" href="#related-requests-for-comment-28">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0120_consensus.html">RFC-0120: Base Layer Consensus</a></li>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
</ul>
<h2 id="replay-attack"><a class="header" href="#replay-attack">Replay attack</a></h2>
<p>Replay attacks are &quot;replaying&quot; old messages to deceive the receiver about the message's authenticity. 
With TariScript, a vulnerability exists where a replay attack can occur under certain conditions, even with the current consensus rules. </p>
<p>For this attack to work, we need Alice and Charlie to collude to steal some of Bob's funds:</p>
<ul>
<li>Alice sends a one-sided transaction to Bob. </li>
<li>Bob spends this UTXO to Charlie. 
<ul>
<li>Bob has to spend this and only this UTXO alone to Charlie with <strong>zero change</strong>.</li>
</ul>
</li>
<li>Alice sends a new one-sided transaction to Bob, creating the exact same output as before</li>
<li>Alice shares the Blinding factor of the UTXO with Charlie</li>
<li>Charlie can now claim this UTXO by replaying his old transaction 
<ul>
<li>Charlie has the signatures to spend the scripts, sign for the changes, etc. </li>
<li>Because the previous transaction contains no other inputs, Charlie only has to provide signatures for this one UTXO.</li>
<li>Because there is no change UTXO, Charlie has the keys for all the outputs in the transactions and can thus add another transaction or input
/output to make sure the kernel excess signature is unique.</li>
</ul>
</li>
</ul>
<p>This does not work if Bob includes another UTXO in the transaction to Charlie due to the <a href="Glossary.html#script-offset">script offset</a>. Although Charlie has the 
blinding factor, for the one UTXO, he does not have the <a href="Glossary.html#script-offset">script offset</a>. Charlie can create a new kernel signature unique for blockchain consensus with the blinding factor. Still, because the <a href="Glossary.html#script-offset">script offset</a> needs to balance as well, and he does not know the private keys for this, he needs
to use this as is, meaning he needs to use an exact copy of the transaction. If the transaction includes any UTXO that he does not know the 
blinding factor of, he cannot create a new kernel excess signature. Meaning it won't pass consensus rules. </p>
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<p>This is a very niche attack that will only be useful under certain circumstances, but never less still needs to be addressed. </p>
<h3 id="sign-with-chain-information"><a class="header" href="#sign-with-chain-information">Sign with chain information</a></h3>
<p>If we require as part of the <a href="RFC-0201_TariScript.html#transaction-input-changes">script signature</a> challenge that we sign the mined block height of that UTXO, it will ensure that Charlie cannot replay the signatures that
Bob provided on the Input to spend the output, as each duplicate commitment will have its own block height. This is ensured as we currently have a limit that a commitment
must be unique in the unspent set. </p>
<h4 id="advantages"><a class="header" href="#advantages">Advantages</a></h4>
<ul>
<li>Does not require any more on-chain information</li>
</ul>
<h4 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h4>
<ul>
<li>Reorged transactions cannot be put back in if the inputs are now spent at different heights</li>
</ul>
<h3 id="enforce-global-commitment-uniqueness"><a class="header" href="#enforce-global-commitment-uniqueness">Enforce global commitment uniqueness</a></h3>
<p>Alice cannot send the same one-sided UTXO to Bob if we require the commitment to be globally unique. This does mean that pruned nodes needs 
to track the spent TXO set's commitment and the UTXO set.</p>
<h4 id="advantages-1"><a class="header" href="#advantages-1">advantages</a></h4>
<ul>
<li>Safely reorg transactions</li>
</ul>
<h4 id="disadvantages-1"><a class="header" href="#disadvantages-1">disadvantages</a></h4>
<ul>
<li>Pruned node needs to save extra data about the spent set.</li>
<li>Syncing pruned nodes need to provide extra info to ensure that the downloaded list of commitments is correct
<ul>
<li>Without requiring extra information in the header, pruned nodes need to download the entire TXO set and compare this to the output_mmr root.</li>
</ul>
</li>
</ul>
<h1 id="change-log-29"><a class="header" href="#change-log-29">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">2022-10-19</td><td style="text-align: left">Minor editorial changes</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">2022-10-10</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvheerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0141sparsemerkletrees"><a class="header" href="#rfc-0141sparsemerkletrees">RFC-0141/SparseMerkleTrees</a></h1>
<h2 id="sparse-merkle-trees-a-mutable-data-structure-for-txo-commitments"><a class="header" href="#sparse-merkle-trees-a-mutable-data-structure-for-txo-commitments">Sparse Merkle Trees: A mutable data structure for TXO commitments</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">CjS77</a></p>
<h1 id="licence-33"><a class="header" href="#licence-33">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2023 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-35"><a class="header" href="#language-35">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-35"><a class="header" href="#disclaimer-35">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-34"><a class="header" href="#goals-34">Goals</a></h2>
<p>This Request for Comment (RFC) proposes replacing the current Mutable Merkle Mountain Range (MMMR) data structure 
used for tracking the commitment to the UTXO set, with a Sparse Merkle tree (SMT).</p>
<h2 id="related-requests-for-comment-29"><a class="header" href="#related-requests-for-comment-29">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0110_BaseNodes.html">RFC-0110: Base Nodes</a></li>
</ul>
<h2 id="description-16"><a class="header" href="#description-16">Description</a></h2>
<h3 id="sparse-merkle-trees"><a class="header" href="#sparse-merkle-trees">Sparse Merkle trees</a></h3>
<p>A sparse Merkle tree (<a href="https://eprint.iacr.org/2016/683.pdf" title="Original paper">SMT</a>) is a Merkle-type structure, except the contained data is indexed, and each datapoint is 
placed at the leaf that corresponds to that datapoint’s index. Empty nodes are represented by a predefined &quot;null&quot; value.</p>
<p>Since every empty node has the same hash, and the tree is sparse, it is possible to prune the tree in a way such 
that only the non-zero leaf nodes and placeholders marking the empty sub-trees are stored. Therefore, SMTs are 
relatively compact. </p>
<p>A major feature of SMTs is that they are truly mutable. The current UTXO Merkle root in Tari is calculated using a 
Merkle Mountain Range (MMR). This has some drawbacks: </p>
<ol>
<li>MMRs are <em>immutable</em> data structures, and therefore as a workaround (some would say, hack), a bitmap is appended 
to the MMR to mark the spent outputs. In Tari's implementation, a roaring bitmap is used, which takes 
advantage of compression, but even so, it is still fairly large and will grow indefinitely.</li>
<li>The Merkle tree must keep a record of all TXOs forever, and mark them as they are spent. The blockchain cannot 
prune STXOs from the set.</li>
<li>The root is path-dependent. Let's say that the UTXO merkle root currently has a value <code>R1</code>. When you add a UTXO 
to the set, to giving a new Merkle root <code>R2</code>, say, and then immediately remove the UTXO, the Merkle root will now be 
some <code>R3</code> and <em>not</em> <code>R1</code> as you might expect. This path dependence also extends to the order of adding UTXOs. 
Adding UTXO <code>A</code> then <code>B</code> yields a different root to <code>B</code> then <code>A</code>.</li>
</ol>
<p>SMTs are true mutable data structures and do not have these drawbacks. </p>
<ol>
<li>No tracking bitmap is needed. When a UTXO is spent, it can be deleted from the tree.</li>
<li>It is possible to prune STXOs from the UTXO set to calculate the Merkle root.</li>
<li>Adding and removing UTXOs in any order will always yield the same Merkle root. Adding and then deleting a UTXO 
from the set will result in the same Merkle root as before the UTXO was added.</li>
</ol>
<h3 id="inclusion-and-exclusion-proofs"><a class="header" href="#inclusion-and-exclusion-proofs">Inclusion and exclusion proofs</a></h3>
<p>Inclusion proofs for the current MMMR structure are possible but clunky, since the entire bitmap state must be 
included with the Merkle tree proof.</p>
<p>Exclusion proofs are not possible in the current MMMR implementation, unless an output happens to be a spent output. 
In this &quot;STXO proof&quot;, the form of the proof is identical to the inclusion proof, with the verifier checking that 
the bit corresponding to the TXO is set, rather than unset.</p>
<p>SMTs support inclusion <em>and</em> exclusion proofs, and they are both succinct, O(log n), representations of the tree.</p>
<h3 id="space-savings"><a class="header" href="#space-savings">Space savings</a></h3>
<p>In terms of space, the SMT is more efficient than MMMRs and the advantage grows with time.</p>
<p>For an SMT, to calculate the root of the UTXO set, all you need is the UTXO set itself, assuming the commitment is 
used as the tree index.</p>
<p>Consider some representative numbers:</p>
<p>Let's assume there are 1,000,000 UTXOs, with another 2,000,000 UTXOs having being spent over the lifetime of the
project. A busy blockchain might achieve this level of traffic in a few days.</p>
<p>If each commitment-UTXO hash pair is 64 bytes, you need serialize 64MB to recreate the Merkle root for the SMT.</p>
<p>For the MMMR, even though you only need the UTXO hash, you need all 3,000,000 values (96MB) plus approximately 1MB 
for every million hashes in a bitmap to indicate which hashes have  been deleted (3 MB) for a total of 99MB.</p>
<p>This only gets worse with time. Over a period of a year, a busy blockchain might have 100,000,000 spent transaction 
outputs. However, the UTXO set will grow far more slowly, and perhaps only 10x in size to 10 million outputs.</p>
<p>The SMT requires serialising 640MB of data to recreate the root, whereas the MMMR now requires 3.6GB of data.</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>The proposed implementation assumes that a key-value store for the data exists. The Merkle tree is only 
concerned with the index and the value hash, as opposed to the value itself.</p>
<p>When constructing a new tree, a hashing algorithm is specified. As 
indicated, the &quot;values&quot; provided to the tree must already be a hash, and should have been generated from a different 
hashing algorithm to the one driving the tree, in order to prevent second pre-image attacks.</p>
<p>To insert a new leaf, the key is used to derive a path through the tree. Starting with the most significant bit, you 
move down the left branch if the bit is zero, or take the right branch if the bit is equal to one. Once a terminal 
node is reached, the node is replaced with a new sub-tree with the existing terminal node and the new leaf node forming the 
children of the last branch node in the sub-tree. The depth of the sub-tree is determined by the number of matching 
bits of the respective keys of the two nodes.</p>
<p>To delete a node, the procedure above is reversed. This entails that a significant portion of the tree may be pruned 
when deleting a node in a highly sparse region of the tree.</p>
<p>The null hashes representing the empty sub-trees are treated identically to the leaf nodes. 
Thus branch hashes are calculated in the usual way, <em>inter alia</em>, <code>H_branch = H(Branch marker, H_left, H_right)</code>, 
irrespective of whether the left or right nodes are empty or not. </p>
<p>Domain separation SHOULD be used to distinguish branch nodes from leaf nodes. This also mitigates second pre-image 
attacks if the advice above is not followed and the values are hashed with the same algorithm as the tree. </p>
<p>For leaf node hashes, the key MUST be included in the hash. This prevents leaf node spoofing of the pruned tree. 
Therefore, leaf node hashes are of the form <code>H_leaf = H(Leaf marker, H_key, H_value)</code>.</p>
<p>A proof of concept implementation has been written and submitted for review in 
<a href="https://github.com/tari-project/tari/pull/5457">PR #5457</a>. The examples that follow assume this implementation.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p>Let's create a SMT with four nodes.</p>
<p>If we insert the nodes at</p>
<ul>
<li>A: 01001111 (79 in decimal)</li>
<li>B: 01011111 (95 in decimal)</li>
<li>C: 11100000 (224 in decimal)</li>
<li>D: 11110000 (240 in decimal)</li>
</ul>
<p>you will notice that the first two diverge at the fourth bit, while the first and last pairs differ at the
first bit. This results in a SMT that looks like this:</p>
<div style="line-height: 1em" class="hljs">
<pre>
            ┌──────┐
      ┌─────┤ root ├─────┐
      │     └──────┘     │
     ┌┴┐0               ┌┴┐1
  ┌──┤ ├──┐          ┌──┤ ├───┐
  │  └─┘  │          │  └─┘   │
 ┌┴┐00   ┌┴┐01      ┌┴┐10    ┌┴┐11
 │0│  ┌──┤ ├──┐     │0│    ┌─┤ ├─┐
 └─┘  │  └─┘  │     └─┘    │ └─┘ │
     ┌┴┐010  ┌┴┐011     110┌┴┐   ┌┴┐111
   ┌─┤ ├─┐   │0│          │0│ ┌─┤ ├─┐
   │ └─┘ │   └─┘          └─┘ │ └─┘ │
  ┌┴┐   ┌┴┐                  ┌┴┐   ┌┴┐
  │A│   │B│                  │D│   │C│
  └─┘   └─┘                  └─┘   └─┘
</pre>
</div>
<p><em>Figure 1: An example sparse Merkle tree.</em></p>
<p>The merkle root is calculated by hashing nodes in the familiar way.</p>
<p>Of note is that when we <em>delete</em> all the nodes, the SMT hash is <code>000...</code>, as expected. The MMMR
will never have a hash that's the same after adding, and then deleting the same node because of the bitmap tracking
deleted entries.</p>
<p>So even though the SMT is slower, it is still fast enough. The bandwidth
savings are substantial and the privacy benefits are significant.</p>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<h3 id="details"><a class="header" href="#details">Details</a></h3>
<p>The SMT implementation is faster than <code>MutableMMR</code> up to around 10,000 nodes, and then the average depth starts to 
affect it. By 1,000,000  nodes, it is significantly slower than MMR.</p>
<p>This makes sense since MMR is basically O(1) for inserts, while SMT is O(log(n)).</p>
<p>A rudimentary benchmark test yielded the following results</p>
<pre><code class="language-text">Starting: SMT: Inserting 1000000 keys
Finished: SMT: Inserting 1000000 keys - 1.921310493s
Starting: SMT: Calculating root hash
Tree size: 1000000. Root hash: 3e42ca40df366db52464c19b6ba71428976a56d7b120bc3c882fc29bf05dc1d7
Finished: SMT: Calculating root hash - 644.226062ms
Starting: SMT: Deleting 500000 keys
Finished: SMT: Deleting 500000 keys - 863.873761ms
Starting: SMT: Calculating root hash
Tree size: 500000. Root hash: 2a7b51f114a17c229f1067feb4ba5b6aad975689160a5eab0d90f89a3bcf09f8
Finished: SMT: Calculating root hash - 207.30907ms
Starting: SMT: Deleting another 500000 keys
Finished: SMT: Deleting another 500000 keys - 850.606501ms
Starting: SMT: Calculating root hash
Tree size: 0. Root hash: 0000000000000000000000000000000000000000000000000000000000000000
Finished: SMT: Calculating root hash - 3.892µs
Starting: MMR: Inserting 1000000 keys
Finished: MMR: Inserting 1000000 keys - 741.641704ms
Starting: SMT: Calculating root hash
Tree size: 1000000. Root hash: da6135ccaabf146024cae1b0e7ad6ba7e9dad79724fb9199b721d4cd243ba999
Finished: SMT: Calculating root hash - 8.649µs
Starting: MMR: Deleting 500000 keys
Finished: MMR: Deleting 500000 keys - 6.525858ms
Starting: SMT: Calculating root hash
Tree size: 500000. Root hash: fd60e168f27acba374109de9b8231e7252f0cfdf385f87dbfd92873d4956c995
Finished: SMT: Calculating root hash - 50.276µs
Starting: MMR: Deleting another 500000 keys
Finished: MMR: Deleting another 500000 keys - 6.862469ms
Starting: SMT: Calculating root hash
Tree size: 0. Root hash: 5d70f3177a0b46ea1b853c58d5e3f7d6e78cbc4149d71592bb6cea63d50ed96c
Finished: SMT: Calculating root hash - 93.618µs
</code></pre>
<p>The SMT is taking 1.92s to insert 1 mil nodes, or 1.9us per node on average on a 2018 Intel i9 Macbook Pro.</p>
<p>This is still sufficiently fast for our purposes and the benefits of having a truly mutable data structure, succinct 
inclusion and exclusion proofs, and significant serialisation savings far outweigh the performance costs. </p>
<h2 id="specification-1"><a class="header" href="#specification-1">Specification</a></h2>
<p>Define the following constants:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Value</th></tr></thead><tbody>
<tr><td>EMPTY_NODE_HASH</td><td>bytes</td><td>[0; 32]</td></tr>
<tr><td>LEAF_PREFIX</td><td>bytes</td><td>b&quot;V&quot;</td></tr>
<tr><td>BRANCH_PREFIX</td><td>bytes</td><td>b&quot;B&quot;</td></tr>
<tr><td>KEY_LENGTH_BYTES</td><td>integer</td><td>32</td></tr>
</tbody></table>
</div>
<h3 id="node-types"><a class="header" href="#node-types">Node types</a></h3>
<p>Each <code>Node</code> in the tree is either, <code>Empty</code>, a <code>Leaf</code>, or a <code>Branch</code>. Every node in the tree is associated with a 
hash function, <code>H</code> that has a digest output length of <code>KEY_LENGTH_BYTES</code>.</p>
<p>Leaf nodes store the key and value in their data property. Leaf nodes are immutable, and MAY cache the hash value 
for efficiency.</p>
<p>Branch nodes contain two <code>Node</code> instances, referring to the left and right child nodes respectively.  Branch nodes 
MAY store additional data, such as the height of the node in the tree, the key prefix and the node's hash value, for 
performance and efficiency purposes.</p>
<p>Default empty nodes always have a constant hash, <code>EMPTY_NODE_HASH</code>.</p>
<p>In summary, the nodes are defined as:</p>
<pre><code class="language-rust noplayground ignore">pub struct LeafNode&lt;H&gt; {
    key: NodeKey,
    hash: NodeHash,
    value: ValueHash,
    hash_type: PhantomData&lt;H&gt;,
}

pub struct EmptyNode {}

impl EmptyNode {
    pub fn hash(&amp;self) -&gt; &amp;'static NodeHash {
        &amp;EMPTY_NODE_HASH
    }
}

pub struct BranchNode&lt;H&gt; {
    // The height of the branch. It is also the number of bits that all keys below this branch share.
    height: usize,
    // Only the first `height` bits of the key are relevant for this branch.
    key: NodeKey,
    hash: NodeHash,
    // Flag to indicate that the tree hash changed somewhere below this branch. and that the hash should be
    // recalculated.
    is_hash_stale: bool,
    left: Box&lt;Node&lt;H&gt;&gt;,
    right: Box&lt;Node&lt;H&gt;&gt;,
    hash_type: PhantomData&lt;H&gt;,
}</code></pre>
<h3 id="leaf-node-values"><a class="header" href="#leaf-node-values">Leaf node values</a></h3>
<p>This specification outsources hashing the value data to an external service. 'Value' data in terms of the 
specification refers to the hash of the value data. The hashing algorithm used to hash the data SHOULD be different 
from <code>H</code>, to prevent second preimage attacks. </p>
<p>The digest length of the value hashes does not need to be <code>KEY_LENGTH_BYTES</code>, but it MUST be a constant predefined 
length.</p>
<h3 id="node-hashes"><a class="header" href="#node-hashes">Node hashes</a></h3>
<h4 id="empty-nodes"><a class="header" href="#empty-nodes">Empty nodes</a></h4>
<p>As described above, empty nodes always return <code>EMPTY_NODE_HASH</code> as the hash value.</p>
<h4 id="leaf-nodes"><a class="header" href="#leaf-nodes">Leaf nodes</a></h4>
<p>The definition of a leaf node's hash is</p>
<pre><code class="language-text">    H::digest(LEAF_PREFIX || KEY(32-bytes) || VALUE_HASH)
</code></pre>
<p>The key MUST be included in the hash. Imagine every leaf node has the same value. If the key was not hashed, there 
would be many different tree structures that would yield the same tree root. Specifically, any tree could replace a 
leaf node with a different leaf node with the same key prefix corresponding to the height of the original leaf node 
without changing the root hash.</p>
<h4 id="branch-nodes"><a class="header" href="#branch-nodes">Branch nodes</a></h4>
<p>The definition of a branch node's hash is</p>
<pre><code class="language-text">    H::digest(BRANCH_PREFIX || height || key_prefix || left_child_hash || right_child_hash)
</code></pre>
<p>where</p>
<ul>
<li><code>height</code> is the height of the branch in the tree, where the root node is height 0.</li>
<li><code>key_prefix</code> is the common prefix that the key of <em>every</em> descendent node of this branch will begin with. 
<code>key_prefix</code> is <code>KEY_LENGTH_BYTES</code> long, and every bit after the prefix MUST be set to zero. This means that key 
prefixes are not unique. For example, every key prefix for the left-most path down the tree will always have a 
prefix of <code>[0; 32]</code>. The height parameter helps disambiguate this.</li>
<li><code>left_child_hash</code> and <code>right_child_hash</code> are the hashes of the left and right child noes respectively, and have 
length <code>KEY_LENGTH_BYTES</code>. </li>
</ul>
<h3 id="tree-structure"><a class="header" href="#tree-structure">Tree structure</a></h3>
<p>The Merkle tree is built on top of an underlying dataset consisting of a set of (key, value) tuples. 
The key fixes the position of each dataset element in the tree: starting from the root, each digit in the binary 
expansion  indicates whether we should follow the left child (next digit is 0) or the right child (next digit is 1), 
see Figure 1. The length of the key (in bytes) is a fixed constant of the tree, <code>KEY_LENGTH_BYTES</code>, larger than 0.</p>
<p>Rather than explicitly creating a full tree, we simulate it by inserting only non-zero leaves into the tree whenever 
a new key-value pair is added to the dataset, using the two optimizations:</p>
<ol>
<li>Each subtree with exactly one non-empty leaf is replaced by the leaf itself.</li>
<li>Each subtree containing only empty nodes is replaced by a constant node with hash value equal to <code>EMPTY_HASH</code>.</li>
</ol>
<h3 id="root-hash-calculation"><a class="header" href="#root-hash-calculation">Root Hash Calculation</a></h3>
<p>The Merkle root of a dataset is computed as follows:</p>
<ol>
<li>The Merkle root of an empty dataset is set to the constant value <code>EMPTY_HASH</code>.</li>
<li>The Merkle root of a dataset with a single element is set to the leaf hash of that element.</li>
<li>Otherwise, the Merkle root is the hash of the branch node occupying the root position. The child hashes are 
calculated recursively using the definitions above.</li>
</ol>
<h3 id="adding-or-updating-a-key-value-pair"><a class="header" href="#adding-or-updating-a-key-value-pair">Adding or updating a key-value pair</a></h3>
<p>Adding a new node or updating an existing one follows the same logic. Therefore, a single function, <code>upsert</code> is 
defined. The borrow semantics of Rust requires a slightly different approach to managing the tree than one might 
take in other languages (e.g. <a href="https://github.com/LiskHQ/lips/blob/main/proposals/lip-0039.md" title="LIP-0039: Introduce sparse Merkle trees">LIP39</a>).</p>
<pre><code class="language-rust noplayground ignore">    pub fn upsert(&amp;mut self, key: NodeKey, value: ValueHash) -&gt; Result&lt;UpdateResult, SMTError&gt; {
        let new_leaf = LeafNode::new(key, value);
        if self.is_empty() {
            self.root = Node::Leaf(new_leaf);
            return Ok(UpdateResult::Inserted);
        } else if self.root.is_leaf() {
            return self.upsert_root(new_leaf);
        }
        // Traverse the tree until we find either an empty node or a leaf node.
        let mut terminal_branch = self.find_terminal_branch(new_leaf.key())?;
        let result = terminal_branch.insert_or_update_leaf(new_leaf)?;
        Ok(result)
    }
    
    /// Look at the height-th most significant bit and returns Left of it is a zero and Right if it is a one 
    fn traverse_direction(height: usize, child: &amp;NodeKey) -&gt; TraverseDirection {...}
    
    // Finds the branch node above the terminal node. The case of an empty or leaf root node must be handled elsewhere 
    fn find_terminal_branch(&amp;mut self, child_key: &amp;NodeKey) -&gt; Result&lt;TerminalBranch&lt;'_, H&gt;, SMTError&gt; {
        let mut parent_node = &amp;mut self.root;
        let mut empty_siblings = Vec::new();
        if !parent_node.is_branch() {
            return Err(SMTError::UnexpectedNodeType);
        }
        let mut done = false;
        let mut traverse_dir = TraverseDirection::Left;
        while !done {
            let branch = parent_node.as_branch_mut().unwrap();
            traverse_dir = traverse_direction(branch.height(), child_key)?;
            let next = match traverse_dir {
                TraverseDirection::Left =&gt; {
                    empty_siblings.push(branch.right().is_empty());
                    branch.left()
                },
                TraverseDirection::Right =&gt; {
                    empty_siblings.push(branch.left().is_empty());
                    branch.right()
                },
            };
            if next.is_branch() {
                parent_node = match traverse_dir {
                    TraverseDirection::Left =&gt; parent_node.as_branch_mut().unwrap().left_mut(),
                    TraverseDirection::Right =&gt; parent_node.as_branch_mut().unwrap().right_mut(),
                };
            } else {
                done = true;
            }
        }
        let terminal = TerminalBranch {
            parent: parent_node,
            direction: traverse_dir,
            empty_siblings,
        };
        Ok(terminal)
    }</code></pre>
<pre><code class="language-rust noplayground ignore">struct TerminalBranch&lt;'a, H&gt; {
    parent: &amp;'a mut Node&lt;H&gt;,
    direction: TraverseDirection,
    empty_siblings: Vec&lt;bool&gt;,
}

impl&lt;'a, H: Digest&lt;OutputSize = U32&gt;&gt; TerminalBranch&lt;'a, H&gt; {
    /// Returns the terminal node of the branch
    pub fn terminal(&amp;self) -&gt; &amp;Node&lt;H&gt; {
        let branch = self.parent.as_branch().unwrap();
        branch.child(self.direction)
    }

    // When inserting a new leaf node, there might be a slew of branch nodes to create depending on where the keys
    // of the existing leaf and new leaf node diverge. E.g. if a leaf node of key `1101` is being inserted into a
    // tree with a single leaf node of key `1100` then we must create branches at `1...`, `11..`, and `110.` with
    // the leaf nodes `1100` and `1101` being the left and right branches at height 4 respectively.
    //
    // This function handles this case, as well the simple update case, and the simple insert case, where the target
    // node is empty.
    fn insert_or_update_leaf(&amp;mut self, leaf: LeafNode&lt;H&gt;) -&gt; Result&lt;UpdateResult, SMTError&gt; {
        let branch = self.parent.as_branch_mut().ok_or(SMTError::UnexpectedNodeType)?;
        let height = branch.height();
        let terminal = branch.child_mut(self.direction);
        match terminal {
            Empty(_) =&gt; {
                let _ = [Set terminal to the new leaf (Insert)]
                Ok(UpdateResult::Inserted)
            },
            Leaf(old_leaf) if old_leaf.key() == leaf.key() =&gt; {
                let old_value = [Replace of leaf with new leaf (Update)]
                Ok(UpdateResult::Updated(old_value))
            },
            Leaf(_) =&gt; {
                let branch = // Create a new sub-tree with the old and new leaf being children of a branch at the height
                             // of the common key-prefixes
                Ok(UpdateResult::Inserted)
            },
            _ =&gt; unreachable!(),
        }
    }</code></pre>
<h3 id="removing-a-leaf-node"><a class="header" href="#removing-a-leaf-node">Removing a Leaf Node</a></h3>
<p>A certain key-value pair can be removed from the tree by deleting the corresponding leaf node and rearranging the 
affected nodes in the tree. The following protocol can be used to remove a key <code>k</code> from the tree.</p>
<pre><code class="language-rust noplayground ignore">    /// Attempts to delete the value at the location `key`. If the tree contains the key, the deleted value hash is
    /// returned. Otherwise, `KeyNotFound` is returned.
    pub fn delete(&amp;mut self, key: &amp;NodeKey) -&gt; Result&lt;DeleteResult, SMTError&gt; {
        if self.is_empty() {
            return Ok(DeleteResult::KeyNotFound);
        }
        if self.root.is_leaf() {
            return self.delete_root(key);
        }
        let mut path = self.find_terminal_branch(key)?;
        let result = match path.classify_deletion(key)? {
            PathClassifier::KeyDoesNotExist =&gt; DeleteResult::KeyNotFound,
            PathClassifier::TerminalBranch =&gt; {
                let deleted = // prune tree placing sibling at correct place upstream
                DeleteResult::Deleted(deleted)
            },
            PathClassifier::NonTerminalBranch =&gt; {
                let deleted_hash = path.delete()?;
                DeleteResult::Deleted(deleted_hash)
            },
        };
        Ok(result)
    }</code></pre>
<h3 id="proof-construction"><a class="header" href="#proof-construction">Proof Construction</a></h3>
<p>Proofs are constructed in a straightforward manner. Unlike other SMT implementations (e.g. <a href="https://github.com/LiskHQ/lips/blob/main/proposals/lip-0039.md" title="LIP-0039: Introduce sparse Merkle trees">LIP39</a>), if a
sibling node is empty, then <code>EMPTY_NODE_HASH</code> is included as the sibling hash, rather than building a bitmap of
non-empty siblings.</p>
<p>Both inclusion and exclusion proofs use a common algorithm, <code>build_proof_candidate</code> for traversing the tree to the 
desired proof key,<br />
collecting hashes of every sibling node. The terminal node for where the proof key should reside is also noted:</p>
<pre><code class="language-rust noplayground ignore">pub struct ExclusionProof&lt;H&gt; {
    siblings: Vec&lt;NodeHash&gt;,
    // The terminal node of the tree proof, or `None` if the the node is `Empty`.
    leaf: Option&lt;LeafNode&lt;H&gt;&gt;,
    phantom: std::marker::PhantomData&lt;H&gt;,
}

impl&lt;H: Digest&lt;OutputSize = U32&gt;&gt; SparseMerkleTree&lt;H&gt; {
    /// Construct the data structures needed to generate the Merkle proofs. Although this function returns a struct
    /// of type `ExclusionProof` it is not really a valid (exclusion) proof. The constructors do additional
    /// validation before passing the structure on. For this reason, this method is `private` outside of the module.
    pub(crate) fn build_proof_candidate(&amp;self, key: &amp;NodeKey) -&gt; Result&lt;ExclusionProof&lt;H&gt;, SMTError&gt; {
        let mut siblings = Vec::new();
        let mut current_node = &amp;self.root;
        while current_node.is_branch() {
            let branch = current_node.as_branch().unwrap();
            let dir = traverse_direction(branch.height(), key)?;
            current_node = match dir {
                TraverseDirection::Left =&gt; {
                    siblings.push(branch.right().hash().clone());
                    branch.left()
                },
                TraverseDirection::Right =&gt; {
                    siblings.push(branch.left().hash().clone());
                    branch.right()
                },
            };
        }
        let leaf = current_node.as_leaf().cloned();
        let candidate = ExclusionProof::new(siblings, leaf);
        Ok(candidate)
    }
}</code></pre>
<h4 id="inclusion-proof"><a class="header" href="#inclusion-proof">Inclusion proof</a></h4>
<p>An inclusion proof is valid if the terminal node found in <code>build_proof_candidate</code> matches the key and value provided 
in the proof request. Equivalently, the leaf node's hash must match the hash of a new leaf node generated with the 
key and value given in the proof request.</p>
<p>The final proof consists of the vector of sibling hashes. </p>
<pre><code class="language-rust noplayground ignore">pub struct InclusionProof&lt;H&gt; {
    siblings: Vec&lt;NodeHash&gt;,
    phantom: std::marker::PhantomData&lt;H&gt;,
}

impl&lt;H: Digest&lt;OutputSize = U32&gt;&gt; InclusionProof&lt;H&gt; {
    /// Generates an inclusion proof for the given key and value hash from the given tree. If the key does not exist in
    /// tree, or the key does exist, but the value hash does not match, then `from_tree` will return a
    /// `NonViableProof` error.
    pub fn from_tree(tree: &amp;SparseMerkleTree&lt;H&gt;, key: &amp;NodeKey, value_hash: &amp;ValueHash) -&gt; Result&lt;Self, SMTError&gt; {
        let proof = tree.build_proof_candidate(key)?;
        match proof.leaf {
            Some(leaf) =&gt; {
                let node_hash = LeafNode::&lt;H&gt;::hash_value(key, value_hash);
                if leaf.hash() != &amp;node_hash {
                    return Err(SMTError::NonViableProof);
                }
            },
            None =&gt; return Err(SMTError::NonViableProof),
        }
        Ok(Self::new(proof.siblings))
    }
}</code></pre>
<h4 id="exclusion-proof"><a class="header" href="#exclusion-proof">Exclusion proof</a></h4>
<p>An exclusion proof request only requires a key value. A proof is valid if the leaf node returned by 
<code>build_proof_candidate</code> does not have the same key as the proof request.</p>
<p>The proof consists of the sibling hashes and a copy of the terminal leaf node.</p>
<pre><code class="language-rust noplayground ignore">impl&lt;H: Digest&lt;OutputSize = U32&gt;&gt; ExclusionProof&lt;H&gt; {
    /// Generates an exclusion proof for the given key from the given tree. If the key exists in the tree then
    /// `from_tree` will return a `NonViableProof` error.
    pub fn from_tree(tree: &amp;SparseMerkleTree&lt;H&gt;, key: &amp;NodeKey) -&gt; Result&lt;Self, SMTError&gt; {
        let proof = tree.build_proof_candidate(key)?;
        // If the keys match, then we cannot provide an exclusion proof, since the key *is* in the tree
        if let Some(leaf) = &amp;proof.leaf {
            if leaf.key() == key {
                return Err(SMTError::NonViableProof);
            }
        }
        Ok(proof)
    }</code></pre>
<h3 id="proof-verification"><a class="header" href="#proof-verification">Proof Verification</a></h3>
<p>To check an exclusion proof, the Verifier calls the <code>ExclusionProof::validate(&amp;self, keys, root)</code> function. This 
function is not a method of the tree, and can be run just by holding the Merkle root.</p>
<p>The function reconstructs the tree using the expected key and places the leaf node provided in the proof at the terminal 
position. It then calculates the root hash. </p>
<p>Validation succeeds if the calculated root hash matches the given root hash, and the leaf node is
empty, or the existing leaf node has a different key to the expected key.</p>
<pre><code class="language-rust noplayground ignore">    pub fn validate(&amp;self, expected_key: &amp;NodeKey, expected_root: &amp;NodeHash) -&gt; bool {
        let leaf_hash = match &amp;self.leaf {
            Some(leaf) =&gt; leaf.hash().clone(),
            None =&gt; (EmptyNode {}).hash().clone(),
        };
        let root = self.calculate_root_hash(expected_key, leaf_hash);
        // For exclusion proof, roots must match AND existing leaf must be empty, or keys must not match
        root == *expected_root &amp;&amp;
            match &amp;self.leaf {
                Some(leaf) =&gt; leaf.key() != expected_key,
                None =&gt; true,
            }
    }</code></pre>
<p>Verifying inclusion proofs is similar, except that the terminal leaf node will be constructed from the key and value 
hash provided by the verifier.</p>
<pre><code class="language-rust noplayground ignore">    pub fn validate(&amp;self, expected_key: &amp;NodeKey, expected_value: &amp;ValueHash, expected_root: &amp;NodeHash) -&gt; bool {
        // calculate expected leaf node hash
        let leaf_hash = LeafNode::&lt;H&gt;::hash_value(expected_key, expected_value);
        let calculated_root = self.calculate_root_hash(expected_key, leaf_hash);
        calculated_root == *expected_root
    }</code></pre>
<h2 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<p>If the UTXO Merkle root is replaced by a sparse Merkle tree, this change would require a <strong>hard fork</strong>, 
since it fundamentally alters how the UTXO Merkle root is calculated. </p>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<ol>
<li>Dahlberg et. al., &quot;Efficient Sparse Merkle Trees&quot;, <a href="https://eprint.iacr.org/2016/683.pdf" title="Original paper">SMT</a></li>
<li>A. Ricottone, &quot;LIP-0039: Introduce sparse Merkle trees&quot;, <a href="https://github.com/LiskHQ/lips/blob/main/proposals/lip-0039.md" title="LIP-0039: Introduce sparse Merkle trees">LIP39</a></li>
</ol>
<h1 id="change-log-30"><a class="header" href="#change-log-30">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Date</th><th>Change</th><th>Author</th></tr></thead><tbody>
<tr><td>10 Jul 2023</td><td>First draft</td><td>CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0153stagedwalletsecurity"><a class="header" href="#rfc-0153stagedwalletsecurity">RFC-0153/StagedWalletSecurity</a></h1>
<h2 id="staged-wallet-security"><a class="header" href="#staged-wallet-security">Staged Wallet Security</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-34"><a class="header" href="#licence-34">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-36"><a class="header" href="#language-36">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-36"><a class="header" href="#disclaimer-36">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-35"><a class="header" href="#goals-35">Goals</a></h2>
<p>This Request for Comment (RFC) aims to describe Tari's ergonomic approach to securing funds in a hot wallet.
The focus is on mobile wallets, but the strategy described here is equally applicable to console or desktop wallets.</p>
<h2 id="related-requests-for-comment-30"><a class="header" href="#related-requests-for-comment-30">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0150_Wallets.html">RFC-0150: Wallets</a></li>
</ul>
<h2 id="description-17"><a class="header" href="#description-17">Description</a></h2>
<h3 id="rationale"><a class="header" href="#rationale">Rationale</a></h3>
<p>A major UX hurdle when users first interact with a crypto wallet is the friction they experience with the first user
experience.</p>
<p>A common theme: I want to play with some new wallet X that I saw advertised somewhere, so I download it and run it.
But first I get several screens that</p>
<ul>
<li>ask me to review my seed phrase,</li>
<li>ask me to write down my seed phrase,</li>
<li>prevent typical &quot;skip this&quot; tricks like taking a screenshot,</li>
<li>ask to confirm if I've written down my seed phrase,</li>
<li>force me to write a test, either by supplying a random sample of my seed phrase, or by getting me to type in the
whole thing.</li>
</ul>
<p>After all this, I play with the wallet a bit, and then typically, I uninstall it.</p>
<p>The goal of this RFC is to <strong>get the user playing with the wallet as quickly as possible</strong>. <em>Without</em> sacrificing
security whatsoever.</p>
<h3 id="a-staged-approach"><a class="header" href="#a-staged-approach">A staged approach</a></h3>
<p>This RFC proposes a smart, staged approach to wallet security. One that maximises user experience without compromising
safety.</p>
<p>Each step enforces more stringent security protocols on the user than the previous step.</p>
<p>The user moves from one step to another based on criteria that</p>
<ol>
<li>the user configures based on her preferences, or</li>
<li>uses sane predefined defaults.</li>
</ol>
<p>The criteria are generally based on the value of the wallet balance.</p>
<p>Once a user moves to a stage, the wallet does <em>not</em> move to a lower stage if the requirements for the stage are no longer
met.</p>
<p>Users may also jump to any more advanced stage from their wallet settings / configuration at any time.</p>
<h4 id="stage-zero---zero-balance"><a class="header" href="#stage-zero---zero-balance">Stage zero - zero balance</a></h4>
<p>When the user has a <em>zero balance</em>, there's no risk in letting them skip securing their wallet.</p>
<p>Therefore, Tari wallets SHOULD just skip the whole seed phrase ritual and let the user jump right into the action.</p>
<h4 id="stage-1a---a-reminder-to-write-down-your-seed-phrase"><a class="header" href="#stage-1a---a-reminder-to-write-down-your-seed-phrase">Stage 1a - a reminder to write down your seed phrase</a></h4>
<p>Once the user's balance exceeds the <code>MINIMUM_STAGE_ONE_BALANCE</code>, they will be prompted to review and write down their
seed phrase. The <code>MINIMUM_STAGE_ONE_BALANCE</code> is any non-zero balance by default.</p>
<p>After the transaction that causes the balance to exceed <code>MINIMUM_STAGE_ONE_BALANCE</code> is confirmed, the user is presented
with a friendly message: </p>
<pre><code class="language-text">You now have _real_ money in your wallet. If you accidentally delete your wallet app or lose
your device, your funds are lost, and there is no way to recover them unless you have safely kept a copy of your
`seed phrase` safe somewhere. Click 'Ok' to review and save the phrase now, or 'Do it later' to do it at a more
convenient time.
</code></pre>
<p>If the user elects <em>not</em> to save the phrase, the message pops up again periodically. Once per day, or when the balance
increases -- whichever is less frequent -- is sufficient without being too intrusive.</p>
<h4 id="stage-1b---simple-wallet-backups"><a class="header" href="#stage-1b---simple-wallet-backups">Stage 1b - simple wallet backups</a></h4>
<p>Users are used to storing their data in the cloud. Although this practice is frowned upon by crypto purists, for small
balances (the type you often keep in a hot wallet), using secure cloud storage for wallet backups is a fair
compromise between keeping the keys safe from attackers and protecting users from themselves.</p>
<p>The simple wallet backup saves the spending keys and values of the user's wallet to a personal cloud space (e.g. Google Drive,
Apple iCloud, Dropbox).</p>
<p>This solution does not require any additional input from the user besides providing authorisation to store in the cloud.
This can be done using the standard APIs and Authentication flows that each cloud provider publishes for their platform.</p>
<p>In particular, we do not ask for a password to encrypt the commitment data. The consequence is that anyone who gains
access to this data -- by stealing the user's cloud credentials -- <em>could</em> steal the user's funds.</p>
<p>Therefore, the threshold for moving from this stage to Stage 2, <code>STAGE_TWO_THRESHOLD_BALANCE</code> is relatively low;
somewhere in the region of \$10 to \$50.</p>
<p>The seed phrase MUST NOT be stored on the cloud in Stage 1b. Doing so would result in all <em>future</em> funds of the user being
lost if the backup were ever compromised. Since the backup is unencrypted in Stage 1b, we store the minimum amount of data
needed to recover the funds and limit the potential loss of funds in case of a breach to just that found in the commitments in the
backup, which should not be more than \$50.</p>
<p>Therefore, stage 1b backups are really just exporting and importing of UTXO data. The consequence of this is 
that restoring from a 1b backup does not restore the emoji id. On the other hand, you can easily import into any 
other wallet (e.g. into another wallet on another device owned by the same user).</p>
<p>Backups MUST be authorised by the user when the first cloud backup is made and SHOULD be automatically updated after each
transaction is confirmed.</p>
<p>Wallet authors MAY choose to exclude Stage 1b from the staged security protocol.</p>
<p>As usual, the user MUST be able to configure <code>STAGE_TWO_THRESHOLD_BALANCE</code> to suit their particular needs.</p>
<p>When this threshold is reached, the user SHOULD be prompted with a call to back-up their data:</p>
<pre><code class="language-text">Your wallet now holds a fair amount of value, which you probably don't want to lose. Unlike a physical wallet's 
notes, it's possible to make a copy of your wallet's contents that you can use to recover your funds in case you 
lose them.
 
You should think about making a copy of your wallet's coins, which we will keep up date date after every transaction.

If you have a copy of your seed phrase saved somewhere safe, and don't want to back up your coins into the cloud, you 
can skip this step.
</code></pre>
<p>The user can pick between <code>backup my coins</code> or <code>I have my seed phrase. Skip backups for now</code>.</p>
<p>If the user chooses to skip the backup, do not prompt them for stage 1b backups again.</p>
<h4 id="stage-2---full-wallet-backups"><a class="header" href="#stage-2---full-wallet-backups">Stage 2 - full wallet backups</a></h4>
<p>Once a user has a significant balance (over <code>STAGE_TWO_THRESHOLD_BALANCE</code>), Stage 2 is active. Stage 2 entails a full,
encrypted backup of the user's wallet to the cloud. The user needs to provide a <strong>password</strong> to perform and secure the encryption.</p>
<p>This makes the user's fund safer while at rest in the cloud. It also introduces an additional point of failure: the user
can forget their wallet's encryption password.</p>
<p>Stage 1b and 2 are similar in functionality but different in scope (Stage 2 allows us to store all the wallet
metadata, rather than just the commitments). For this reason, Stage 1b is optional.</p>
<p>Backups MUST be authorised by the user when the first cloud backup is made and SHOULD be automatically updated after each
transaction.</p>
<p>When migrating from Stage 1 to Stage 2, the Stage 1b backups SHOULD be deleted.</p>
<p>Once the stage 2 threshold is reached, the user is again presented with a call-to-action:</p>
<pre><code class="language-text">                   😎💰💰💰😎
It's awesome that you're using [this Tari wallet] so much!
You're a high-roller, so it's time to add another layer of security 
to your wallet backups.

Your funds will be safer if we encrypt your cloud backups with an 
additional password of your own choosing. You need to make sure that 
this password is very string and that YOU DO NOT FORGET it!

(Whatever happens, you can always restore from your seed phrase, so 
make sure you're still keeping this safe and secreted away).

As an added benefit, password-encrypted backups allow us to backup your 
transaction history as well!            
</code></pre>
<p>The user can choose to <code>Upgrade my backups</code>, <code>do this later</code>, <code>check my backup settings</code>. </p>
<p>The latter option takes the user to the wallet settings, where they can configure the various thresholds and 
manually decide which backup strategy they want to pursue.</p>
<p>They should be prompted periodically (once per day is sufficient) if they choose to defer the upgrade.</p>
<h4 id="stage-3---sweep-to-cold-wallet"><a class="header" href="#stage-3---sweep-to-cold-wallet">Stage 3 - Sweep to cold wallet</a></h4>
<p><strong>Pending hardware wallet support</strong></p>
<p>Above a given limit -- user-defined, or the default <code>MAX_HOT_WALLET_BALANCE</code>, the user should be prompted to transfer
funds into a cold wallet. The amount to sweep can be calculated as <code>MAX_HOT_WALLET_BALANCE</code> - <code>SAFE_HOT_WALLET_BALANCE</code>.</p>
<p>If the user ignores the prompt, they SHOULD be reminded one week later. From the second prompt onward, users SHOULD be given
an option to re-configure the values for <code>MAX_HOT_WALLET_BALANCE</code> and <code>SAFE_HOT_WALLET_BALANCE</code>.</p>
<p>Assuming one-sided payments are live, the user SHOULD be able to configure a <code>COLD_WALLET_ADDRESS</code> in the wallet.</p>
<p>For security reasons, a user SHOULD be asked for their 2FA confirmation, if it is configured, before broadcasting the
sweep transaction to the blockchain.</p>
<p>A suitable prompt for the user once the <code>MAX_HOT_WALLET_BALANCE</code> threshold is reached is:</p>
<pre><code class="language-text">🐋🐋🐋🐋🐋🐋🐋🐋  ❗❗❗ Whale Alert ❗❗❗  🐋🐋🐋🐋🐋🐋🐋🐋
Your mobile wallet holds way more funds than would normally be 
considered safe to walk around with in your pocket.

You should really consider sweeping most of your balance into a 
cold- or hardware wallet.   
</code></pre>
<p>Possible actions from this prompt include:</p>
<ul>
<li><code>Set up my cold wallet address</code>, if the cold wallet address has not been configured.</li>
<li><code>Transfer funds to my cold wallet</code>, if the cold wallet <em>has</em> been set up. The usual transaction confirmation flow 
SHOULD be followed here, and a stealth one-sided payment SHOULD be the default transaction type.</li>
<li><code>I'll deal with this myself</code>, which takes the user to their backup settings.</li>
</ul>
<p>To avoid spamming the user, do not fire this prompt more than once every three days.</p>
<h4 id="security-hygiene"><a class="header" href="#security-hygiene">Security hygiene</a></h4>
<ul>
<li>From stage 1 onwards Users should be asked periodically whether they still have their seed phrase written down.
Once every two months is sufficient.</li>
</ul>
<h1 id="change-log-31"><a class="header" href="#change-log-31">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">2022-11-10</td><td style="text-align: left">Initial stable</td><td style="text-align: left">Adrian Truszczyński</td></tr>
<tr><td style="text-align: left">2022-12-12</td><td style="text-align: left">Update user messages</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">2022-12-20</td><td style="text-align: left">Fix typo</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0154deeplinksconvention"><a class="header" href="#rfc-0154deeplinksconvention">RFC-0154/DeepLinksConvention</a></h1>
<h2 id="deep-links-structure-convention"><a class="header" href="#deep-links-structure-convention">Deep links structure convention.</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/TruszczynskiA">Adrian Truszczyński</a></p>
<h1 id="licence-35"><a class="header" href="#licence-35">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-37"><a class="header" href="#language-37">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-37"><a class="header" href="#disclaimer-37">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-36"><a class="header" href="#goals-36">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to specify the deep links structure used in the Tari Aurora project.
The primary motivation is to create a simple, human-readable, and scalable way to structure deep links used by the Tari Aurora clients.</p>
<h2 id="description-18"><a class="header" href="#description-18">Description</a></h2>
<p>Deep links are the URIs with hierarchical components sequence. We can use this sequence to pass and handle data in a standardized and predictable way. To do that, we need to pass three components to the target client: the scheme, command, and data.</p>
<h3 id="scheme"><a class="header" href="#scheme">Scheme</a></h3>
<p>The scheme is used to address the client, which will handle the command and data components. In the Tari Aurora project, we're using the <code>tari</code> scheme to open the wallet app and execute the command.</p>
<h3 id="command"><a class="header" href="#command">Command</a></h3>
<p>The command is a path string used to pass information about the action that should be performed by the client. The handler uses this command to determine how to deserialize the data, before passing it to the command function.
To support multiple networks the first path component should be the name of corresponding network. Before proceeding with the command, the client should first check that the active account is pointed to the correct network, or show an error if there is a mismatch. </p>
<p>For simple actions, the command can be defined as a single phrase. For more complex actions, the command should be defined as a multi-path where the second path component should be the name of the action group.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples:</a></h4>
<p>Simple Actions:</p>
<pre><code class="language-ignore">mainnet/user_profile
testnet/login
</code></pre>
<p>Complex Actions:</p>
<pre><code class="language-ignore">mainnet/payments/send
testnet/payments/request
</code></pre>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<p>The data component is an optional string of key-value pairs used by the parser/decoder to deserialize the data, which the client passes to the command function. The data component should be formatted in the same way as a URL query. The sub-component should have a <code>?</code> prefix, the key-value pairs should be separated by <code>&amp;</code>, and every key should be separated from the value by <code>=</code> character.</p>
<h3 id="the-structure"><a class="header" href="#the-structure">The Structure</a></h3>
<p>Combining all three components, they will form a deep link with a structure presented below:</p>
<pre><code class="language-ignore">{scheme}://{network_name}/{command}?{data}
</code></pre>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples:</a></h4>
<pre><code class="language-ignore">tari://mainnet/profile
tari://mainnet/profile/username
tari://testnet/payments/send?amount=1.23&amp;pubKey=01234556789abcde
tari://nextnet/contacts/list[0][alias]=MrTari&amp;list[0][tariAddress]=01234556789abcde&amp;list[1][alias]=AdamSmith&amp;list[1][tariAddress]=edcba9876543210
</code></pre>
<h3 id="deeplinks-in-use"><a class="header" href="#deeplinks-in-use">Deeplinks in use:</a></h3>
<ul>
<li><code>{network_name}/transactions/send</code></li>
</ul>
<p>The data contains transaction information used in the send tokens process.</p>
<div class="table-wrapper"><table><thead><tr><th>Value Name</th><th style="text-align: center">Value Type</th><th>Note</th></tr></thead><tbody>
<tr><td>tariAddress</td><td style="text-align: center">String</td><td>Receiver's Tari Address (base58)</td></tr>
<tr><td>amount</td><td style="text-align: center">UInt64?</td><td>The amount in micro Tari</td></tr>
<tr><td>note</td><td style="text-align: center">String?</td><td>Note passed with transaction</td></tr>
</tbody></table>
</div>
<ul>
<li><code>{network_name}/base_nodes/add</code></li>
</ul>
<p>The data contains a custom base node configuration. This deep link adds a new base node configuration to the pool and switches to the added base node. </p>
<div class="table-wrapper"><table><thead><tr><th>Value Name</th><th style="text-align: center">Value Type</th><th>Note</th></tr></thead><tbody>
<tr><td>name</td><td style="text-align: center">String</td><td>The name of the base node</td></tr>
<tr><td>peer</td><td style="text-align: center">String</td><td>Base node's public link and onion address combined together</td></tr>
</tbody></table>
</div>
<ul>
<li><code>{network_name}/contacts</code></li>
</ul>
<p>List of contacts. This deep link is used to share multiple Tari contacts with another user.</p>
<div class="table-wrapper"><table><thead><tr><th>Value Name</th><th style="text-align: center">Value Type</th><th>Note</th></tr></thead><tbody>
<tr><td>list</td><td style="text-align: center">Array&lt;Contact&gt;</td><td>List of <code>Contact</code> objects</td></tr>
</tbody></table>
</div>
<p><code>Contact</code> object</p>
<div class="table-wrapper"><table><thead><tr><th>Value Name</th><th style="text-align: center">Value Type</th><th>Note</th></tr></thead><tbody>
<tr><td>alias</td><td style="text-align: center">String?</td><td>Contact's name/alias</td></tr>
<tr><td>tariAddress</td><td style="text-align: center">String</td><td>Contact's Tari Address (base58)</td></tr>
</tbody></table>
</div>
<ul>
<li><code>{network_name}/profile</code></li>
</ul>
<p>User's profile card. It is used to initiate the transaction with a predefined receiver address and presented alias.</p>
<div class="table-wrapper"><table><thead><tr><th>Value Name</th><th style="text-align: center">Value Type</th><th>Note</th></tr></thead><tbody>
<tr><td>alias</td><td style="text-align: center">String</td><td>User's name/alias</td></tr>
<tr><td>tariAddress</td><td style="text-align: center">String</td><td>User's Tari Address (base58)</td></tr>
</tbody></table>
</div>
<h1 id="change-log-32"><a class="header" href="#change-log-32">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">19 Apr 2023</td><td style="text-align: left">First stable, replace public key with tari address</td><td style="text-align: left"><a href="https://github.com/SWvheerden">SWvHeerden</a></td></tr>
<tr><td style="text-align: left">06 Jun 2023</td><td style="text-align: left">Added descriptions for <code>/contacts</code> and <code>/profile</code> deep links</td><td style="text-align: left"><a href="https://github.com/TruszczynskiA">Adrian Truszczyński</a></td></tr>
<tr><td style="text-align: left">17 Jul 2024</td><td style="text-align: left">Updated documentation for <code>transactions/send</code>, <code>/contacts</code>, and <code>/profile</code> deep links</td><td style="text-align: left"><a href="https://github.com/TruszczynskiA">Adrian Truszczyński</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0230time-related-transactions"><a class="header" href="#rfc-0230time-related-transactions">RFC-0230/Time-related Transactions</a></h1>
<h2 id="time-related-transactions"><a class="header" href="#time-related-transactions">Time-related Transactions</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/SWvheerden">S W van Heerden</a></p>
<h1 id="licence-36"><a class="header" href="#licence-36">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-38"><a class="header" href="#language-38">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-38"><a class="header" href="#disclaimer-38">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-37"><a class="header" href="#goals-37">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe a few extensions to <a href="Glossary.html#mimblewimble">Mimblewimble</a> to allow time-related transactions.</p>
<h2 id="related-requests-for-comment-31"><a class="header" href="#related-requests-for-comment-31">Related Requests for Comment</a></h2>
<ul>
<li><a href="BaseLayerExtensions.html">RFC-0200: Base Layer Extensions</a></li>
</ul>
<h2 id="description-19"><a class="header" href="#description-19">Description</a></h2>
<h4 id="time-locked-utxos"><a class="header" href="#time-locked-utxos">Time-locked UTXOs</a></h4>
<p>Time-locked Unspent Transaction Outputs (UTXOs) can be accomplished by adding a feature flag to a UTXO and a lock height, 
also referred to as the output's maturity. This allows a consensus limit on after which height the output can be 
spent.</p>
<p>This requires that users constructing a transaction:</p>
<ul>
<li>MUST include a feature flag of their UTXO; and</li>
<li>MUST include a lock height in their UTXO.</li>
</ul>
<p>This adds the following requirement for a <a href="Glossary.html#base-node">base node</a>:</p>
<ul>
<li>A <a href="Glossary.html#base-node">base node</a> MUST NOT allow a UTXO to be spent if the <a href="Glossary.html#current-head">current head</a> has not already exceeded the UTXO's lock height.</li>
</ul>
<p>This also adds the following requirement for a <a href="Glossary.html#base-node">base node</a>:</p>
<ul>
<li>A base node MUST reject any <a href="Glossary.html#block">block</a> that contains a <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> with a lock height not already past the <a href="Glossary.html#current-head">current head</a>.</li>
</ul>
<h4 id="time-locked-contracts"><a class="header" href="#time-locked-contracts">Time-locked Contracts</a></h4>
<p>In standard <a href="Glossary.html#mimblewimble">Mimblewimble</a>, time-locked contracts can be accomplished by modifying the kernel of each transaction to 
include a lock height. This limits how early in the blockchain lifetime the specific transaction can be included in a 
block. This approach is used in a traditional <a href="Glossary.html#mimblewimble">Mimblewimble</a> construction that does not implement any kind of scripting.
This has two disadvantages. Firstly, the spending condition is very primitive and cannot be linked to other conditions.
Secondly, it bloats the kernel, which is a component of the transaction that cannot be pruned.</p>
<p>However, with <a href="RFC-0201_TariScript.html">TariScript</a> it becomes possible to express spending conditions like a time-lock as part of a UTXO's script.
The <code>CheckHeightVerify(height)</code> TariScript Op code allows a time-lock check to be incorporated into a script. The following is a simple
example of a plain time-lock script that prevents an output from being spent before the chain reaches height 4000:</p>
<pre><code class="language-text">CheckHeightVerify(4000)
</code></pre>
<h4 id="hashed-time-locked-contract"><a class="header" href="#hashed-time-locked-contract">Hashed Time-locked Contract</a></h4>
<p>Hashed time-locked contracts (<a href="Glossary.html#hashed-time-locked-contract">HTLC</a>) are a way of reserving funds that can only be spent if a hash pre-image can be provided or
if a specified amount of time has passed. The hash pre-image is a secret that can be revealed under the right conditions
to enable spending of the UTXO before the time-lock is reached. The secret can be directly exchanged between the parties or
revealed to the other party by spending an output that makes use of an adaptor signature.</p>
<p><a href="Glossary.html#hashed-time-locked-contract">HTLC</a>s enable a number of interesting transaction constructions. For example, <a href="https://tlu.tarilabs.com/protocols/atomic-swaps/AtomicSwaps.html">Atomic Swaps</a>
and Payment Channels like those in the <a href="https://tlu.tarilabs.com/protocols/lightning-network-for-dummies">Lightning Network</a>.</p>
<p>The following is an example of an <a href="Glossary.html#hashed-time-locked-contract">HTLC</a> script. In this script, Alice sends some Tari to Bob that he can spend using the 
private key of <code>P_b</code> if he can provide the pre-image to the SHA256 hash output (<code>HASH256{pre_image}</code>) specified in the script
by Alice. If Bob has not spent this UTXO before the chain reaches height 5000 then Alice will be able to spend the output
using the private key of <code>P_a</code>.</p>
<pre><code class="language-text">HashSha256
PushHash(HASH256{pre_image})
Equal
IFTHEN
   PushPubkey(P_b)
ELSE
   CheckHeightVerify(5000)
   PushPubkey(P_a)
ENDIF
</code></pre>
<p>A more detailed analysis of the execution of this kind of script can be found at <a href="RFC-0202_TariScriptOpcodes.html#time-locked-contract">Time-locked Contact</a></p>
<h1 id="change-log-33"><a class="header" href="#change-log-33">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">14 Apr 2019</td><td style="text-align: left">First draft</td><td style="text-align: left">SWvheerden</td></tr>
<tr><td style="text-align: left">19 Dec 2021</td><td style="text-align: left">TariScript updates</td><td style="text-align: left">philipr</td></tr>
<tr><td style="text-align: left">31 Oct 2022</td><td style="text-align: left">Stable update</td><td style="text-align: left">brianp</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0240atomic-swap"><a class="header" href="#rfc-0240atomic-swap">RFC-0240/Atomic Swap</a></h1>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/SWvheerden">S W van Heerden</a></p>
<h1 id="licence-37"><a class="header" href="#licence-37">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-39"><a class="header" href="#language-39">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-39"><a class="header" href="#disclaimer-39">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-38"><a class="header" href="#goals-38">Goals</a></h2>
<p>This Request for Comment (RFC) aims to describe how Atomic swaps will be created between two parties on different blockchains.</p>
<h2 id="related-requests-for-comment-32"><a class="header" href="#related-requests-for-comment-32">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="RFC-0202_TariScriptOpcodes.html">RFC-0202: TariScript Opcodes</a></li>
</ul>
<p>$$
\newcommand{\preimage}{\phi} % pre image
\newcommand{\hash}[1]{\mathrm{H}\bigl({#1}\bigr)}
$$</p>
<h2 id="description-20"><a class="header" href="#description-20">Description</a></h2>
<p>Atomic swaps are atomic transactions that allow users to exchange different crypto assets and or coins without using a
central exchange and or trusting each other. Trading coins or assets this way makes it much more private and secure to
do and swap because no third party is required to be secure. Atomic swaps work on the principle of using 
<a href="https://en.bitcoin.it/wiki/Hash_Time_Locked_Contracts">Hashed Time Lock Contracts</a>(HTLC). 
In short, it requires some hash pre-image to unlock the contract, or the time-lock can be used to reclaim the funds. </p>
<p>In a cross-chain Atomic swap, both users lock up the funds to be exchanged on their respective chains in an HTLC-type contract. 
However, the two contracts’ pre-image, or spending secret, is the same, but only one party knows the correct pre-image. 
When the first HTLC contract is spent, this publicly reveals the pre-image for the other party to spend the second HTLC.
If the first HTLC is never spent, the second transaction's time-lock will allow the user to respend the funds back to
themselves after the time lock has passed.</p>
<h3 id="btc---xtr-atomicswap"><a class="header" href="#btc---xtr-atomicswap">BTC - XTR AtomicSwap</a></h3>
<h4 id="overview-3"><a class="header" href="#overview-3">Overview</a></h4>
<p>BTC uses a scripting language for smart contracts on transactions which enables <a href="https://tlu.tarilabs.com/protocols/atomic-swaps/AtomicSwaps.html">atomic swaps</a>
on the BTC chain. Traditionally <a href="Glossary.html#mimblewimble">Mimblewimble</a> coins do not implement scripts, which makes Atomic swaps harder to
implement but not impossible. Grin has implemented atomic swaps using a version of a 2-of-2 multi-signature transaction
<a href="https://tlu.tarilabs.com/protocols/grin-protocol-overview/MainReport.html#atomic-swaps">mimblewimble atomic swaps</a>.
Fortunately, Tari does have scripting with <a href="Glossary.html#tariscript">TariScript</a>, which works a lot like BTC scripts, making the implementation simpler.
Because of the scripting similarities, the scripts to both HTLCs will look very similar, and we only need to ensure that
we use the same hash function in both. </p>
<p>To do an Atomic swap from BTC to XTR, we need four wallets, two BTC wallets, and two XTR wallets, one wallet per person,
per coin.</p>
<p>As an example, Alice wants to trade some of her XTR for Bob's BTC. Alice and Bob need to agree on an amount of XTR and
BTC to swap. Once an agreement is reached, the swap is executed in the following steps:</p>
<ul>
<li>
<p>Alice chooses a set of random bytes, \( \preimage \), as the pre-image and hashes it with SHA256. She then sends</p>
</li>
<li>
<p>the hash of the pre-image, \( \hash{\preimage} \), to Bob along with her BTC address.</p>
</li>
<li>
<p>Bob sends her a public version of his <a href="Glossary.html#script-keypair">script key</a>, \( K_{Sb} \), for use in the XTR transaction, which we can refer
to as Bob's script address.</p>
</li>
<li>
<p>Alice creates a one-sided XTR transaction with an HTLC contract requiring \( \preimage \) as the input, which will
either payout to Bob's script address or her script address, \( K_{Sa} \), after a particular &quot;time&quot; has elapsed
(block height has been reached). </p>
</li>
<li>
<p>Bob waits for this transaction to be mined. When it is mined, he verifies that the UTXO spending script expects a
comparison of \( \hash{\preimage} \) as the first instruction, and that his public <a href="Glossary.html#script-keypair">script key</a>, \( K_{Sb} \), will
be the final value remaining after executing the script. He has the private <a href="Glossary.html#script-keypair">script key</a>, \( k_{Sb} \), to enable him
to produce a signature to claim the funds if he can get hold of the expected pre-image input value, \( \preimage \).
He also verifies that the UTXO has a sufficiently long time-lock to give him time to claim the transaction.</p>
</li>
<li>
<p>Upon verification, Bob creates a Segwit HTLC BTC transaction with the same \( \hash{\preimage} \), which will spend</p>
</li>
<li>
<p>to Alice's BTC address she gave him. It is essential to note that the time lock for this HTLC has to expire before</p>
</li>
<li>
<p>the time lock of the XTR HTLC that Alice created.</p>
</li>
<li>
<p>Alice checks the Bitcoin blockchain, and upon seeing that the transaction is mined, she claims the transaction, but,</p>
</li>
<li>
<p>for her to do so, she has to make public what \( \preimage \) is as she has to use it as the witness of the 
claiming transaction.</p>
</li>
<li>
<p>Bob sees that his BTC is spent, and looks at the witness to get \( \preimage \). Bob can then use \( \preimage \)
to claim the XTR transaction.</p>
</li>
</ul>
<h4 id="btc---htlc-script"><a class="header" href="#btc---htlc-script">BTC - HTLC script</a></h4>
<p>Here is the required BTC script that Bob publishes:</p>
<pre><code class="language-btc_script ignore">	OP_IF
	   OP_SHA256 &lt;HASH256{pre_image}&gt; OP_EQUALVERIFY
		&lt;Alice BTC address&gt; OP_CHECKSIG
	OP_ELSE
      &lt;relative locktime&gt;
      OP_CHECKSEQUENCEVERIFY
      OP_DROP
      &lt;Bob BTC address&gt; OP_CHECKSIG
   OP_ENDIF
</code></pre>
<p><em>relative locktime</em> is a time sequence in which Alice chooses to lock up the funds to give Bob time to claim this. </p>
<h4 id="xtr---htlc-script"><a class="header" href="#xtr---htlc-script">XTR - HTLC script</a></h4>
<p>Here is the required XTR script that Alice publishes:</p>
<pre><code class="language-TariScript ignore">   HashSha256 PushHash(HASH256{pre_image}) Equal
   IFTHEN
      PushPubkey(K_{Sb})
	ELSE
      CheckHeightVerify(height)
      PushPubkey(K_{Sa})
   ENDIF
</code></pre>
<p>(\( K_{Sb} \)) is the public key of the <a href="Glossary.html#script-keypair">script key</a> pair that Bob chooses to claim this transaction if Alice backs out. 
<em>height</em> is an absolute block height that Bob chooses to lock up the funds to give Alice time to claim the funds. </p>
<h2 id="xtr---xmr-swap"><a class="header" href="#xtr---xmr-swap">XTR - XMR swap</a></h2>
<p>The Tari - Monero atomic swap involved a bit more detail than just a simple script and is explained in
<a href="RFC-0241_AtomicSwapXMR.html">RFC-0241: XTR - XMR swap</a></p>
<h2 id="notation-2"><a class="header" href="#notation-2">Notation</a></h2>
<p>Where possible, the &quot;usual&quot; notation is used to denote terms commonly found in cryptocurrency literature. Lower case
characters are used as private keys, while uppercase characters are used as public keys. New terms introduced here are
assigned greek lowercase letters in most cases. Some terms used here are noted down in <a href="Glossary.html#tariscript">TariScript</a>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th>Symbol</th><th>Definition</th></tr></thead><tbody>
<tr><td style="text-align: left">Pre-image</td><td>\( \preimage \)</td><td>The random byte data used for the pre-image of the hash</td></tr>
<tr><td style="text-align: left"></td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="change-log-34"><a class="header" href="#change-log-34">Change Log</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">17 Oct 2022</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvHeerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0241xmr-atomic-swap"><a class="header" href="#rfc-0241xmr-atomic-swap">RFC-0241/XMR Atomic Swap</a></h1>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/SWvheerden">S W van Heerden</a></p>
<h1 id="licence-38"><a class="header" href="#licence-38">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-40"><a class="header" href="#language-40">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-40"><a class="header" href="#disclaimer-40">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-39"><a class="header" href="#goals-39">Goals</a></h2>
<p>This Request for Comment (RFC) aims to describe how an Atomic swap between Tari and Monero will be created.</p>
<h2 id="related-requests-for-comment-33"><a class="header" href="#related-requests-for-comment-33">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="RFC-0202_TariScriptOpcodes.html">RFC-0202: TariScript Opcodes</a></li>
</ul>
<p>$$
\newcommand{\script}{\alpha} % utxo script
\newcommand{\input}{ \theta }
\newcommand{\cat}{\Vert}
\newcommand{\so}{\gamma} % script offset
\newcommand{\hash}[1]{\mathrm{H}\bigl({#1}\bigr)}
$$</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Any comments, changes or questions to this PR can be made in one of the following ways:</p>
<ul>
<li>Join the discussion on the <a href="https://github.com/tari-project/tari/discussions/3647">Github discussion page</a>.</li>
<li>Create a new PR on the Tari project <a href="https://github.com/tari-project/tari/pulls">Github pull requests</a>.</li>
<li>Create a new issue on the Tari project <a href="https://github.com/tari-project/tari/issues">Github issues</a>.</li>
</ul>
<h2 id="description-21"><a class="header" href="#description-21">Description</a></h2>
<p>Doing atomic swaps with Monero is more complicated and requires a cryptographic dance to complete as Monero does not
implement any form of HTLC's or the like. This means that when doing an atomic swap with Monero, most of the logic will
have to be implemented on the Tari side. Atomic swaps between Monero and Bitcoin have been implemented by the <a href="https://github.com/farcaster-project/RFCs">Farcaster  project</a>
and the <a href="https://github.com/comit-network/xmr-btc-swap">Comit team</a>. Due to the how TariScript works, we have a few
advantages over Bitcoin script regarding <a href="https://tlu.tarilabs.com/cryptography/introduction-to-scriptless-scripts#adaptor-signatures">adaptor signatures</a>, as the <a href="Glossary.html#script-keypair">script key</a> was explicitly designed with <a href="https://tlu.tarilabs.com/cryptography/introduction-to-scriptless-scripts">scriptless scripts</a> in mind.</p>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<p>The primary, happy path outline of a Tari - Monero atomic swap is described here, and more detail will follow. We assume
that Alice wants to trade her XTR for Bob's XMR.</p>
<ul>
<li>Negotiation - Both parties negotiate the value and other details of the Monero and Tari UTXO's.</li>
<li>Commitment - Both parties commit to the keys, nonces, inputs, and outputs to use for the transaction.</li>
<li>XTR payment - Alice makes the XTR payment to a UTXO containing a &quot;special&quot; script described below.</li>
<li>XMR Payment - The Monero payment is made to a multiparty <a href="https://tlu.tarilabs.com/cryptography/introduction-to-scriptless-scripts">scriptless script</a> UTXO.</li>
<li>Claim XTR - Bob redeems the XTR, and in doing so, reveals the XMR private key to Alice only.</li>
<li>Claim XMR - Alice may claim the XMR using the revealed key.</li>
</ul>
<p>Please take note of the notation used in <a href="Glossary.html#tariscript">TariScript</a> and specifically notation used on the signatures on the <a href="RFC-0201_TariScript.html#transaction-input-changes">transaction inputs</a> and on the signatures on the <a href="RFC-0201_TariScript.html#transaction-output-changes">transaction outputs</a>.
We will note other notations in the <a href="RFC-0241_AtomicSwapXMR.html#notation">Notation</a> section.</p>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p>The scheme revolves around Alice, who wants to exchange her Tari for Bob's Monero. Because they don't trust each other, 
they have to commit some information to do the exchange. And if something goes wrong here, we want to ensure that we can 
refund both parties either in Monero or Tari.</p>
<p>How this works is that Alice and Bob create a shared output on both chains. The Monero output is a simple aggregate key 
to unlock the UTXO, while multiple keys are needed to unlock the Tari UTXO. An aggregate key locks this Monero UTXO that 
neither Alice nor Bob knows, but they both know half of the key. The current Tari block height determines the unlocking 
key for the Tari UTXO.</p>
<p>The process is started by Alice and Bob exchanging and committing to some information. Alice is the first to publish a 
transaction, which creates the Tari UTXO. If Bob is happy that the Tari UTXO has been mined and verifies all the 
information, he will publish a transaction to create the Monero UTXO.</p>
<p>The TariScript script on the UTXO ensures that they will have to reveal their portion of the Monero key when either 
Alice or Bob spends this. This disclosure allows the other party to claim the Monero by being the only one to own the 
complete Monero aggregate key.</p>
<p>We can visualize the happy path flow with the image below. 
<img src="assets/XTR_XMR_happy.png" alt="swap flow" /></p>
<p>The script will ensure that at any point in time, at least someone can claim the Tari UTXO, and if that person does so, 
the other party can claim the Monero UTXO by looking at the spending data. It has two lock heights, determining who can 
claim the Tari UTXO if the happy path fails. Before the first lock height, only Bob can claim the Tari; we call this the 
swap transaction.</p>
<p>If Bob disappears after Alice has posted the Tari UTXO, Alice can claim the Tari after the first lock height and before 
the second lock height; we call this the refund transaction. It ensures that Alice can reclaim her Tari if Bob 
disappears, and if Bob reappears, he can reclaim his Monero.</p>
<p>That leaves us with the scenario where Alice disappears after Bob posts the Monero transaction, in which case we need to 
protect Bob. After the second lock height, only Bob can claim the Tari; we call this the lapse transaction. The lapse 
transaction will reveal Bob's Monero key so that if Alice reappears, she can claim the Monero.</p>
<p>The image below details the time flow of the Tari transactions spending the Tari UTXO. 
<img src="assets/TXR_XMR_flow.png" alt="swap flow" /></p>
<h2 id="heights-security-and-other-considerations"><a class="header" href="#heights-security-and-other-considerations">Heights, Security, and other considerations</a></h2>
<p>We need to consider a few things for this to be secure, as there are possible scenarios that can reduce the security in the atomic swap. </p>
<p>When looking at the two lock heights, the first lock height should be sufficiently large enough to give ample time for Alice to post the Tari UTXO transaction and for it to be mined with a safe number of confirmations,
and for Bob to post the Monero transaction and for it to be mined with a safe number of confirmations. The second lock
height should give ample time for Alice after the first lock height to re-claim her Tari. Larger heights here might make
refunds slower, but it should be safer in giving more time to finalize this. </p>
<p>Allowing both to claim the Tari after the second lock height is, on face value, a safer option. This can be done by enabling
either party to claim the script with the lapse transaction. The counterparty can then claim the Monero. However, this
will open up an attack vector to enable either party to claim the Monero while claiming the Tari. Either party could trivially
pull off such a scheme by performing a front-running attack and having a bit of luck. The counterparty monitors all broadcast 
transactions to base nodes. Upon identifying the lapse transaction, they do two things; in quick succession, broadcast 
their lapse transaction and the transaction to claim the Monero, both with sufficiently high fees. Base nodes will 
prefer to mine transactions with the higher fees, and thus the counterparty can walk away with both the Tari and the 
Monero.</p>
<p>It is also possible to prevent the transaction from being mined after being submitted to the mempool. This can be caused by a combination
of a too busy network, not enough fees, or a too-small period in the time locks. When one of these atomic swap transactions gets published to a mempool, we effectively already have all the details exposed. For the atomic swaps, it means we already revealed part of the Monero key, although
the actual Tari transaction has not been mined. But this is true for any HTLC or like script on any blockchain. But in the odd
chance that this does happen whereby the fees are too little and time locks not enough, it should be possible to do a child-pays-for-parent
transaction to bump up the fees on the transaction to get it mined and confirmed.</p>
<h2 id="key-construction"><a class="header" href="#key-construction">Key construction</a></h2>
<p>Using <a href="https://reyify.com/blog/flipping-the-scriptless-script-on-schnorr">multi-signatures</a> with Schnorr signatures, we
need to ensure that the keys are constructed so that key cancellation attacks are not possible. To do this, we create new
keys from the chosen public keys \(K_a'\) and \(K_b'\)</p>
<p>$$
\begin{aligned}
K_a &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_a' } * K_a' \\
k_a &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_a' } * k_a' \\
K_b &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_b' } * K_b' \\
k_b &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_b' } * k_b' \\
\end{aligned}
\tag{1}
$$</p>
<h2 id="key-equivalence"><a class="header" href="#key-equivalence">Key equivalence</a></h2>
<p>Monero uses Ed25519, while Tari uses <a href="https://ristretto.group/">Ristretto</a> as its curve of choice. While Ristretto and Ed25519 both works on Curve25519 and the Edward
points are the same, they differ when the points are encoded. In practice, this means the following:</p>
<p>$$
\begin{aligned}
Xm &amp;= x \cdot G_m \\
X &amp;= x \cdot G \\
X &amp;\neq X_m \\
\end{aligned}
\tag{2}
$$</p>
<p>To use public keys across different implementations or curves, we must prove that the same private key created the &quot;different&quot; public keys. Because we exchange encoded points, we need some way of proving they are the same.
<a href="https://projekter.aau.dk/projekter/files/260345149/Electronic_voting_application_based_on_public_verifiable_secret_sharing.pdf">Jepsen</a> designed a proof to prove Discrete Logarithm Equality (DLEQ) between two generator groups. But the proof here is not created for Elliptic Curve Cryptography (ECC) but can be adapted to ECC by:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{K_1 \cat K_2 \cat R_{1} \cat R_{2}} \\
s &amp;= r + e(k) \\
R_{1} &amp;= r \cdot G \\
R_{2} &amp;= r \cdot G_m \\
K_{1} &amp;= k \cdot G \\
K_{2} &amp;= k \cdot G_m \\
\end{aligned}
\tag{3}
$$</p>
<p>The verification is then:
$$
\begin{aligned}
e &amp;= \hash{K_1 \cat K_2 \cat R_{1} \cat R_{2}} \\
s \cdot G &amp;= R_{1} + e(K_1) \\
s \cdot G_m &amp;= R_{2} + e(K_2) \\
\end{aligned}
\tag{4}
$$</p>
<p>But this method has a problem with ECC keys as they are always used as \(mod(n)\) where n is the group size. With ECC, we cannot always use the method; it can only be used when the two curves are of the same group
size \(n\), or \(s &lt; n\). If this is not the case, a <a href="https://web.getmonero.org/resources/research-lab/pubs/MRL-0010.pdf">bit comparison</a> needs to be created to prove this.
But luckily, we use Ristretto and Ed25519, both on Curve25519, because it’s the same curve, same generator point, and just
different encodings. We can use this proof to know even though the encoded public keys do not match, they still share a private key</p>
<h2 id="key-security"><a class="header" href="#key-security">Key security</a></h2>
<p>The risk of publicly exposing part of the Monero private key is still secure because of how <a href="https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc#private-key-public-key-and-the-generator-point-in-ecc">ECC</a> works. We can
add two secret keys together and share the public version of both. And at the same time, we know that no one can calculate
the secret key with just one part.</p>
<p>$$
\begin{aligned}
(k_a + k_b) \cdot G &amp;= k_a \cdot G + k_b \cdot G\\
(k_a + k_b) \cdot G &amp;= K_a + K_b \\
(k_a + k_b) \cdot G &amp;= K \\
\end{aligned}
\tag{5}
$$</p>
<p>We know that \(K\), \(K_a\), \(K_b\) are public. While \(k\), \(k_a\), \(k_b\) are all private.</p>
<p>But if we expose \(k_b\), we can try to do the following:
$$
\begin{aligned}
(k_a + k_b) \cdot G &amp;= K_a + K_b\\
k_a \cdot G &amp;= (K_a + K_b - k_b \cdot G) \\
k_a \cdot G &amp;= K_a \\
\end{aligned}
\tag{6}
$$</p>
<p>However, this is the Elliptic-Curve Discrete Logarithm Problem, and there is no easy solution to solve this on current computer
hardware. Thus this is still secure even though we leaked part of the secret key \(k\).</p>
<h2 id="method-1"><a class="header" href="#method-1">Method 1</a></h2>
<h3 id="detail"><a class="header" href="#detail">Detail</a></h3>
<p>This method relies purely on TariScript to enforce the exposure of the private Monero aggregate keys. Based on <a href="https://suredbits.com/payment-points-part-1/">Point Time Lock Contracts</a>, the script forces the spending party to supply their Monero
private key part as input data to the script, evaluated via the operation <code>ToRistrettoPoint</code>. This TariScript operation will
publicly reveal part of the aggregated Monero private key, but this is still secure: see <a href="RFC-0241_AtomicSwapXMR.html#key-security">Key security</a>.</p>
<p>The simplicity of this method lies therein that the spending party creates all transactions on their 
own. Bob requires a pre-image from Alice to complete the swap transaction; Alice needs to verify that Bob published the 
Monero transaction and that everything is complete as they have agreed. If she is happy, she will provide Bob with the 
pre-image to claim the Tari UTXO.</p>
<h3 id="tariscript-1"><a class="header" href="#tariscript-1">TariScript</a></h3>
<p>The Script used for the Tari UTXO is as follows:</p>
<pre><code class="language-TariScript ignore">   ToRistrettoPoint
   CheckHeight(height_1)
   LtZero
   IFTHEN
      PushPubkey(X_b)
      EqualVerify
      HashSha256 
      PushHash(HASH256{pre_image})
      EqualVerify
      PushPubkey(K_{Sb})
   Else
      CheckHeight(height_2)
      LtZero
      IFTHEN
         PushPubkey(X_a)
         EqualVerify
         PushPubkey(K_{Sa})
      Else
         PushPubkey(X_b)
         EqualVerify
         PushPubkey(K_{Sb})
      ENDIF
   ENDIF
</code></pre>
<p>Before <code>height_1</code>, Bob can claim the Tari UTXO by supplying <code>pre_image</code> and his private Monero key part <code>x_b</code>. After 
<code>height_1</code> but before <code>height_2</code>, Alice can claim the Tari UTXO by supplying her private Monero key part <code>x_a</code>. After 
<code>height_2</code>, Bob can claim the Tari UTXO by providing his private Monero key part <code>x_b</code>.</p>
<h3 id="negotiation"><a class="header" href="#negotiation">Negotiation</a></h3>
<p>Alice and Bob have to negotiate the exchange rate and the amount exchanged in the atomic swap. They also need to decide 
how the two UTXO's will look on the blockchain. To accomplish this, the following needs to be finalized:</p>
<ul>
<li>Amount of Tari to swap for the amount of Monero</li>
<li>Monero public key parts \(Xm_a\), \(Xm_b\) ,and its aggregate form \(Xm\)</li>
<li>DLEQ proof of \(Xm_a\) and \(X_a\)</li>
<li>Tari <a href="Glossary.html#script-keypair">script key</a> parts \(K_{Sa}\), \(K_{Sb}\) </li>
<li>The <a href="Glossary.html#tariscript">TariScript</a> to be used in the Tari UTXO</li>
<li>The blinding factor \(k_i\) for the Tari UTXO, which can be a Diffie-Hellman between their Tari addresses.</li>
</ul>
<h3 id="key-selection"><a class="header" href="#key-selection">Key selection</a></h3>
<p>Using (1), we create the Monero keys as they are multi-party aggregate keys.
The Monero key parts for Alice and Bob is constructed as follows:</p>
<p>$$
\begin{aligned}
Xm_a' &amp;= xm_a' \cdot G_m \\
Xm_b' &amp;= xm_b' \cdot G_m \\
xm_a &amp;=  \hash{\hash{Xm_a' \cat Xm_b'} \cat Xm_a' } * xm_a' \\
xm_b &amp;=  \hash{\hash{Xm_a' \cat Xm_b'} \cat Xm_b' } * xm_b' \\
xm_a &amp;= x_a \\
xm_b &amp;= x_b \\
Xm_a &amp;=  \hash{\hash{Xm_a' \cat Xm_b'} \cat Xm_a' } * Xm_a' \\
Xm_b &amp;=  \hash{\hash{Xm_a' \cat Xm_b'} \cat Xm_b' } * Xm_b' \\
xm &amp;= xm_a + xm_b + k_i \\
Xm &amp;= Xm_a + Xm_b + k_i \cdot G_m\\
x &amp;= x_a + x_b + k_i \\
X &amp;= X_a + X_b + k_i \cdot G\\
\end{aligned}
\tag{7}
$$</p>
<h3 id="commitment-phase"><a class="header" href="#commitment-phase">Commitment phase</a></h3>
<p>This phase allows Alice and Bob to commit to using their keys.</p>
<h4 id="starting-values"><a class="header" href="#starting-values">Starting values</a></h4>
<p>Alice needs to provide Bob with the following:</p>
<ul>
<li>Script public key: \( K_{Sa}\)</li>
<li>Monero public key \( Xm_a'\) with Ristretto encoding</li>
</ul>
<p>Bob needs to provide Alice with the following:</p>
<ul>
<li>Script public key: \( K_{Sb}\)</li>
<li>Monero public key \( Xm_b'\) with Ristretto encoding</li>
</ul>
<p>Using the above equations in (7), Alice and Bob can calculate \(Xm\), \(Xm_a\), \(Xm_b\)</p>
<h4 id="dleq-proof"><a class="header" href="#dleq-proof">DLEQ proof</a></h4>
<p>Alice needs to provide Bob with:</p>
<ul>
<li>Monero public key \(X_a\) encoding on Ristretto</li>
<li>DLEQ proof for \(Xm_a\) and \(X_a\): \((R_{ZTa}, R_{ZMa}, s_{Za})\)</li>
</ul>
<p>$$
\begin{aligned}
e &amp;= \hash{X_a \cat Xm_a \cat R_{ZTa} \cat R_{ZMa}} \\
s_{Za} &amp;= r + e(x_a) \\
R_{ZTa} &amp;= r \cdot G \\
R_{ZMa} &amp;= r \cdot G_m \\
\end{aligned}
\tag{8}
$$</p>
<p>Bob needs to provide Alice with:</p>
<ul>
<li>Monero public key \(X_b\) encoding on Ristretto</li>
<li>DLEQ proof for \(Xm_b\) and \(X_b\): \((R_{ZTb}, R_{ZMb}, s_{Zb})\)</li>
</ul>
<p>$$
\begin{aligned}
e &amp;= \hash{X_b \cat Xm_b \cat R_{ZTb} \cat R_{ZMb}} \\
s_{Za} &amp;= r + e(x_b) \\
R_{ZTa} &amp;= r \cdot G \\
R_{ZMa} &amp;= r \cdot G_m \\
\end{aligned}
\tag{9}
$$</p>
<p>Alice needs to verify Bob's DLEQ proof with:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{X_b \cat Xm_b \cat R_{ZTb} \cat R_{ZMb}} \\
s_{Zb} \cdot G &amp;= R_{ZTb} + e(X_b) \\
s_{Zb} \cdot G_m &amp;= R_{ZMb} + e(Xm_b) \\
\end{aligned}
\tag{10}
$$</p>
<p>Bob needs to verify Alice's DLEQ proof with:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{X_a \cat Xm_a \cat R_{ZTa} \cat R_{ZMa}} \\
s_{Za} \cdot G &amp;= R_{ZTa} + e(X_a) \\
s_{Za} \cdot G_m &amp;= R_{ZMa} + e(Xm_a) \\
\end{aligned}
\tag{11}
$$</p>
<h3 id="xtr-payment"><a class="header" href="#xtr-payment">XTR payment</a></h3>
<p>Alice will construct the Tari UTXO with the correct <a href="RFC-0241_AtomicSwapXMR.html#tariscript">script</a> and publish the containing transaction to the 
blockchain, knowing that she can reclaim her Tari if Bob vanishes or tries to break the agreement. This is done with 
standard Mimblewimble rules and signatures.</p>
<h3 id="xmr-payment"><a class="header" href="#xmr-payment">XMR payment</a></h3>
<p>When Bob sees that the Tari UTXO that Alice created is mined on the Tari blockchain with the correct script, Bob can
publish the Monero transaction containing the Monero UTXO with the aggregate key \(Xm = Xm_a + Xm_b + k_i \cdot G_m \).</p>
<h3 id="claim-xtr"><a class="header" href="#claim-xtr">Claim XTR</a></h3>
<p>When Alice sees that the Monero UTXO that Bob created is mined on the Monero blockchain containing the correct aggregate 
key \(Xm\), she can provide Bob with the required <code>pre_image</code> to spend the Tari UTXO. She does not have the 
missing key \(xm_b \) to claim the Monero yet, but it will be revealed when Bob claims the Tari. </p>
<p>Bob can now supply the <code>pre_image</code> and his Monero private key as transaction input to unlock the script.</p>
<h3 id="claim-xmr"><a class="header" href="#claim-xmr">Claim XMR</a></h3>
<p>Alice can now see that Bob spent the Tari UTXO, and by examining the <code>input_data</code> required to satisfy the script, she 
can learn Bob's secret Monero key. Although this private key \( xm_b \) is now public knowledge, her part of the Monero spend key 
is still private, and thus only she knows the complete Monero spend key. She can use this knowledge to claim the Monero 
UTXO.</p>
<h3 id="the-refund"><a class="header" href="#the-refund">The refund</a></h3>
<p>If something goes wrong and Bob never publishes the Monero or disappears, Alice needs to wait for the lock height
<code>height_1</code> to pass. This will allow her to reclaim her Tari, but in doing so, she needs to publish her Monero secret key 
as input to the script to unlock the Tari. When Bob comes back online, he can use this public knowledge to reclaim his 
Monero, as only he knows both parts of the Monero UTXO spend key.</p>
<h3 id="the-lapse-transaction"><a class="header" href="#the-lapse-transaction">The lapse transaction</a></h3>
<p>If something goes wrong and Alice never gives Bob the required <code>pre_image</code>, Bob needs to wait for the lock height
<code>height_2</code> to pass. This will allow him to claim the Tari he wanted all along, but in doing so, he needs to publish
his Monero secret key as input to the script to unlock the Tari. When Alice comes back online, she can use this public 
knowledge to claim the Monero she wanted all along as only she now knows both parts of the Monero UTXO spend key.</p>
<h2 id="method-2"><a class="header" href="#method-2">Method 2</a></h2>
<h3 id="detail-1"><a class="header" href="#detail-1">Detail</a></h3>
<p>This method is based on work by the <a href="https://github.com/farcaster-project/RFCs">Farcaster project</a> and the <a href="https://github.com/comit-network/xmr-btc-swap">Comit team</a>. It utilizes adapter signatures and multi-party commitment signatures to ensure that
the spending party leaks their private Monero key part. Because all keys are aggregates keys, we need to ensure that the refund
and lapse transactions are negotiated and signed before Alice publishes the Tari UTXO. This will allow either Alice or Bob to
claim the refund and lapse transactions, respectively, without the other party being online. </p>
<h3 id="tariscript-2"><a class="header" href="#tariscript-2">TariScript</a></h3>
<p>The Script used for the Tari UTXO is as follows:</p>
<pre><code class="language-TariScript ignore">   CheckHeight(height_1)
   LtZero
   IFTHEN
      PushPubkey(K_{Ss})
   Else
      CheckHeight(height_2)
      LtZero
      IFTHEN
         PushPubkey(K_{Sr})
      Else
         PushPubkey(K_{Sl})
      ENDIF
   ENDIF
</code></pre>
<p>Before <code>height_1</code>, Bob can claim the Tari UTXO if Alice gives him the correct signature to complete the transaction.
After <code>height_1</code> but before <code>height_2</code>, Alice can claim the Tari UTXO. After <code>height_2,</code> Bob can claim the Tari UTXO.</p>
<h3 id="negotiation-1"><a class="header" href="#negotiation-1">Negotiation</a></h3>
<p>Alice and Bob have to negotiate the exchange rate and the amount exchanged in the atomic swap. 
They also need to decide how the two UTXO's will look on the blockchain. To accomplish this, the following needs to be finalized:</p>
<ul>
<li>Amount of Tari to swap for the amount of Monero</li>
<li>Monero public key parts \(Xm_a\), \(Xm_b\), and its aggregate form \(X\)</li>
<li>Tari <a href="Glossary.html#script-keypair">script key</a> parts \(K_{Ssa}\), \(K_{Ssb}\), and its aggregate form \(K_{Ss}\) for the swap transaction</li>
<li>Tari <a href="Glossary.html#script-keypair">script key</a> parts \(K_{Sra}\), \(K_{Srb}\), and its aggregate form \(K_{Sr}\) for the refund transaction</li>
<li>Tari <a href="Glossary.html#script-keypair">script key</a> parts \(K_{Sla}\), \(K_{Slb}\), and its aggregate form \(K_{Sl}\) for the lapse transaction</li>
<li>Tari <a href="Glossary.html#sender-offset-keypair">sender offset key</a> parts  \(K_{Osa}\), \(K_{Osb}\), and its aggregate form \(K_{Os}\) for the swap transaction</li>
<li>Tari <a href="Glossary.html#sender-offset-keypair">sender offset key</a> parts  \(K_{Ora}\), \(K_{Orb}\), and its aggregate form \(K_{Or}\) for the refund transaction</li>
<li>Tari <a href="Glossary.html#sender-offset-keypair">sender offset key</a> parts  \(K_{Ola}\), \(K_{Olb}\), and its aggregate form \(K_{Ol}\) for the lapse transaction</li>
<li>All of the nonces used in the script signature creation and Metadata signature for the swap, refund, and lapse transactions</li>
<li>The <a href="Glossary.html#script-offset">script offset</a> used in both the swap, refund, and lapse transactions</li>
<li>The <a href="Glossary.html#tariscript">TariScript</a> to be used in the Tari UTXO</li>
<li>The blinding factor \(k_i\) for the Tari UTXO, which can be a Diffie-Hellman between their addresses.</li>
</ul>
<h3 id="key-selection-1"><a class="header" href="#key-selection-1">Key selection</a></h3>
<p>Using (1), we create the Monero keys as they are multi-party aggregate keys.</p>
<p>The <a href="Glossary.html#script-keypair">script key</a> parts for Alice and Bob is constructed as follows:</p>
<p>$$
\begin{aligned}
k_{Ssa} &amp;=  \hash{\hash{K_{Ssa}' \cat K_{Ssb}'} \cat K_{Ssa}' } * k_{Ssa}' \\
k_{Ssb} &amp;=  \hash{\hash{K_{Ssa}' \cat K_{Ssb}'} \cat K_{Ssb}' } * k_{Ssb}' \\
k_{Ss} &amp;= k_{Ssa} + k_{sb} \\
k_{Sra} &amp;=  \hash{\hash{K_{Sra}' \cat K_{Srb}'} \cat K_{Sra}' } * k_{Sra}' \\
k_{Srb} &amp;=  \hash{\hash{K_{Sra}' \cat K_{Srb}'} \cat K_{Srb}' } * k_{Srb}' \\
k_{Sr} &amp;= k_{Sra} + k_{Srb} \\
k_{Sla} &amp;=  \hash{\hash{K_{Sla}' \cat K_{Slb}'} \cat K_{Sla}' } * k_{Sla}' \\
k_{Slb} &amp;=  \hash{\hash{K_{Sla}' \cat K_{Slb}'} \cat K_{Slb}' } * k_{Slb}' \\
k_{Sl} &amp;= k_{Sla} + k_{Slb} \\
\end{aligned}
\tag{12}
$$</p>
<p>The <a href="Glossary.html#sender-offset-keypair">sender offset key</a> parts for Alice and Bob is constructed as follows:</p>
<p>$$
\begin{aligned}
k_{Osa} &amp;=  \hash{\hash{K_{Osa}' \cat K_{Osb}'} \cat K_{Osa}' } * k_{Osa}' \\
k_{Osb} &amp;=  \hash{\hash{K_{Osa}' \cat K_{Osb}'} \cat K_{Osb}' } * k_{Osb}' \\
k_{Os} &amp;= k_{Osa} + k_{Ssb} \\
k_{Ora} &amp;=  \hash{\hash{K_{Ora}' \cat K_{Orb}'} \cat K_{Ora}' } * k_{Ora}' \\
k_{Orb} &amp;=  \hash{\hash{K_{Ora}' \cat K_{Orb}'} \cat K_{Orb}' } * k_{Orb}' \\
k_{Or} &amp;= k_{Ora} + k_{Srb} \\
k_{Ola} &amp;=  \hash{\hash{K_{Ola}' \cat K_{Olb}'} \cat K_{Ola}' } * k_{Ola}' \\
k_{Olb} &amp;=  \hash{\hash{K_{Ola}' \cat K_{Olb}'} \cat K_{Olb}' } * k_{Olb}' \\
k_{Ol} &amp;= k_{Ola} + k_{Slb} \\
\end{aligned}
\tag{13}
$$</p>
<p>The Monero key parts for Alice and Bob is constructed as follows:</p>
<p>$$
\begin{aligned}
xm_a' &amp;= x_a' \\
xm_b' &amp;= x_b' \\
Xm_a' &amp;= x_a' \cdot G_m \\
Xm_b' &amp;= x_b' \cdot G_m \\
X_a' &amp;= x_a' \cdot G \\
X_b' &amp;= x_b' \cdot G \\
x_a &amp;=  \hash{\hash{X_a' \cat X_b'} \cat X_a' } * x_a' \\
x_b &amp;=  \hash{\hash{X_a' \cat X_b'} \cat X_b' } * x_b' \\
x &amp;= x_a + x_b + k_i \\
Xm &amp;= Xm_a + Xm_b + k_i \cdot G_m \\
X &amp;= X_a + X_b + k_i \cdot G\\
\end{aligned}
\tag{14}
$$</p>
<h3 id="commitment-phase-1"><a class="header" href="#commitment-phase-1">Commitment phase</a></h3>
<p>Similar to method 1, this phase allows Alice and Bob to commit to using their keys and requires more than one round to 
complete. Some of the information that needs to be committed depends on previous knowledge. </p>
<h4 id="starting-values-1"><a class="header" href="#starting-values-1">Starting values</a></h4>
<p>Alice needs to provide Bob with the following:</p>
<ul>
<li>Output commitment \(C_r\) of the refund transaction's output</li>
<li>Output features  \( F_r\) of the refund transaction's output</li>
<li>Output script  \( \script_r\) of the refund transaction's output</li>
<li>Output commitment \(C_l\) of the lapse transaction's output</li>
<li>Output features  \( F_l\) of the lapse transaction's output</li>
<li>Output script  \( \script_l\) of the lapse transaction's output</li>
<li>Public keys: \( K_{Ssa}'\), \( K_{Sra}'\), \( K_{Sla}'\), \( K_{Osa}'\), \( K_{Ora}'\), \( K_{Ola}'\), \( X_a'\)</li>
<li>Nonces: \( R_{Ssa}\), \( R_{Sra}\), \( R_{Sla}\), \( R_{Msa}\), \( R_{Mra}\), \( R_{Mla}\)</li>
</ul>
<p>Bob needs to provide Alice with the following:</p>
<ul>
<li>Output commitment \(C_s\) of the swap transaction's output</li>
<li>Output features  \( F_s\) of the swap transaction's output</li>
<li>Output script  \( \script_s\) of the swap transaction's output</li>
<li>Public keys: \( K_{Ssb}'\), \( K_{Srb}'\), \( K_{Slb}'\), \( K_{Osb}'\), \( K_{Orb}'\), \( K_{Olb}'\), \( X_b'\)</li>
<li>Nonces: \( R_{Ssb}\), \( R_{Srb}\), \( R_{Slb}\), \( R_{Msb}\), \( R_{Mrb}\), \( R_{Mlb}\)</li>
</ul>
<p>After Alice and Bob have exchanged the variables, they start trading calculated values. </p>
<h4 id="construct-adaptor-signatures-and-dleq-proofs"><a class="header" href="#construct-adaptor-signatures-and-dleq-proofs">Construct adaptor signatures and DLEQ proofs</a></h4>
<p>Alice needs to provide Bob with the following values:</p>
<ul>
<li>Adaptor signature part \(b_{Sra}'\) for \(b_{Sra}\)</li>
<li>Signature part \(a_{Sra}\)</li>
<li>Monero public key \(X_a\) encoded with Ristretto </li>
<li>Monero public key \(Xm_a\) encoded with ed25519</li>
<li>DLEQ proof for \(Xm_a\) and \(X_a\): \((R_{ZTa}, R_{ZMa}, s_{Za})\)</li>
</ul>
<p>Alice constructs the <strong>adaptor signature</strong> of the <a href="RFC-0201_TariScript.html#transaction-input-changes">input script signature</a> 
parts for the refund transaction ( \(a_{Sra}\) and \(b_{Sra}'\) ) with:</p>
<p>$$
\begin{aligned}
a_{Sra} &amp;= r_{Sra_a} +  e_r(v_{i}) \\
b_{Sra}' &amp;= r_{Sra_b} +  e_r(k_{Sra}+k_i) \\
e_r &amp;= \hash{ (R_{Sr} + (X_a)) \cat \alpha_r \cat \input_r \cat (K_{Sra} + K_{Srb}) \cat C_i} \\
R_{Sr} &amp;= r_{Sra_a} \cdot H + r_{Sra_b} \cdot G + R_{Srb} \\
X_a &amp;= x_a \cdot G \\
\end{aligned}
\tag{15}
$$</p>
<p>Alice constructs the DLEQ proof:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{X_a \cat Xm_a \cat R_{ZTa} \cat R_{ZMa}} \\
s_{Za} &amp;= r + e(x_a) \\
R_{ZTa} &amp;= r \cdot G \\
R_{ZMa} &amp;= r \cdot G_m \\
\end{aligned}
\tag{16}
$$</p>
<p>Bob needs to provide Alice with the following values:</p>
<ul>
<li>Adaptor signature part \(b_{Ssb}'\) for \(b_{Ssb}\)</li>
<li>Signature part \(a_{Ssb}\)</li>
<li>Adaptor signature part \(b_{Slb}'\) for \(b_{Slb}\)</li>
<li>Signature part \(a_{Slb}\)</li>
<li>Monero public key \(X_b\) encoded with Ristretto </li>
<li>Monero public key \(Xm_b\) encoded with ed25519</li>
<li>DLEQ proof for \(Xm_b\) and \(X_b\): \((R_{ZTb}, R_{ZMb}, s_{Zb})\)</li>
</ul>
<p>Bob constructs the <strong>adaptor signatures</strong> of the <a href="RFC-0201_TariScript.html#transaction-input-changes">input script signature</a> 
parts for the swap transaction ( \(a_{Ssb}\), \(b_{Ssb}'\) ) and the lapse transaction 
( \(a_{Slb}\) and \(b_{Slb}'\) ) with</p>
<p>$$
\begin{aligned}
a_{Ssb} &amp;= r_{Ssb_a} +  e_s(v_{i}) \\
b_{Ssb}' &amp;= r_{Ssb_b} +  e_s(k_{Ssb}+k_i) \\
e_s &amp;= \hash{ (R_{Sr} + (X_b)) \cat \alpha_i \cat \input_i \cat (K_{Ssa} + K_{Ssb}) \cat C_i} \\
R_{Ss} &amp;= r_{Ssb_a} \cdot H + r_{Ssb_b} \cdot G + R_{Ssa} \\
a_{Slb} &amp;= r_{Slb_a} +  e_l(v_{i}) \\
b_{Slb}' &amp;= r_{Slb_b} +  e_l(k_{Slb}+k_i) \\
e_l &amp;= \hash{ (R_{Sl} + (X_b)) \cat \alpha_i \cat \input_i \cat (K_{Sla} + K_{Slb}) \cat C_i} \\
R_{Sl} &amp;= r_{Slb_a} \cdot H + r_{Slb_b} \cdot G + R_{Sla} \\
X_b &amp;= x_b \cdot G \\
\end{aligned}
\tag{17}
$$</p>
<p>Bob constructs the DLEQ proof:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{X_b \cat Xm_b \cat R_{ZTb} \cat R_{ZMb}} \\
s_{Zb} &amp;= r + e(x_b) \\
R_{ZTb} &amp;= r \cdot G \\
R_{ZMb} &amp;= r \cdot G_m \\
\end{aligned}
\tag{18}
$$</p>
<h4 id="verify-adaptor-signatures-and-dleq-proofs"><a class="header" href="#verify-adaptor-signatures-and-dleq-proofs">Verify adaptor signatures and DLEQ proofs</a></h4>
<p>Alice needs to verify Bob's adaptor signatures with:</p>
<p>$$
\begin{aligned}
a_{Ssb} \cdot H + b_{Ssb}' \cdot G &amp;= R_{Ssb} + (C_i+K_{Ssb})*e_s \\
a_{Slb} \cdot H + b_{Slb}' \cdot G &amp;= R_{Slb} + (C_i+K_{Slb})*e_l \\
\end{aligned}
\tag{19}
$$</p>
<p>Alice needs to verify Bob's Monero public keys using the zero-knowledge proof:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{X_b \cat Xm_b \cat R_{ZTb} \cat R_{ZMb}} \\
s_{Zb} \cdot G &amp;= R_{ZTb} + e(X_b) \\
s_{Zb} \cdot G_m &amp;= R_{ZMb} + e(Xm_b) \\
\end{aligned}
\tag{20}
$$</p>
<p>Bob needs to verify Alice's adaptor signature with:</p>
<p>$$
\begin{aligned}
a_{Sra} \cdot H + b_{Sra}' \cdot G &amp;= R_{Sra} + (C_i+K_{Sra})*e_r \\
\end{aligned}
\tag{21}
$$</p>
<p>Bob needs to verify Alice's Monero public keys using the zero-knowledge proof:</p>
<p>$$
\begin{aligned}
e &amp;= \hash{X_a \cat XM_a \cat R_{ZTa} \cat R_{ZMa}} \\
s_{Za} \cdot G &amp;= R_{ZTa} + e(X_a) \\
s_{Za} \cdot G_m &amp;= R_{ZMa} + e(Xm_a) \\
\end{aligned}
\tag{22}
$$</p>
<h4 id="swap-out-refund-and-lapse-transactions"><a class="header" href="#swap-out-refund-and-lapse-transactions">Swap out refund and lapse transactions</a></h4>
<p>If Alice and Bob are happy with the verification, they need to swap out refund and lapse transactions.</p>
<p>Alice needs to provide Bob with the following:</p>
<ul>
<li><a href="RFC-0201_TariScript.html#transaction-input-changes">Input script signature</a> for lapse transaction (\( (a_{Sla}, b_{Sla}), R_{Sla}\) )</li>
<li><a href="RFC-0201_TariScript.html#transaction-output-changes">Output metadata signature</a> for lapse transaction (\( b_{Mla}, R_{Mla}\) )</li>
<li><a href="RFC-0201_TariScript.html#script-offset">Script offset</a> for lapse transaction \( \so_{la} \)</li>
</ul>
<p>Alice constructs for the lapse transaction signatures.
$$
\begin{aligned}
a_{Sla} &amp;= r_{Sla_a} +  e_l(v_{i}) \\
b_{Sla} &amp;= r_{Sla_b} +  e_l(k_{Sla}) \\
e_l &amp;= \hash{ (R_{Sl} + (X_b)) \cat \alpha_i \cat \input_i \cat (K_{Sla} + K_{Slb}) \cat C_i} \\
R_{Sl} &amp;= r_{Sla_a} \cdot H + r_{Sla_b} \cdot G + R_{Slb}\\
b_{Mla} &amp;= r_{Mla_b} + e(k_{Ola}) \\
R_{Mla} &amp;= b_{Mla} \cdot G \\
e &amp;= \hash{ (R_{Mla} + R_{Mlb}) \cat \script_l \cat F_l \cat (K_{Ola} + K_{Olb}) \cat C_l} \\
\so_{la} &amp;= k_{Sla} - k_{Ola} \\
\end{aligned}
\tag{23}
$$</p>
<p>Bob needs to provide Alice with the following:</p>
<ul>
<li><a href="RFC-0201_TariScript.html#transaction-input-changes">Input script signature</a> for refund transaction (\( (a_{Srb}, b_{Srb}), R_{Srb}\) )</li>
<li><a href="RFC-0201_TariScript.html#transaction-output-changes">Output metadata signature</a> for refund transaction (\( b_{Mrb}, R_{Mrb}\) )</li>
<li><a href="RFC-0201_TariScript.html#script-offset">Script offset</a> for refund transaction \( \so_{rb} \)</li>
</ul>
<p>Bob constructs for the refund transaction signatures.
$$
\begin{aligned}
a_{Srb} &amp;= r_{Srb_a} +  e_r(v_{i}) \\
b_{Srb} &amp;= r_{Srb_b} +  e_r(k_{Srb}) \\
e_r &amp;= \hash{ (R_{Sr} + (X_a)) \cat \alpha_i \cat \input_i \cat (K_{Sra} + K_{Srb}) \cat C_i} \\
R_{Sl} &amp;= r_{Srb_a} \cdot H + r_{Srb_b} \cdot G + R_{Sra}\\
b_{Mrb} &amp;= r_{Mrb_b} + e(k_{Orb}) \\
R_{Mrb} &amp;= b_{Mrb} \cdot G \\
e &amp;= \hash{ (R_{Mra} + R_{Mrb}) \cat \script_r \cat F_r \cat (K_{Ora} + K_{Orb}) \cat C_r} \\
\so_{rb} &amp;= k_{Srb} - k_{Orb} \\
\end{aligned}
\tag{24}
$$</p>
<p>Although the script validation on output \(C_i\)  will not pass due to the lock height, both Alice and Bob need to
verify that the total aggregated signatures and script offset for the refund and lapse transaction are valid should they
need to publish them at a future date without the other party’s presence.</p>
<h3 id="xtr-payment-1"><a class="header" href="#xtr-payment-1">XTR payment</a></h3>
<p>If Alice and Bob are happy with all the committed values, Alice will construct the Tari UTXO with the correct 
<a href="RFC-0241_AtomicSwapXMR.html#tariscript">script</a> and publish the containing transaction to the blockchain. Because Bob already gave her the 
required signatures for his part of the refund transaction, Alice can easily compute the required aggregated signatures 
by adding the parts together. She has all the knowledge to spend this after the lock expires. </p>
<h3 id="xmr-payment-1"><a class="header" href="#xmr-payment-1">XMR Payment</a></h3>
<p>When Bob sees that the Tari UTXO that Alice created is mined on the Tari blockchain with the correct script, he can go 
ahead and publish the Monero UTXO with the aggregate key \(Xm = Xm_a + Xm_b \).</p>
<h3 id="claim-xtr-1"><a class="header" href="#claim-xtr-1">Claim XTR</a></h3>
<p>When Alice sees that the Monero UTXO that Bob created is mined on the Monero blockchain containing the correct aggregate 
key \(Xm\), she can provide Bob with the following allowing him to spend the Tari UTXO:</p>
<ul>
<li>Script signature for the swap transaction \((a_{Ssa}\, b_{Ssa}), R_{Ssa}\)</li>
<li>Metadata signature for swap transaction \((b_{Msa}, R_{Msa})\)</li>
<li>Script offset for swap transaction \( \so_{sa} \)</li>
</ul>
<p>She does not have the missing key \(x_b \) to claim the Monero yet, but it will be revealed when Bob claims the Tari. </p>
<p>Alice constructs for the swap transaction.
$$
\begin{aligned}
a_{Ssa} &amp;= r_{Ssa_a} +  e_s(v_{i}) \\
b_{Ssa} &amp;= r_{Ssa_b} +  e_s(k_{Ssa}) \\
e_s &amp;= \hash{ (R_{Ss} + (X_b)) \cat \alpha_i \cat \input_i \cat (K_{Ssa} + K_{Ssb}) \cat C_i} \\
R_{Ss} &amp;= r_{Ssa_a} \cdot H + r_{Ssa_b} \cdot G + R_{Ssb}\\
b_{Msa} &amp;= r_{Msa_b} + e(k_{Osa}) \\
R_{Msa} &amp;= b_{Msa} \cdot G \\
e &amp;= \hash{ (R_{Msa} + R_{Msb}) \cat \script_s \cat F_s \cat (K_{Osa} + K_{Osb}) \cat C_s} \\
\so_{sa} &amp;= k_{Ssa} - k_{Osa} \\
\end{aligned}
\tag{25}
$$</p>
<p>Bob constructs the swap transaction.
$$
\begin{aligned}
a_{Ssb} &amp;= r_{Ssb_a} +  e_s(v_{i}) \\
b_{Ssb} &amp;= r_{Ssb_b} + x_b + e_s(k_{Ssb} + k_i) \\
e_s &amp;= \hash{ (R_{Ss} + (X_b)) \cat \alpha_i \cat \input_i \cat (K_{Ssa} + K_{Ssb}) \cat C_i} \\
a_{Ss} &amp;= a_{Ssa} + a_{Ssb} \\
b_{Ss} &amp;= b_{Ssa} + b_{Ssb} \\
R_{Ss} &amp;= r_{Ssa_b} \cdot H + r_{Ssb_b} \cdot G + R_{Ssa}\\
a_{Msb} &amp;= r_{Msb_a} + e(v_{s}) \\
b_{Msb} &amp;= r_{Msb_b} + e(k_{Osb}+k_s) \\
R_{Msb} &amp;= a_{Msb} \cdot H + b_{Msb} \cdot G \\
e &amp;= \hash{ (R_{Msa} + R_{Msb}) \cat \script_s \cat F_s \cat (K_{Osa} + K_{Osb}) \cat C_s} \\
R_{Ms} &amp;= R_{Msa} + R_{Msb} \\
\so_{sb} &amp;= k_{Ssb} - k_{Osb} \\
\so_{s} &amp;= \so_{sa} +\so_{sb} \\
\end{aligned}
\tag{26}
$$</p>
<p>Bob's transaction now has all the required signatures to complete the transaction. He will then publish the transaction.</p>
<h3 id="claim-xmr-1"><a class="header" href="#claim-xmr-1">Claim XMR</a></h3>
<p>Because Bob has now published the transaction on the Tari blockchain, Alice can calculate the missing Monero key \(x_b\)
as follows:</p>
<p>$$
\begin{aligned}
b_{Ss} &amp;= b_{Ssa} + b_{Ssb} \\
b_{Ss} - b_{Ssa} &amp;= b_{Ssb} \\
b_{Ssb} &amp;= r_{Ssb_b} + x_b + e_s(k_{Ssb} + k_i) \\
b_{Ssb} - b_{Ssb}' &amp;= r_{Ssb_b} + x_b + e_s(k_{Ssb} + k_i) -(r_{Ssb_b} +  e_s(k_{Ssb}+k_i))\\
b_{Ssb} - b_{Ssb}' &amp;= x_b \\
\end{aligned}
\tag{27}
$$</p>
<p>With \(x_b\) in hand, she can calculate \(X = x_a + x_b\), and with this, she claims the Monero.</p>
<h3 id="the-refund-1"><a class="header" href="#the-refund-1">The refund</a></h3>
<p>If something goes wrong and Bob never publishes the Monero, Alice needs to wait for the lock height
<code>height_1</code> to pass. This will allow her to create the refund transaction to reclaim her Tari.</p>
<p>Alice constructs the refund transaction with</p>
<p>$$
\begin{aligned}
a_{Sra} &amp;= r_{Sra_a} +  e_s(v_{i}) \\
b_{Sra} &amp;= r_{Sra_b} + x_a + e_s(k_{Sra} + k_i) \\
e_r &amp;= \hash{ (R_{Sr} + (X_a)) \cat \alpha_i \cat \input_i \cat (K_{Sra} + K_{Srb}) \cat C_i} \\
a_{Sr} &amp;= a_{Sra} + a_{Srb} \\
b_{Sr} &amp;= b_{Sra} + b_{Srb} \\
R_{Sr} &amp;= r_{Sra_a} \cdot H + r_{Sra_b} \cdot G + R_{Srb}\\
a_{Mra} &amp;= r_{Mra_a} + e(v_{r}) \\
b_{Mra} &amp;= r_{Mra_b} + e(k_{Ora}+k_r) \\
R_{Mra} &amp;= a_{Mra} \cdot H + b_{Mra} \cdot G \\
e &amp;= \hash{ (R_{Mra} + R_{Mrb}) \cat \script_s \cat F_s \cat (K_{Ora} + K_{Orb}) \cat C_r} \\
R_{Mr} &amp;= R_{Mra} + R_{Mrb} \\
\so_{ra} &amp;= k_{Sra} - k_{Ora} \\
\so_{r} &amp;= \so_{ra} +\so_{rb} \\
\end{aligned}
\tag{28}
$$</p>
<p>This allows Alice to claim back her Tari, but it also exposes her Monero key \(x_a\)
This means if Bob did publish the Monero UTXO, he could calculate \(X\) using:
$$
\begin{aligned}
b_{Sr} &amp;= b_{Sra} + b_{Srb} \\
b_{Sr} - b_{Sra} &amp;= b_{Sra} \\
b_{Sra} &amp;= r_{Sra_b} + x_a + e_r(k_{Sra} + k_i) \\
b_{Sra} - b_{Sra}' &amp;= r_{Sra_b} + x_a + e_r(k_{Sra} + k_i) -(r_{Sra_b} +  e_r(k_{Sra}+k_i))\\
b_{Sra} - b_{Sra}' &amp;= x_a \\
\end{aligned}
\tag{29}
$$</p>
<h3 id="the-lapse-transaction-1"><a class="header" href="#the-lapse-transaction-1">The lapse transaction</a></h3>
<p>If something goes wrong and Alice never publishes her refund transaction, Bob needs to wait for the
lock height <code>height_2</code> to pass. This will allow him to create the lapse transaction to claim the Tari. </p>
<p>Bob constructs the lapse transaction with
$$
\begin{aligned}
a_{Slb} &amp;= r_{Slb_a} +  e_l(v_{i}) \\
b_{Slb} &amp;= r_{Slb_b} + x_b + e_l(k_{Slb} + k_i) \\
e_l &amp;= \hash{ (R_{Sl} + (X_b)) \cat \alpha_i \cat \input_i \cat (K_{Sla} + K_{Slb}) \cat C_i} \\
a_{Sl} &amp;= a_{Sla} + a_{Slb} \\
b_{Sl} &amp;= b_{Sla} + b_{Slb} \\
R_{Sl} &amp;= r_{Slb_a} \cdot H + r_{Slb_b} \cdot G + R_{Sla}\\
a_{Mlb} &amp;= r_{Mlb_a} + e(v_{l}) \\
b_{Mlb} &amp;= r_{Mlb_b} + e(k_{Olb}+k_l) \\
R_{Mlb} &amp;= a_{Mlb} \cdot H + b_{Mlb} \cdot G \\
e &amp;= \hash{ (R_{Mla} + R_{Mlb}) \cat \script_l \cat F_l \cat (K_{Ola} + K_{Olb}) \cat C_l} \\
R_{Ml} &amp;= R_{Mla} + R_{Mlb} \\
\so_{lb} &amp;= k_{Slb} - k_{Olb} \\
\so_{r} &amp;= \so_{la} +\so_{lb} \\
\end{aligned}
\tag{30}
$$</p>
<p>This allows Bob to claim the Tari he originally wanted, but it also exposes his Monero key \(x_b\)
This means if Alice ever comes back online, she can calculate \(X\) and claim the Monero she wanted all along using:
$$
\begin{aligned}
b_{Sl} &amp;= b_{Slb} + b_{Slb} \\
b_{Sl} - b_{Slb} &amp;= b_{Slb} \\
b_{Slb} &amp;= r_{Slb_b} + x_a + e_r(k_{Slb} + k_i) \\
b_{Slb} - b_{Slb}' &amp;= r_{Slb_b} + x_b + e_r(k_{Slb} + k_i) -(r_{Slb_b} +  e_r(k_{Slb}+k_i))\\
b_{Slb} - b_{Slb}' &amp;= x_b \\
\end{aligned}
\tag{31}
$$</p>
<h2 id="notation-3"><a class="header" href="#notation-3">Notation</a></h2>
<p>Where possible, the &quot;usual&quot; notation is used to denote terms commonly found in cryptocurrency literature. Lower case 
characters are used as private keys, while uppercase characters are used as public keys. New terms introduced here are 
assigned greek lowercase letters in most cases. Some terms used here are noted down in <a href="Glossary.html#tariscript">TariScript</a>. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th>Symbol</th><th>Definition</th></tr></thead><tbody>
<tr><td style="text-align: left">subscript s</td><td>\( _s \)</td><td>The swap transaction</td></tr>
<tr><td style="text-align: left">subscript r</td><td>\( _r \)</td><td>The refund transaction</td></tr>
<tr><td style="text-align: left">subscript l</td><td>\( _l \)</td><td>The lapse transaction</td></tr>
<tr><td style="text-align: left">subscript a</td><td>\( _a \)</td><td>Belongs to Alice</td></tr>
<tr><td style="text-align: left">subscript b</td><td>\( _b \)</td><td>Belongs to Bob</td></tr>
<tr><td style="text-align: left">Monero key</td><td>\( X \)</td><td>Aggregate Monero public key encoded with Ristretto</td></tr>
<tr><td style="text-align: left">Alice's Monero key</td><td>\( X_a \)</td><td>Alice's partial  Monero public key encoded with Ristretto</td></tr>
<tr><td style="text-align: left">Bob's Monero key</td><td>\( X_b \)</td><td>Bob's partial  Monero public key encoded with Ristretto</td></tr>
<tr><td style="text-align: left">Monero key</td><td>\( Xm \)</td><td>Aggregate Monero public key encoded with Ed25519</td></tr>
<tr><td style="text-align: left">Alice's Monero key</td><td>\( Xm_a \)</td><td>Alice's partial  Monero public key encoded with Ed25519</td></tr>
<tr><td style="text-align: left">Bob's Monero key</td><td>\( Xm_b \)</td><td>Bob's partial  Monero public key encoded with Ed25519</td></tr>
<tr><td style="text-align: left">Script key</td><td>\( K_s \)</td><td>The <a href="Glossary.html#script-keypair">script key</a> of the utxo</td></tr>
<tr><td style="text-align: left">Alice's Script key</td><td>\( K_sa \)</td><td>Alice's partial <a href="Glossary.html#script-keypair">script key</a></td></tr>
<tr><td style="text-align: left">Bob's Script key</td><td>\( K_sb \)</td><td>Bob's partial <a href="Glossary.html#script-keypair">script key</a></td></tr>
<tr><td style="text-align: left">Alice's adaptor signature</td><td>\( b'_{Sa} \)</td><td>Alice's adaptor signature for the signature \( b_{Sa} \) of the script_signature of the utxo</td></tr>
<tr><td style="text-align: left">Bob's adaptor signature</td><td>\( b'_{Sb} \)</td><td>Bob's adaptor signature for the \( b_{Sb} \) of the script_signature of the utxo</td></tr>
<tr><td style="text-align: left">Ristretto G generator</td><td>\(k \cdot G  \)</td><td>Value k over Curve25519 G generator encoded with Ristretto</td></tr>
<tr><td style="text-align: left">Ristretto H generator</td><td>\(k \cdot H  \)</td><td>Value k over Tari H generator encoded with Ristretto</td></tr>
<tr><td style="text-align: left">ed25519 G generator</td><td>\(k \cdot G_m  \)</td><td>Value k over Curve25519 G generator encoded with Ed25519</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-310submarine-swap"><a class="header" href="#rfc-310submarine-swap">RFC-310/Submarine Swap</a></h1>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/SWvheerden">S W van Heerden</a></p>
<h1 id="licence-39"><a class="header" href="#licence-39">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-41"><a class="header" href="#language-41">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-41"><a class="header" href="#disclaimer-41">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-40"><a class="header" href="#goals-40">Goals</a></h2>
<p>This Request for Comment (RFC) aims to describe how an Atomic swap between Tari and Minotari will be created.</p>
<h2 id="related-requests-for-comment-34"><a class="header" href="#related-requests-for-comment-34">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="RFC-0202_TariScriptOpcodes.html">RFC-0202: TariScript Opcodes</a></li>
<li><a href="RFC-0240_AtomicSwap.html">RFC-0240: AtomicSwap </a></li>
<li><a href="RFC-0241_AtomicSwapXMR.html">RFC-0241: AtomicSwap XMR</a></li>
</ul>
<p>$$
\newcommand{\script}{\alpha} % utxo script
\newcommand{\input}{ \theta }
\newcommand{\cat}{\Vert}
\newcommand{\so}{\gamma} % script offset
\newcommand{\hash}[1]{\mathrm{H}\bigl({#1}\bigr)}
$$</p>
<h2 id="comments-1"><a class="header" href="#comments-1">Comments</a></h2>
<p>Any comments, changes or questions to this PR can be made in one of the following ways:</p>
<ul>
<li>Create a new PR on the Tari project <a href="https://github.com/tari-project/tari/pulls">Github pull requests</a>.</li>
<li>Create a new issue on the Tari project <a href="https://github.com/tari-project/tari/issues">Github issues</a>.</li>
</ul>
<h2 id="description-22"><a class="header" href="#description-22">Description</a></h2>
<p>To be able to exchange Tari and Minotari without the use of some centralized exchange service, we need to do Submarine swaps or Atomic swaps between the two.
We want to keep Tari as bare bones as possible with if possible just a commitment and perhaps a range proof, this means that we will not have access to
smart contract features typically required for doing submarine swaps. This does not mean it is not possible to do atomic swaps with non-smart contract coins,
look at <a href="RFC-0241_AtomicSwapXMR.html">RFC-0241: AtomicSwap XMR</a> to see how this is done with Minotari and Monero.</p>
<h2 id="method-1"><a class="header" href="#method-1">Method</a></h2>
<p>The primary, happy path outline of a Tari - Minotari submarine swap is described here, and more detail will follow. We assume
that Alice wants to trade her Minotari for Bob's Tari.</p>
<ul>
<li>Negotiation - Both parties negotiate the value and other details of the Tari and Minotari commitments.</li>
<li>Commitment - Both parties commit to the keys, nonces, inputs, and outputs to use for the transaction.</li>
<li>Minotari payment - Alice makes the Minotari payment to a UTXO containing a &quot;special&quot; script described below.</li>
<li>Tari Payment - The Tari payment is made to a multiparty <a href="https://tlu.tarilabs.com/cryptography/introduction-to-scriptless-scripts">scriptless script</a> commitment.</li>
<li>Claim Minotari - Bob redeems the Minotari, and in doing so, reveals the Tari private key to Alice only.</li>
<li>Claim Tari - Alice may claim the Tari using the revealed key.</li>
</ul>
<p>Please take note of the notation used in <a href="Glossary.html#tariscript">TariScript</a> and specifically notation used on the signatures on the <a href="RFC-0201_TariScript.html#transaction-input-changes">transaction inputs</a> and on the signatures on the <a href="RFC-0201_TariScript.html#transaction-output-changes">transaction outputs</a>.
We will note other notations in the <a href="RFC-0310_SubmarineSwaps.html#notation">Notation</a> section.</p>
<h2 id="tldr-1"><a class="header" href="#tldr-1">TL;DR</a></h2>
<p>The scheme revolves around Alice, who wants to exchange her Minotari for Bob's Tari. Because they don't trust each 
other, 
they have to commit some information to do the exchange. And if something goes wrong here, we want to ensure that we can 
refund both parties either in Tari or Minotari.</p>
<p>How this works is that Alice and Bob create a shared output on both chains. The Tari output is a simple aggregate key 
to unlock the commitment, while multiple keys are needed to unlock the Minotari UTXO. An aggregate key locks this Tari commitment
that neither Alice nor Bob knows, but they both know half of the key. The current Minotari block height determines the 
unlocking key for the Minotari UTXO.</p>
<p>The process is started by Alice and Bob exchanging and committing to some information. Alice is the first to publish a 
transaction, which creates the Minotari UTXO. If Bob is happy that the Minotari UTXO has been mined and verifies all 
the information, he will publish a transaction to create the Tari commitment.</p>
<p>The TariScript script on the UTXO ensures that they will have to reveal their portion of the Tari key when either 
Alice or Bob spends this. This disclosure allows the other party to claim the Tari by being the only one to own the 
complete Tari aggregate key.</p>
<p>The script will ensure that at any point in time, at least someone can claim the Minotari UTXO, and if that person 
does so,  the other party can claim the Tari commitment by looking at the spending data. It has two lock heights, 
determining who can claim the Minotari UTXO if the happy path fails. Before the first lock height, only Bob can claim 
the Tari; we call this the 
swap transaction.</p>
<p>If Bob disappears after Alice has posted the Minotari UTXO, Alice can claim the Minotari after the first lock height and before 
the second lock height; we call this the refund transaction. It ensures that Alice can reclaim her Minotari if Bob 
disappears, and if Bob reappears, he can reclaim his Tari.</p>
<p>That leaves us with the scenario where Alice disappears after Bob posts the Tari transaction, in which case we need to 
protect Bob. After the second lock height, only Bob can claim the Minotari; we call this the lapse transaction. The lapse 
transaction will reveal Bob's Tari key so that if Alice reappears, she can claim the Tari.</p>
<h2 id="heights-security-and-other-considerations-1"><a class="header" href="#heights-security-and-other-considerations-1">Heights, Security, and other considerations</a></h2>
<p>We need to consider a few things for this to be secure, as there are possible scenarios that can reduce the security in the atomic swap. </p>
<p>When looking at the two lock heights, the first lock height should be sufficiently large enough to give ample time for Alice to post the Tari UTXO transaction and for it to be mined with a safe number of confirmations,
and for Bob to post the Tari transaction and for it to be mined with a safe number of confirmations. The second lock
height should give ample time for Alice after the first lock height to re-claim her Minotari. Larger heights here might make
refunds slower, but it should be safer in giving more time to finalize this. </p>
<p>Allowing both to claim the Minotari after the second lock height is, on face value, a safer option. This can be done by enabling
either party to claim the script with the lapse transaction. The counterparty can then claim the Tari. However, this
will open up an attack vector to enable either party to claim the Tari while claiming the Minotari. Either party could 
trivially
pull off such a scheme by performing a front-running attack and having a bit of luck. The counterparty monitors all broadcast 
transactions to base nodes. Upon identifying the lapse transaction, they do two things; in quick succession, broadcast 
their lapse transaction and the transaction to claim the Tari, both with sufficiently high fees. Base nodes will 
prefer to mine transactions with the higher fees, and thus the counterparty can walk away with both the Minotari and the 
Tari.</p>
<p>It is also possible to prevent the transaction from being mined after being submitted to the mempool. 
This can be caused by a combination of a too busy network, not enough fees, or a too-small period in the time locks.
When one of these atomic swap transactions gets published to a mempool, we effectively  already have all the details 
exposed. For the atomic swaps, it means we already revealed part of the Tari key, although the actual Minotari 
transaction has not been mined. But this is true for any HTLC or like script on any blockchain. 
But in the odd  chance that this does happen whereby the fees are too little and time locks not enough, it should be 
possible to do a child-pays-for-parent transaction to bump up the fees on the transaction to get it mined and confirmed.</p>
<h2 id="key-construction-1"><a class="header" href="#key-construction-1">Key construction</a></h2>
<p>Using <a href="https://reyify.com/blog/flipping-the-scriptless-script-on-schnorr">multi-signatures</a> with Schnorr signatures, we
need to ensure that the keys are constructed so that key cancellation attacks are not possible. To do this, we create new
keys from the chosen public keys \(K_a'\) and \(K_b'\)</p>
<p>$$
\begin{aligned}
K_a &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_a' } * K_a' \\
k_a &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_a' } * k_a' \\
K_b &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_b' } * K_b' \\
k_b &amp;=  \hash{\hash{K_a' \cat K_b'} \cat K_b' } * k_b' \\
\end{aligned}
\tag{1}
$$</p>
<h2 id="key-security-1"><a class="header" href="#key-security-1">Key security</a></h2>
<p>The risk of publicly exposing part of the Tari private key is still secure because of how <a href="https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc#private-key-public-key-and-the-generator-point-in-ecc">ECC</a> works. We can
add two secret keys together and share the public version of both. And at the same time, we know that no one can calculate
the secret key with just one part.</p>
<p>$$
\begin{aligned}
(k_a + k_b) \cdot G &amp;= k_a \cdot G + k_b \cdot G\\
(k_a + k_b) \cdot G &amp;= K_a + K_b \\
(k_a + k_b) \cdot G &amp;= K \\
\end{aligned}
\tag{5}
$$</p>
<p>We know that \(K\), \(K_a\), \(K_b\) are public. While \(k\), \(k_a\), \(k_b\) are all private.</p>
<p>But if we expose \(k_b\), we can try to do the following:
$$
\begin{aligned}
(k_a + k_b) \cdot G &amp;= K_a + K_b\\
k_a \cdot G &amp;= (K_a + K_b - k_b \cdot G) \\
k_a \cdot G &amp;= K_a \\
\end{aligned}
\tag{6}
$$</p>
<p>However, this is the Elliptic-Curve Discrete Logarithm Problem, and there is no easy solution to solve this on current computer
hardware. Thus this is still secure even though we leaked part of the secret key \(k\).</p>
<h2 id="method-2"><a class="header" href="#method-2">Method</a></h2>
<h3 id="detail-2"><a class="header" href="#detail-2">Detail</a></h3>
<p>We rely purely on TariScript to enforce the exposure of the private Tari aggregate keys. Based on <a href="https://suredbits.com/payment-points-part-1/">Point Time Lock Contracts</a>, 
the script forces the spending party to supply their Tari private key part as input data to the script, evaluated via the operation <code>ToRistrettoPoint</code>. This TariScript 
operation will publicly reveal part of the aggregated Tari private key, but this is still secure: see <a href="RFC-0310_SubmarineSwaps.html#key-security">Key security</a>.</p>
<p>The simplicity of this method lies therein that the spending party creates all transactions on their 
own. Bob requires a pre-image from Alice to complete the swap transaction; Alice needs to verify that Bob published the 
Tari transaction and that everything is complete as they have agreed. If she is happy, she will provide Bob with the 
pre-image to claim the Tari UTXO.</p>
<h3 id="tariscript-3"><a class="header" href="#tariscript-3">TariScript</a></h3>
<p>The Script used for the Tari UTXO is as follows:</p>
<pre><code class="language-TariScript ignore">   ToRistrettoPoint
   CheckHeight(height_1)
   LtZero
   IFTHEN
      PushPubkey(X_b)
      EqualVerify
      HashSha256 
      PushHash(HASH256{pre_image})
      EqualVerify
      PushPubkey(K_{Sb})
   Else
      CheckHeight(height_2)
      LtZero
      IFTHEN
         PushPubkey(X_a)
         EqualVerify
         PushPubkey(K_{Sa})
      Else
         PushPubkey(X_b)
         EqualVerify
         PushPubkey(K_{Sb})
      ENDIF
   ENDIF
</code></pre>
<p>Before <code>height_1</code>, Bob can claim the Minotari UTXO by supplying <code>pre_image</code> and his private Tari key part <code>x_b</code>. After 
<code>height_1</code> but before <code>height_2</code>, Alice can claim the Minotari UTXO by supplying her private Tari key part <code>x_a</code>. After 
<code>height_2</code>, Bob can claim the Minotari UTXO by providing his private Tari key part <code>x_b</code>.</p>
<h3 id="negotiation-2"><a class="header" href="#negotiation-2">Negotiation</a></h3>
<p>Alice and Bob have to negotiate the exchange rate and the amount exchanged in the atomic swap. They also need to decide 
how the two UTXO's will look on the blockchain. To accomplish this, the following needs to be finalized:</p>
<ul>
<li>Amount of Minotari to swap for the amount of Tari</li>
<li>Tari public key parts \(X_a\), \(X_b\) ,and its aggregate form \(X\)</li>
<li>Minotari <a href="Glossary.html#script-keypair">script key</a> parts \(K_{Sa}\), \(K_{Sb}\) </li>
<li>The <a href="Glossary.html#tariscript">TariScript</a> to be used in the Minotari UTXO</li>
<li>The blinding factor \(k_i\) for the Minotari UTXO, which can be a Diffie-Hellman between their Tari network 
addresses.</li>
</ul>
<h3 id="key-selection-2"><a class="header" href="#key-selection-2">Key selection</a></h3>
<p>Using (1), we create the Tari keys as they are multi-party aggregate keys.
The Tari key parts for Alice and Bob is constructed as follows:</p>
<p>$$
\begin{aligned}
X_a' &amp;= x_a' \cdot G \\
X_b' &amp;= x_b' \cdot G \\
x_a &amp;=  \hash{\hash{X_a' \cat X_b'} \cat X_a' } * x_a' \\
x_b &amp;=  \hash{\hash{X_a' \cat X_b'} \cat X_b' } * x_b' \\
x_a &amp;= x_a \\
x_b &amp;= x_b \\
X_a &amp;=  \hash{\hash{X_a' \cat X_b'} \cat X_a' } * X_a' \\
X_b &amp;=  \hash{\hash{X_a' \cat X_b'} \cat X_b' } * X_b' \\
x &amp;= x_a + x_b + k_i \\
X &amp;= X_a + X_b + k_i \cdot G_m\\
x &amp;= x_a + x_b + k_i \\
X &amp;= X_a + X_b + k_i \cdot G\\
\end{aligned}
\tag{7}
$$</p>
<h3 id="commitment-phase-2"><a class="header" href="#commitment-phase-2">Commitment phase</a></h3>
<p>This phase allows Alice and Bob to commit to using their keys.</p>
<h4 id="starting-values-2"><a class="header" href="#starting-values-2">Starting values</a></h4>
<p>Alice needs to provide Bob with the following:</p>
<ul>
<li>Script public key: \( K_{Sa}\)</li>
<li>Tari public key \( X_a'\)</li>
</ul>
<p>Bob needs to provide Alice with the following:</p>
<ul>
<li>Script public key: \( K_{Sb}\)</li>
<li>Tari public key \( X_b'\)</li>
</ul>
<p>Using the above equations in (7), Alice and Bob can calculate \(X\), \(X_a\), \(X_b\)</p>
<h3 id="minotari-payment"><a class="header" href="#minotari-payment">Minotari payment</a></h3>
<p>Alice will construct the Minotari UTXO with the correct <a href="RFC-0310_SubmarineSwaps.html#tariscript">script</a> and publish the containing transaction to the 
blockchain, knowing that she can reclaim her Minotari if Bob vanishes or tries to break the agreement. This is done with 
standard Mimblewimble rules and signatures.</p>
<h3 id="tari-payment"><a class="header" href="#tari-payment">Tari payment</a></h3>
<p>When Bob sees that the Minotari UTXO that Alice created is mined on the Minotari blockchain with the correct script, Bob can
publish the Tari transaction containing the Tari commitment with the aggregate key \(X = X_a + X_b + k_i \cdot G \).</p>
<h3 id="claim-minotari"><a class="header" href="#claim-minotari">Claim Minotari</a></h3>
<p>When Alice sees that the Tari commitment that Bob created is confirmed on the second layer containing the correct aggregate 
key \(X\), she can provide Bob with the required <code>pre_image</code> to spend the Minotari UTXO. She does not have the 
missing key \(x_b \) to claim the Tari yet, but it will be revealed when Bob claims the Minotari. </p>
<p>Bob can now supply the <code>pre_image</code> and his Tari private key as transaction input to unlock the script.</p>
<h3 id="claim-tari"><a class="header" href="#claim-tari">Claim Tari</a></h3>
<p>Alice can now see that Bob spent the Minotari UTXO, and by examining the <code>input_data</code> required to satisfy the script, she 
can learn Bob's secret Tari key. Although this private key \( x_b \) is now public knowledge, her part of the Tari spend key 
is still private, and thus only she knows the complete Tari spend key. She can use this knowledge to claim the Tari commitment.</p>
<h3 id="the-refund-2"><a class="header" href="#the-refund-2">The refund</a></h3>
<p>If something goes wrong and Bob never publishes the Tari or disappears, Alice needs to wait for the lock height
<code>height_1</code> to pass. This will allow her to reclaim her Minotari, but in doing so, she needs to publish her Tari secret key 
as input to the script to unlock the Minotari. When Bob comes back online, he can use this public knowledge to reclaim his 
Tari, as only he knows both parts of the Tari commitment spend key.</p>
<h3 id="the-lapse-transaction-2"><a class="header" href="#the-lapse-transaction-2">The lapse transaction</a></h3>
<p>If something goes wrong and Alice never gives Bob the required <code>pre_image</code>, Bob needs to wait for the lock height
<code>height_2</code> to pass. This will allow him to claim the Minotari he wanted all along, but in doing so, he needs to publish
his Tari secret key as input to the script to unlock the Minotari. When Alice comes back online, she can use this public 
knowledge to claim the Tari she wanted all along as only she now knows both parts of the Tari commitment spend key.</p>
<h2 id="notation-4"><a class="header" href="#notation-4">Notation</a></h2>
<p>Where possible, the &quot;usual&quot; notation is used to denote terms commonly found in cryptocurrency literature. Lower case 
characters are used as private keys, while uppercase characters are used as public keys. New terms introduced here are 
assigned greek lowercase letters in most cases. Some terms used here are noted down in <a href="Glossary.html#tariscript">TariScript</a>. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th>Symbol</th><th>Definition</th></tr></thead><tbody>
<tr><td style="text-align: left">subscript s</td><td>\( _s \)</td><td>The swap transaction</td></tr>
<tr><td style="text-align: left">subscript r</td><td>\( _r \)</td><td>The refund transaction</td></tr>
<tr><td style="text-align: left">subscript l</td><td>\( _l \)</td><td>The lapse transaction</td></tr>
<tr><td style="text-align: left">subscript a</td><td>\( _a \)</td><td>Belongs to Alice</td></tr>
<tr><td style="text-align: left">subscript b</td><td>\( _b \)</td><td>Belongs to Bob</td></tr>
<tr><td style="text-align: left">Tari key</td><td>\( X \)</td><td>Aggregate Tari public key</td></tr>
<tr><td style="text-align: left">Alice's Tari key</td><td>\( X_a \)</td><td>Alice's partial Tari public key</td></tr>
<tr><td style="text-align: left">Bob's Tari key</td><td>\( X_b \)</td><td>Bob's partial Tari public key</td></tr>
<tr><td style="text-align: left">Script key</td><td>\( K_s \)</td><td>The <a href="Glossary.html#script-keypair">script key</a> of the utxo</td></tr>
<tr><td style="text-align: left">Alice's Script key</td><td>\( K_sa \)</td><td>Alice's partial <a href="Glossary.html#script-keypair">script key</a></td></tr>
<tr><td style="text-align: left">Bob's Script key</td><td>\( K_sb \)</td><td>Bob's partial <a href="Glossary.html#script-keypair">script key</a></td></tr>
<tr><td style="text-align: left">Alice's adaptor signature</td><td>\( b'_{Sa} \)</td><td>Alice's adaptor signature for the signature \( b_{Sa} \) of the script_signature of the utxo</td></tr>
<tr><td style="text-align: left">Bob's adaptor signature</td><td>\( b'_{Sb} \)</td><td>Bob's adaptor signature for the \( b_{Sb} \) of the script_signature of the utxo</td></tr>
<tr><td style="text-align: left">Ristretto G generator</td><td>\(k \cdot G  \)</td><td>Value k over Curve25519 G generator encoded with Ristretto</td></tr>
</tbody></table>
</div>
<h1 id="change-log-35"><a class="header" href="#change-log-35">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">23 Oct 2023</td><td style="text-align: left">Thaum -&gt; Tari</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">15 Nov 2022</td><td style="text-align: left">First outline</td><td style="text-align: left">SWvHeerden</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0388-bearer-tokens"><a class="header" href="#rfc-0388-bearer-tokens">RFC-0388 Bearer Tokens</a></h1>
<h2 id="a-scheme-for-granting-the-bearer-permissions-on-second-layer-assets"><a class="header" href="#a-scheme-for-granting-the-bearer-permissions-on-second-layer-assets">A Scheme for Granting the Bearer Permissions on Second Layer Assets</a></h2>
<p><img src="theme/images/status-raw.svg" alt="status: raw" /></p>
<p><strong>Maintainer(s)</strong>: @mikethetike</p>
<h1 id="licence-40"><a class="header" href="#licence-40">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-42"><a class="header" href="#language-42">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-42"><a class="header" href="#disclaimer-42">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-41"><a class="header" href="#goals-41">Goals</a></h2>
<p>Many dapps and web3 enabled applications require the ability to spend or interact with the assets
that a user owns on their behalf. Ethereum and many other blockchains achieve this in a stateful
manner by invoking methods such as 'approve' and 'approve_all' in ERC20 and ERC721. Being stateful, 
the user must spend fees in order to add or revoke permissions. When fees are high, or due to 
simplistic user interfaces, a user will often grant a much higher level of permission than is required. 
For example, the user may approve a service to transfer all of their funds, or all of their NFTs.</p>
<p>The scheme proposed by this RFC is a stateless token that the bearer can use to invoke methods on the 
DAN layer.</p>
<h2 id="related-requests-for-comment-35"><a class="header" href="#related-requests-for-comment-35">Related Requests for Comment</a></h2>
<h2 id="description-23"><a class="header" href="#description-23">Description</a></h2>
<p>This scheme is inspired by <a href="https://www.ndss-symposium.org/ndss2014/programme/macaroons-cookies-contextual-caveats-decentralized-authorization-cloud/">Macaroons</a> in that it allows the bearer of a token to delegate a more restrictive token to
another bearer. </p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<h3 id="auth-token"><a class="header" href="#auth-token">Auth Token</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>root_nonce</td><td>bytes(32) (optional)</td><td>a base ID used to revoke permissions(see below)</td></tr>
<tr><td>expires_at_height</td><td>u64 (optional)</td><td>the sidechain height at which this token expires. Timestamps are not reliable in blockchains, so height is used in this case</td></tr>
<tr><td>granted_to</td><td>pubkey</td><td>the public key of the grantee. Any bearer using this token will need to prove knowledge of the private key</td></tr>
<tr><td>scopes</td><td>string[]</td><td>A list of scopes granted to this scope</td></tr>
<tr><td>caveats</td><td>CaveatExpression[]</td><td>An ordered list of caveats</td></tr>
<tr><td>based_on</td><td>Token (optional)</td><td>If this token is derived from another token, it should be present here</td></tr>
<tr><td>issuer</td><td>PubKey</td><td>the issuer of this token</td></tr>
<tr><td>issuer_sig</td><td>Signature</td><td>a signature signed by <code>issuer</code> of the challenge <code>Hash(root_nonce + granted_to + scopes + caveats + expires_at_height + based_on + issuer )</code></td></tr>
</tbody></table>
</div>
<h3 id="caveat-expression"><a class="header" href="#caveat-expression">Caveat Expression</a></h3>
<pre><code class="language-text">Caveat Expression = &lt;Field&gt; &lt;operator&gt; &lt;Argument&gt;
</code></pre>
<p>Field: An arbitrary string that will be interpreted by the code
Operator: OneOf(&quot;eq&quot;, &quot;le&quot;, &quot;lt&quot;,&quot;ge&quot;, &quot;gt&quot;)
Argument: A constant value, to be interpreted by the code</p>
<p>Examples</p>
<pre><code class="language-text">amount lt 1000
token_id eq 4759
</code></pre>
<h2 id="delegation"><a class="header" href="#delegation">Delegation</a></h2>
<p>A bearer of a token may grant another identity a more specific token, provided that the scopes and caveats are more restrictive.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>The root_nonce, if specified must match the root nonce on record for the issuer.</p>
<blockquote>
<p>Open question: should root nonce just be a special caveat?</p>
</blockquote>
<p>Before starting execution of the instruction, the list of auth tokens must be validated to ensure that each token is more restrictive than
the last.</p>
<p>When executing instructions, caveats MUST be checked if they are relevant to the resources being acted upon. 
For example, if a function requires a scope <code>transfer</code>, the most specific AuthToken must have that scope present.</p>
<h2 id="revoking-tokens"><a class="header" href="#revoking-tokens">Revoking Tokens</a></h2>
<p>Each contract SHOULD store a root nonce for each identity in the contract. To revoke a set of tokens, an identity owner
may change their root nonce. This will revoke all tokens based on this root.</p>
<h3 id="example-1-invoking-an-instruction"><a class="header" href="#example-1-invoking-an-instruction">Example 1: Invoking an instruction</a></h3>
<p>In this example, Alice wants to allow Bob to spend 100 of a fungible asset called <code>WARI</code> from her account.</p>
<p>Let's assume the transfer function looks like this:</p>
<pre><code class="language-nocompile">fn transfer(amount: u64, from: PublicKey, to: PublicKey) 
{
   requires_scope(&quot;transfer&quot;, from);
   // ...
}
</code></pre>
<p>Alice creates a token:</p>
<pre><code class="language-json5">/* bob's token */
{
   &quot;scopes&quot;: [&quot;transfer&quot;],
   &quot;granted_to&quot;: &quot;&lt;Bob's Public Key&gt;&quot;,
   &quot;caveats&quot;: [
      &quot;amount le 100&quot;
   ],
   &quot;issuer&quot;: &quot;&lt;Alice's Public Key&gt;&quot;,
   &quot;issuer_sig&quot;: &quot;&lt;sig&gt;&quot;
}
</code></pre>
<blockquote>
<p>Note: The <code>root_nonce</code> and <code>expires_at_height</code> are missing here, but it would have been better for Alice to include these.
Also, this token allows Bob to spend up to 100 at a time, but does not restrict Bob from using this token again</p>
</blockquote>
<p>Bob can now create the instruction and submit it to the validator node. The validator node checks that the instruction signature
matches the public key in <code>granted_to</code> and also checks that the <code>amount</code> parameter is less than or equal to 100. Finally, the
validator node checks that the scope includes 'transfer', and Alice's public key (specified in <code>from</code>) matches the auth token's issuer signature.</p>
<h3 id="example-2-delegation"><a class="header" href="#example-2-delegation">Example 2: Delegation</a></h3>
<p>Let's continue the example, but in this case Bob wants to allow Carol to spend the funds.</p>
<p>In this case, Bob creates a token for Carol with the following:</p>
<pre><code class="language-json5">/* carol's token */
{
   &quot;scopes&quot;: [&quot;transfer&quot;],
   &quot;granted_to&quot;: &quot;&lt;Carol's Public Key&quot;,
   &quot;caveats&quot;: [
      &quot;amount le 90&quot;
   ],
   &quot;issuer&quot;: &quot;&lt;Bob's Public Key&gt;&quot;,
   &quot;issuer_sig&quot;: &quot;&lt;sig&gt;&quot;,
   &quot;based_on&quot;: {
      /* bob's token */
   }
}
</code></pre>
<p>Carol can now create a set of instructions, attach the token and sign it with her public key.</p>
<pre><code class="language-json">{
   &quot;instructions&quot;: [
      {
         &quot;method&quot;: &quot;transfer&quot;,
         &quot;amount&quot;: &quot;80&quot;,
         &quot;from&quot;: &quot;&lt;alice's pub key&gt;&quot;,
         &quot;to&quot;: &quot;&lt;carol's pub key&gt;&quot;
      },
      {
         &quot;method&quot;: &quot;transfer&quot;,
         &quot;amount&quot;: &quot;10&quot;,
         &quot;from&quot;: &quot;&lt;alice's pub key&gt;&quot;,
         &quot;to&quot;: &quot;&lt;bob's pub key&gt;&quot;
      }
   ],
   &quot;authority&quot;: {
      &quot;bearer&quot;: {/* carol's token */},
      &quot;sig&quot;: &quot;&lt;sig with carol's pub key&gt;&quot;
   }
}
</code></pre>
<p>When the validator node receives a set of instructions with this token, it must process each token recursively, with respect to
the token it is based on. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-8001multipartytransactions"><a class="header" href="#rfc-8001multipartytransactions">RFC-8001/MultiPartyTransactions</a></h1>
<h2 id="time-related-transactions-1"><a class="header" href="#time-related-transactions-1">Time related transactions</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/SWvheerden">SW van heerden</a></p>
<h1 id="license-2"><a class="header" href="#license-2">License</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD License</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-43"><a class="header" href="#language-43">Language</a></h2>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-43"><a class="header" href="#disclaimer-43">Disclaimer</a></h2>
<p>The purpose of this document and its content is for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-42"><a class="header" href="#goals-42">Goals</a></h2>
<p>This document describes a few extension to <a href="MimbleWimble">MimbleWimble</a> to allow multi-party <a href="utxo">UTXOs</a>.</p>
<h2 id="related-rfcs-2"><a class="header" href="#related-rfcs-2">Related RFCs</a></h2>
<h2 id="description-24"><a class="header" href="#description-24">Description</a></h2>
<h4 id="multi-party-utxo"><a class="header" href="#multi-party-utxo">Multi Party UTXO</a></h4>
<p>Normal <a href="Glossary.html#mimblewimble">MimbleWimble</a> does not have the concept of a <a href="Glossary.html#multisig">multisig</a> UTXO. The UTXO is a commitment <code>C(v,r) = r·G + v·H</code> with
the value blinded. However, the blinding factor <code>r</code> can be composed of multiple blinding factors where <code>r = r1 + r2 + ... + rn</code>, as Pedersen commitments are linear.</p>
<p>The output commitment can then be constructed as <code>C(v,r) = r1·G + r2·G + ... + rn·G + v·H = (r1 + r2 + ... + rn)·G + v·H</code>.
This can be exploited for multiple users where each participant has their own <code>ri</code> and keeps their private blinding factor
hidden and only provides their public blinding factor.</p>
<p>The base layer is oblivious as to how the commitment and related signature were constructed.
To open such commitments (in order to spend it) only the n-of-n blinding factor <code>r</code> is required, and not the original
aggregated signature that was used to sign the transaction. The parties that wants to open the commitment needs to
collaborate to produce the n-of-n blinding factor <code>r</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-8002transactionprotocol"><a class="header" href="#rfc-8002transactionprotocol">RFC-8002/TransactionProtocol</a></h1>
<h2 id="transaction-protocol"><a class="header" href="#transaction-protocol">Transaction Protocol</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: Cayle Sharrock <CjS77></p>
<h1 id="licence-41"><a class="header" href="#licence-41">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-44"><a class="header" href="#language-44">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-44"><a class="header" href="#disclaimer-44">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-43"><a class="header" href="#goals-43">Goals</a></h2>
<p>This Request for Comment (RFC) describes the transaction protocol for peer-to-peer Tari payments using 
the Mimblewimble protocol. It also considers some attacks that may be launched against the protocol and offers some 
discussion around those attacks and potential alternatives to the protocol.</p>
<p>The goal is to describe a transaction protocol that:</p>
<ul>
<li>permits multiple recipients;</li>
<li>preserves privacy regarding how many parties are involved in the transaction; and</li>
<li>is secure against all reasonable attacks.</li>
</ul>
<h2 id="related-requests-for-comment-36"><a class="header" href="#related-requests-for-comment-36">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0111_BaseNodeArchitecture.html">RFC-0111: Base Node Architecture</a></li>
</ul>
<h2 id="description-25"><a class="header" href="#description-25">Description</a></h2>
<p>The Tari base layer is built using <a href="https://tlu.tarilabs.com/protocols/grin-protocol-overview/MainReport.html" title="Mimblewimble on TLU">Mimblewimble</a>, which requires that all parties involved in a Tari transfer must interact
to construct a valid <a href="https://tlu.tarilabs.com/protocols/mimblewimble-1/MainReport.html" title="Mimblewimble
transactions on TLU">Mimblewimble transaction</a>.</p>
<p>A valid transaction involves:</p>
<ul>
<li>a set of one or more inputs being spent by the Sender;</li>
<li>a set of zero or more outputs being sent to the Sender;</li>
<li>a set of recipients, each of whom MUST construct exactly one output; and</li>
<li>a set of partial Schnorr signatures which, when aggregated, validates the transaction construction and indicates every
party's satisfaction with the terms.</li>
</ul>
<h3 id="the-issue-with-multiple-recipients"><a class="header" href="#the-issue-with-multiple-recipients">The Issue with Multiple Recipients</a></h3>
<p>Each party involved in a Tari transaction must produce a partial signature, signing the same challenge. This challenge is
defined as</p>
<p>$$ e = H(\Sigma R_i \Vert \Sigma P_i \Vert m) $$</p>
<p>where \(R_i\) are public nonces generated by each party for this signature; \(P_i\) are the public <a href="Glossary.html#spending-key">Spending Key</a>s;
and <em>m</em> is the additional metadata for the transaction. \(\Sigma P_i\) is the value of the (pre-offset) excess that is
stored in the transaction kernel.</p>
<p>Notice that every signing party needs to know the sum of all the nonces and public spending keys. This suggests that
every party knows how many parties are involved in the transaction, which is not an ideal privacy scenario. It would be
preferable if a secure scheme could be found where each recipient interacts only with the sender and does not need to
calculate these sums themselves.</p>
<p>Unfortunately, as discussed below, it seems that using any known scheme, it's not possible to satisfy this
privacy goal while achieving the desired security level.</p>
<h3 id="the-issue-with-multiple-senders"><a class="header" href="#the-issue-with-multiple-senders">The Issue with Multiple Senders</a></h3>
<p>To increase privacy, the public excess values are <a href="https://github.com/mimblewimble/grin/blob/master/doc/intro.md#kernel-offsets">offset</a> by a constant random value. The choice of this value, as well
as fee selection, can only be set once per transaction. The privilege of selecting these values is generally bestowed on
the sender, since the sender pays the fee. Allowing multiple sending parties (or equivalently, allowing recipients to provide
inputs) would require a negotiation round to set the fee and offset before the transaction could be constructed. This is
a complication we don't want to deal with, and so all schemes presented here allow exactly one sender.</p>
<h3 id="two-party-transactions"><a class="header" href="#two-party-transactions">Two-party Transactions</a></h3>
<p>Two-party transactions are fairly straightforward and are described in detail by Tari Labs University (TLU). (Refer to 
<a href="https://tlu.tarilabs.com/protocols/mimblewimble-1/MainReport.html" title="Mimblewimble
transactions on TLU">Mimblewimble Transaction</a>.)</p>
<p>It is proposed that Tari implement this single-round two-party transaction scheme as a special case to support both online
two-party transactions as well as &quot;offline&quot; transactions such as via email, text message and carrier pigeon.</p>
<h3 id="multiple-recipient-transaction-scheme"><a class="header" href="#multiple-recipient-transaction-scheme">Multiple-recipient Transaction Scheme</a></h3>
<div class="mermaid">
sequenceDiagram
    participant Sender
    participant Receivers
# Sender Initializes the transaction
    activate Sender
        Sender-->>Sender: initialize
    deactivate Sender
# Sender transmits initial data to all receivers
    activate Sender
        Sender-->>+Receivers: [tx_id, amt_i,H(Rs||Xs),m]
        note left of Sender: CollectingCommitments
        note right of Receivers: SendingCommitment
        Receivers-->>-Sender: [tx_id, H(Ri||Pi)]
     deactivate Sender
# Receiving Outputs
     activate Sender
        Sender-->>+Receivers: [tx_id, [Hashed commitments]]
        note left of Sender: CollectingPubKeys
        note right of Receivers: SendingOutput
        Receivers-->>-Sender: [tx_id, Pi, Ri, C_i, RP_i]
    deactivate Sender
    alt inflation_error()?
        Sender--XReceivers: [tx-id, failed]
    end
# Signature collection
    activate Sender
        Sender-->>+Receivers: [tx_id, [Rs, Ri] [Xs, Pi]]
        note left of Sender: CollectingSignatures
        note right of Receivers: Signing
        Receivers-->>Receivers: validate nonces, pubkeys and pubkey sum
        alt invalid
           Receivers--XSender: failed
        end
        Receivers-->>Receivers: Sign
        Receivers-->>-Sender: [tx_id, s_i]
    deactivate Sender
# Sender sends final notification of result
    note left of Sender: Finalizing
    alt is_valid()
      Sender-->>Receivers: [tx_id, OK]
    else invalid
      Sender--XReceivers: [tx_id, Failed]
    end
</div>
<p>** Legend **</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Symbol</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: left">tx_id</td><td style="text-align: left">Transaction identifier</td></tr>
<tr><td style="text-align: left">amt_i</td><td style="text-align: left">Amount sent to i-th recipient</td></tr>
<tr><td style="text-align: left">Rs, Ri</td><td style="text-align: left">Public nonce</td></tr>
<tr><td style="text-align: left">Xs, Pi</td><td style="text-align: left">Public excess/key</td></tr>
<tr><td style="text-align: left">m</td><td style="text-align: left">Message metadata</td></tr>
<tr><td style="text-align: left">C_i</td><td style="text-align: left">Commitment</td></tr>
<tr><td style="text-align: left">RP_i</td><td style="text-align: left">Range proof</td></tr>
<tr><td style="text-align: left">[..]</td><td style="text-align: left">Vector of data</td></tr>
</tbody></table>
</div>
<h2 id="transaction-id"><a class="header" href="#transaction-id">Transaction ID</a></h2>
<p>The scheme above makes use of a <code>tx_id</code> field in every peer-to-peer message. Since all messages are stateless and
asynchronous, peers need some way of figuring out which message refers to which transaction. The transaction ID fulfils
this role.</p>
<p>The ID does not appear on the blockchain in any manner; is purely used to disambiguate Tari transaction messages and
can be discarded after the transaction is broadcast to the network.</p>
<p>The <code>tx_id</code> is unique for every receiver so that any observers of the communication will not be able to group receivers
together (however, the communication should be over secure channels in general).</p>
<p>The format of the transaction ID is a four-byte, little-endian integer (u64) and is
calculated as</p>
<pre><code class="language-text">H(Rs||i)[0..4]
</code></pre>
<p>where <code>i</code> is the i-th recipient in the transaction. The sender can use the <code>tx_id</code> as a hash map key to identify and
differentiate recipients.</p>
<h2 id="replay-attacks"><a class="header" href="#replay-attacks">Replay Attacks</a></h2>
<p>If any party can be convinced to sign a different message with the same nonce, its private keys will be lost. One way
of achieving this would be if a virtual machine could be &quot;snapshotted&quot; or otherwise cloned at any point between sharing
the public nonce and signing the message. Both copies of the victim's machine will now continue, unaware that there's a
copy participating in a signature round. What then happens is:</p>
<p>$$
\begin{align}
&amp;\text{Clone A} &amp; &amp;\text{Clone B} \\
e_1 &amp;= H(r_1 \Vert r_s \Vert \dots) &amp; e_2 &amp;= H(r_1 \Vert r_s^* \Vert \dots) \\
s_1 &amp;= r_1 + e_1 \cdot k_1 &amp; s_2 &amp;= r_1 + e_2 \cdot k_1 \\
\end{align}
$$</p>
<p>The attacker receives both signatures and trivially calculates the secret key:</p>
<p>$$
\begin{align}
\Delta s &amp;= s_1 - s_2 \\
&amp;= k_1(e_1 - e_2) = k_1\Delta e \\
\Rightarrow k_1 &amp;= \frac{\Delta s}{\Delta e}
\end{align}
$$</p>
<p>We've demonstrated this with the attacker changing their nonce, but literally any alteration to the challenge will provide
a new challenge \(e_2\), enabling the attack.</p>
<p>What can we do about this? In fact, it's not possible to eliminate this attack at all! The reason sits with the proof
that the Schnorr scheme works as a zero-knowledge protocol; the demonstration of this proof is precisely the attack
we're trying to avoid [<a href="https://medium.com/magicofc/interactive-proofs-and-zero-knowledge-b32f6c8d66c3" title="On Interactive Proofs and
Zero-Knowledge: A Primer [Section 3]">GOL19</a>]. If we could eliminate this attack, we'd need to come up with a completely different way
of proving the zero-knowledge property.</p>
<p>So we can't stop it, but we can make it as tricky as possible for the attacker to trick the receiver into replaying the
signature. MuSig does this by requiring parties to share the hash of their nonces beforehand. At its extreme: in the
two-party, single-round scheme, for example, the attacker would need to be able to control the victim's machine code
execution (like running a debugger), at which point one might think the attacker could read the private key directly
from memory anyway.</p>
<h2 id="rogue-key-attacks"><a class="header" href="#rogue-key-attacks">Rogue Key Attacks</a></h2>
<p><a href="https://tlu.tarilabs.com/cryptography/digital_signatures/introduction_schnorr_signatures.html#key-cancellation-attack">Rogue Key attacks</a>
are another type of attack that can occur in multi-signature schemes.</p>
<p>In this case, the attacker has the freedom to choose a key or nonce <em>after</em> the victim has already disclosed theirs. This
may allow the attacker to forge a valid signature on behalf of the victim. A recent paper, [<a href="https://eprint.iacr.org/2018/417.pdf" title="On the Security of Two-Round Multi-Signatures">DRI19</a>], suggests that
<em>any</em> Schnorr-based, two-round multi-signature scheme is vulnerable to a rogue key attack.</p>
<p>How this might apply in an insecure two-round Tari multi-signature scheme is as follows: A receiver sends their public
nonce; output commitment and range proof; and public spending key to the sender, but then decides to cancel the
transaction by refusing to provide a signature and sending an &quot;Abort&quot; message to the sender instead. The sender could,
if they wanted, forge the 2-of-2 signature using this rogue key attack and broadcast the transaction anyway.</p>
<p><strong>Note:</strong> This attack is not applicable in the one-round, two-party scheme, since the receiver returns their information in an
all-or-nothing manner. However, the <em>receiver</em> could attempt to forge a signature, since they have the Sender's public
nonce, but there's nothing they can really do with this signature; they certainly cannot broadcast a transaction with it
because they don't have any of the transaction data at this stage.</p>
<p>We avoid rogue-key attacks in the Tari multi-recipient scheme by employing three rounds. In the first round, parties share a
hash of their public nonces, which each party can later use to verify that no nonces were changed after the actual
public nonces were shared.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-8003tariusecases"><a class="header" href="#rfc-8003tariusecases">RFC-8003/TariUseCases</a></h1>
<h2 id="digital-asset-framework"><a class="header" href="#digital-asset-framework">Digital Asset Framework</a></h2>
<p><img src="./theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">CjS77</a></p>
<h1 id="licence-42"><a class="header" href="#licence-42">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-45"><a class="header" href="#language-45">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-45"><a class="header" href="#disclaimer-45">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-44"><a class="header" href="#goals-44">Goals</a></h2>
<p>There will be many types of digital assets that can be issued on Tari. The aim of this Request for Comment (RFC) is to 
help potential asset
issuers identify use cases for Tari that lead to the design of new types of digital assets that may or may not exist in
their ecosystems today.</p>
<h2 id="related-requests-for-comment-37"><a class="header" href="#related-requests-for-comment-37">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0001_overview.html">RFC-0001: Overview of Tari Network</a></li>
<li><a href="RFCD-0300_DAN.html">RFC-0300: Digital Assets Network</a></li>
</ul>
<h2 id="description-26"><a class="header" href="#description-26">Description</a></h2>
<p>Tari <a href="Glossary.html#digital-asset">digital asset</a>s may exist on the Tari <a href="Glossary.html#digital-asset-network">Digital Assets Network</a> (DAN), are perceived to have value and can be 
owned, with the associated digital data being classified as intangible, personal property.</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Digital assets may have the following high-level classification scheme:</p>
<ul>
<li>Symbolic
<ul>
<li>Insignia</li>
<li>Mascots</li>
<li>Event-driven or historical, e.g. a rivalry or a highly temporal event</li>
</ul>
</li>
<li>Artefacts or objects
<ul>
<li>Legendary</li>
<li>Rare</li>
<li>High demand</li>
<li>Artistic</li>
<li>Historical</li>
</ul>
</li>
<li>Utility
<ul>
<li>Tickets</li>
<li>In-game items</li>
<li>Points</li>
<li>Currency</li>
<li>Full or fractional representation</li>
<li>Bearer instruments/access token</li>
<li>Chat stickers</li>
</ul>
</li>
<li>Persona
<ul>
<li>Personality trait(s)</li>
<li>Emotion(s)</li>
<li>Statistics</li>
<li>Superpower(s)</li>
<li>Storyline(s)</li>
<li>Relationship(s)</li>
<li>Avatar</li>
</ul>
</li>
</ul>
<h3 id="behaviours"><a class="header" href="#behaviours">Behaviours</a></h3>
<p>Digital asset tokens may influence the following behavioural types:</p>
<ul>
<li>Advance purchase</li>
<li>Experience enhancement</li>
<li>Sharing</li>
<li>Loyalty</li>
<li>Reward for performance</li>
<li>Tipping</li>
<li>Donating to a charity</li>
<li>Collecting</li>
<li>Trading</li>
<li>Building/combining</li>
</ul>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Digital assets have many different properties, which may be one or more of the following:</p>
<ul>
<li>Digital assets can be interactive:
<ul>
<li>Easter eggs;
<ul>
<li>media</li>
<li>dynamic, e.g. imagine if assets were similar to sounds, visualizations or other kinds of &quot;demos&quot; or &quot;gifs&quot;)</li>
</ul>
</li>
<li>Game mechanics;</li>
<li>Evolutionary.</li>
</ul>
</li>
<li>Digital assets can be combined to create super assets.</li>
<li>Digital assets can be attribute(s) of another digital asset, e.g. wheels of a vehicle or a VIP ticket has two drink 
cards.</li>
<li>Digital assets can have contingencies, e.g. ownership of a digital asset is contingent on ownership of a different 
digital asset. Using this digital asset is contingent on holding it for a particular duration, etc.</li>
<li>Digital assets can have utility, e.g. be useful.</li>
<li>Digital assets can be used across platforms, e.g. a digital asset for a game could be used as avatars in a social 
network.</li>
<li>Digital assets can have history.</li>
<li>Digital assets can have user-generated tags and/or metadata.</li>
</ul>
<h3 id="interactions"><a class="header" href="#interactions">Interactions</a></h3>
<p>Digital asset owners may have the following interactions with the DAN and/or other people:</p>
<ul>
<li>Digital asset owners can attest that they have ownership over their assets at time <code>t</code>.</li>
<li>Digital asset owners may attest ownership to an individual, to a group of friends or to the entire world.</li>
</ul>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>Rules are the governance of how digital assets may be used or transferred, as defined by the asset issuer:</p>
<ul>
<li>Royalty fees.  Digital asset issuers can set a royalty that charges a fee every time the digital asset is transferred 
between parties. The fee as defined by the issuer can be fixed or dynamic, or follow a complex formula, and value is 
granted to the issuer(s) and/or other entities.</li>
<li>Contingency. Digital asset ownership/interaction may be contingent/dependent on another asset.</li>
<li>Timing controls. Digital assets can only be transferred or used at particular times.</li>
<li>Sharing. Digital assets can be shared with others or even co-owned.</li>
<li>Privacy. Ownership of a digital asset can be changed from private to public.</li>
<li>Upgradability/versioning. Digital assets can be upgraded and/or versioned.</li>
<li>Redeemability. Digital assets can be used once or multiple times.</li>
</ul>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<p>Some examples of how different types of digital assets with different attributes, rules and interactions may be 
manifested are provided here:</p>
<h4 id="crystal-skull-of-akador"><a class="header" href="#crystal-skull-of-akador">Crystal Skull of Akador</a></h4>
<ul>
<li>Is rare, it is 1 of 5.</li>
<li>Is legendary:
<ul>
<li>https://indianajones.fandom.com/wiki/Crystal_Skull_of_Akator;</li>
<li>press reports that this artefact could be worth $X.</li>
</ul>
</li>
<li>Drives collectability.</li>
<li>Drives advance purchase, e.g. if you are one of the first 100,000 people to buy tickets to Indiana Jones World, you 
have a chance of winning this 
1 of 5 artefact.</li>
<li>Has superpowers and utility, e.g. if you have this item while visiting Indiana Jones World, you get to skip the line 
three times.</li>
<li>Is a contingency for another asset, e.g. if you collect this item, two Sankara stones and the Cross of Coronado, you 
can buy the ark of the covenant:
<ul>
<li>Ark of the covenant is rare. It is 1 of 1.</li>
<li>Ark of the covenant is legendary.</li>
<li>Ark of the covenant gives you lifetime access to Indiana Jones World.</li>
<li>Ark of the covenant has rules; 20% of the resale price goes to Indiana Jones World.</li>
</ul>
</li>
</ul>
<h4 id="ab-de-villiers-bat"><a class="header" href="#ab-de-villiers-bat">AB de Villiers' bat</a></h4>
<ul>
<li>Is not rare, it is 1 of 100,000.</li>
<li>Is legendary - https://www.youtube.com/watch?v=HK6B2da3DPA.</li>
<li>Drives collectability, it is part of a series of bats from famous batsmen.</li>
<li>Can be combined with other assets, e.g. be one of the first 10 people to combine six bats to turn this asset into a 
One Day International (ODI) century bat:
<ul>
<li>ODI century bats are rare, they are 1 of 10;</li>
<li>ODI century bats are legendary.</li>
</ul>
</li>
<li>Has no superpowers.</li>
<li>Has no utility.</li>
<li>Has no rules.</li>
</ul>
<h4 id="ovo-owl-x-supreme"><a class="header" href="#ovo-owl-x-supreme">OVO Owl x Supreme</a></h4>
<ul>
<li>Is rare, it is 1 of 200.</li>
<li>Is legendary:
<ul>
<li>https://www.supremenewyork.com;</li>
<li>https://us.octobersveryown.com.</li>
</ul>
</li>
<li>Has a game mechanic:
<ul>
<li>Every time it’s transferred, it may become a golden ticket that grants you access to any Drake show.</li>
<li>If it becomes a golden ticket and is transferred, it loses its golden ticket superpower.</li>
</ul>
</li>
<li>Has utility:
<ul>
<li>Unlocks exclusive media content feat. Drake hosted by OVO SOUND.</li>
<li>May become a golden ticket that grants you access to any Drake show.</li>
</ul>
</li>
<li>Has rules - every time its transferred Supreme and OVO SOUND receive 25% of the transaction value.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0385stablecoin"><a class="header" href="#rfc-0385stablecoin">RFC-0385/StableCoin</a></h1>
<h2 id="privacy-enabled-stablecoin-contract-design"><a class="header" href="#privacy-enabled-stablecoin-contract-design">Privacy-enabled Stablecoin contract design</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a>, <a href="https://github.com/AaronFeickert">Aaron Feickert</a></p>
<h1 id="licence-43"><a class="header" href="#licence-43">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:<a href="RFC-0303_DanOverview.html">RFC-0303_DanOverview.md</a></p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-46"><a class="header" href="#language-46">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as
shown here.</p>
<h2 id="disclaimer-46"><a class="header" href="#disclaimer-46">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-45"><a class="header" href="#goals-45">Goals</a></h2>
<p>This Request for Comment (RFC) describes the a possible manifestation of a privacy-preserving
stablecoin on the Tari Digital Assets Network (DAN).</p>
<h2 id="related-requests-for-comment-38"><a class="header" href="#related-requests-for-comment-38">Related Requests for Comment</a></h2>
<h2 id="evaluation-of-existing-stablecoins"><a class="header" href="#evaluation-of-existing-stablecoins">Evaluation of existing stablecoins</a></h2>
<p>The top two stablecoins by issuance, or &quot;total value locked&quot; (TVL) are Tether USD (USDT, under various contracts) and
USD Coin (USDC).
As of August 2023, these two coins accounted
for <a href="https://defillama.com/stablecoins">87% of the total stablecoin market</a>.</p>
<p>Both coins are fully collateralised and the peg is maintained by the centralised issuer.</p>
<p>Although Tether is under scrutiny by authorities, both stablecoins have been in operation for several years. One
might reasonably assume that the intersection of the feature set of the two coins' contracts represent a minimal set of
requirements for legal operation.</p>
<p>What follows is a brief summary of the features of the two coins.</p>
<h3 id="tether-usd-usdt"><a class="header" href="#tether-usd-usdt">Tether USD (USDT)</a></h3>
<p>The Tether USD ERC-20 contract is deployed at address
<a href="https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7"><code>0xdac17f958d2ee523a2206206994597c13d831ec7</code></a>.
The contract code for this contract is presented in <a href="RFC-0385_StableCoins.html#appendix-a---tether-usd-contract">Appendix A</a>. As of August
2023, USDT 39B was help in this contract.</p>
<p>The contract has the following key features:</p>
<h4 id="administration"><a class="header" href="#administration">Administration</a></h4>
<p>The following monetary functions can only be called by the contract owner:</p>
<ul>
<li><code>issue(amount)</code> - issues new tokens to the contract owner's account.</li>
<li><code>redeem(amount)</code> - redeems tokens from the contract owner's account.</li>
<li><code>setParams(...)</code> - Allows owner to set or change fees for transfers. Currently set to zero.</li>
</ul>
<p>The owner has access to the following fraud/AML functions:</p>
<ul>
<li><code>addBlackList(address)</code> - Adds an address to the blacklist. Blacklisted addresses are not allowed to send tokens
(but they can receive them).</li>
<li><code>removeBlackList(address)</code> - Removes an address from the blacklist.</li>
<li><code>destroyBlackFunds(address)</code> - Destroys all tokens in the blacklisted address, reducing the total supply.</li>
</ul>
<p>Finally, the owner has access to the following contract management functions:</p>
<ul>
<li><code>deprecate(address)</code> - Deprecates the contract and supplies the upgraded contract address.</li>
<li><code>pause</code> - pauses the entire contract, preventing any transfers.</li>
<li><code>unpause</code> - unpauses the contract.</li>
<li><code>transferOwnership(address)</code> - transfers ownership of the contract to a new address.</li>
</ul>
<h4 id="account-owners"><a class="header" href="#account-owners">Account owners</a></h4>
<p>The Tether contract records balances through a simple map of standard wallet addresses to amount.
Any ethereum address is eligible to hold a USDT balance by virtue of the ERC-20 contract.</p>
<p>Account owners (ie the address matching the transaction <code>sender</code>) have the following abilities:</p>
<ul>
<li><code>transfer(to, amount)</code> - transfers tokens to another address. Fees get sent to the owner's account.</li>
<li><code>transferFrom(from, to, value)</code> - allows a 3rd party to transfer tokens from the <code>from</code> account to the <code>to</code> account.
The 3rd party must have been authorised by the <code>from</code> account to do so using <code>approve</code> and amount must be less
than or equal to <code>allowance(from, sender)</code>.</li>
<li><code>approve(spender, amount)</code> - authorises a 3rd party to transfer tokens from the owner's account to another account.
The 3rd party must call <code>transferFrom</code> to perform the transfer.</li>
</ul>
<h4 id="public-read-only-functions"><a class="header" href="#public-read-only-functions">Public read-only functions</a></h4>
<p>The following functions are available to the public:</p>
<ul>
<li><code>totalSupply</code> - returns the total supply of minted tokens. The unit is in millionths of a USD.</li>
<li><code>balanceOf(address)</code> - returns the balance of the given address.</li>
<li><code>allowance(owner, spender)</code> - returns the amount of tokens that the spender is allowed to spend on behalf of the
owner.</li>
<li><code>getBlackListStatus(address)</code> - returns whether the given address is blacklisted.</li>
<li><code>getOwner</code> - returns the owner of the contract.</li>
</ul>
<h3 id="circle-usd-usdc"><a class="header" href="#circle-usd-usdc">Circle USD (USDC)</a></h3>
<p>The primary Circle USD contract address is
<a href="https://etherscan.io/address/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"><code>0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48</code></a>.</p>
<p>This is a proxy contract that relays calls to a secondary contract. This is ostensibly done to allow transparent
upgrades to the contract, but it does imply additional risk, since the contract code that actually runs and secures
your funds is not actually immutable anymore.</p>
<p>The current proxied contract is presented in <a href="RFC-0385_StableCoins.html#appendix-b---circle-usd-contract">Appendix B</a>. As of August 2023,<br />
USDC 24B was held in this contract.</p>
<p>It is an ERC-20 contract like Tether, but adds the ability to carry out signature-based operations. Fees are not
supported in this contract.</p>
<p>The contract has the following key features:</p>
<h4 id="administration-1"><a class="header" href="#administration-1">Administration</a></h4>
<p>The owner has access to the following contract management functions:</p>
<ul>
<li><code>updatePauser(address)</code> - gives the <code>Pause</code> role to a new address.</li>
<li><code>updateBlacklister(address)</code> - gives the <code>Blacklist</code> role to a new address.</li>
<li><code>transferOwnership(address)</code> - transfers ownership of the contract to a new address.</li>
<li><code>updateMasterMinter(address)</code> - gives the <code>MasterMinter</code> role to a new address.</li>
<li><code>updateRescuer(address)</code> - gives the <code>Rescuer</code> role to a new address.</li>
</ul>
<p>The address with the <code>Pauser</code> role has access to the following functions:</p>
<ul>
<li><code>pause</code> - pauses the entire contract, preventing any transfers. Caller must have the <code>Pauser</code> role.</li>
<li><code>unpause</code> - unpauses the contract. Caller must have the <code>Pauser</code> role.</li>
</ul>
<p>The address with the <code>Blacklist</code> role has access to the following functions:</p>
<ul>
<li><code>blacklist(address)</code> - Adds an address to the blacklist. Blacklisted addresses are not allowed to send tokens
(but they can receive them).</li>
<li><code>unBlacklist(address)</code> - Removes an address from the blacklist. Caller must have the <code>Blacklist</code> role.</li>
</ul>
<p>The address with the <code>MasterMinter</code> role has access to the following functions:</p>
<ul>
<li><code>configureMinter(address, amount)</code> - Allows the <code>MasterMinter</code> to add a new minter. The minter is allowed to mint
up to the given amount of tokens. New minters have the <code>Mint</code> role.</li>
<li><code>removeMinter(address)</code> - Removes a minter. The address will no longer be able to mint tokens.</li>
</ul>
<p>Addresses with the <code>Mint</code> role have access to the following functions:</p>
<ul>
<li><code>mint(address, amount)</code> - Mints tokens to the given address. The amount must be less than or equal to the amount
that the minter is allowed to mint. Unlike in Tether, USDC mints can be injected directly into arbitrary accounts.</li>
<li><code>burn(amount)</code> - Burns tokens from the minter's address. Minter must not be blacklisted.</li>
</ul>
<p>The address with the <code>Rescuer</code> role has access to the following function:</p>
<ul>
<li><code>rescueERC20(contract, address, amount)</code> - Unconditionally transfers <code>amount</code> funds from the contract to <code>address</code>.
This is ostensibly a backdoor that allows the owner to recover funds in the event of a bug.</li>
</ul>
<h4 id="account-owners-1"><a class="header" href="#account-owners-1">Account owners</a></h4>
<p>The Tether contract records balances through a simple map of standard wallet addresses to amount.
Any ethereum address is eligible to hold a USDT balance by virtue of the ERC-20 contract.</p>
<p>Account owners (ie the address matching the transaction <code>sender</code>) have the following abilities:</p>
<ul>
<li><code>transfer(to, amount)</code> - transfers tokens to another address. Fees get sent to the owner's account. Neither party
may be blacklisted.</li>
<li><code>transferFrom(from, to, value)</code> - allows a 3rd party to transfer tokens from the <code>from</code> account to the <code>to</code> account.
The 3rd party must have been authorised by the <code>from</code> account to do so using <code>approve</code> and amount must be less
than or equal to <code>allowance(from, sender)</code>. Neither <code>from</code>, <code>to</code> or the <code>sender</code> may be blacklisted.</li>
<li><code>approve(spender, amount)</code> - authorises a 3rd party to transfer tokens from the owner's account to another account.
The 3rd party must call <code>transferFrom</code> to perform the transfer. Neither the 3rd party or the authorising account
may be blacklisted.</li>
<li><code>in(de)creaseAllowance(spender, amount)</code> - increases (decreases) the amount that the spender is allowed to spend on
behalf of the owner. Neither the 3rd party or the authorising account may be blacklisted.</li>
<li><code>transferWithAuthorization(to, value, authParams..)</code> - transfers tokens to another
address based on the signature provided. This allows clients to batch transfers and save on gas, or services to pay
gas on behalf of clients.</li>
<li><code>cancelAuthorization(authParams..)</code> - cancels a pending transferWithAuthorization.</li>
<li><code>permit(owner, spender, value, ...)</code> - Similar to <code>approve</code> but authorisation is provided by a bearer signature.</li>
</ul>
<h4 id="public-read-only-functions-1"><a class="header" href="#public-read-only-functions-1">Public read-only functions</a></h4>
<p>The following functions are available to the public:</p>
<ul>
<li><code>totalSupply</code> - returns the total supply of minted tokens. The unit is in millionths of a USD.</li>
<li><code>balanceOf(address)</code> - returns the balance of the given address.</li>
<li><code>allowance(owner, spender)</code> - returns the amount of tokens that the spender is allowed to spend on behalf of the
owner.</li>
<li><code>isBlacklisted(address)</code> - returns whether the given address is blacklisted.</li>
<li><code>getOwner</code> - returns the owner of the contract.</li>
<li><code>minterAllowance(address)</code> - returns the amount of tokens that the given address is allowed to mint.</li>
<li><code>isMinter(address)</code> - returns whether the given address is a minter.</li>
</ul>
<h2 id="feature-comparison-of-tether-and-circle-usd"><a class="header" href="#feature-comparison-of-tether-and-circle-usd">Feature Comparison of Tether and Circle USD</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Tether</th><th>Circle USD</th><th>Minimal requirements</th></tr></thead><tbody>
<tr><td>Contract type</td><td>ERC-20</td><td>ERC-20</td><td></td></tr>
<tr><td>Minting</td><td>Yes (owner only)</td><td>Yes (multiple minters)</td><td>Yes</td></tr>
<tr><td>Burning</td><td>Yes (owner only)</td><td>Yes (multiple minters)</td><td>Yes</td></tr>
<tr><td>Minting to arbitrary account</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Blacklisting</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Blacklisted account can send</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>Blacklisted account can receive</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td>Blacklisted account can be destroyed</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td>Take funds from arbitrary account</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td>Fees</td><td>Yes (currently zero)</td><td>No</td><td>No</td></tr>
<tr><td>Contract upgrade</td><td>Yes (via linked list)</td><td>Yes (via proxy)</td><td>N/A</td></tr>
<tr><td>Contract pause</td><td>Yes</td><td>Yes</td><td>N/A</td></tr>
</tbody></table>
</div>
<h2 id="description-27"><a class="header" href="#description-27">Description</a></h2>
<h3 id="key-assumptions-and-requirements"><a class="header" href="#key-assumptions-and-requirements">Key assumptions and requirements</a></h3>
<ol>
<li>The stablecoin is account-based.</li>
<li>Issuance and redemptions of the stablecoin tokens are performed by a centralised entity, the <code>issuer</code>. The stability
of the token and its peg are completely dependent on the issuer's ability to maintain the peg. The issuer is
required to act responsibly and issue and redeem tokens in a timely manner in order to engender confidence in the
coin and maintain the peg.</li>
<li>Aside from the administrator privileges conferred on the <code>issuer</code> by the stablecoin contract, the coin is operated
in a decentralised manner, and transfers are facilitated by the Tari network, and are not processed by any
centralised
entity, including the <code>issuer</code>.</li>
<li>The <code>issuer</code> has the following &quot;administrator&quot; powers:
<ol>
<li>Create and authorise new accounts.</li>
<li>Issue new tokens. The new tokens are credited to the <code>issuer</code>'s account. The transactions are in the clear so
that anyone can verify the total circulating supply of the stablecoin.</li>
<li>Redeem (burn) existing tokens. The burnt tokens are debited from the <code>issuer</code>'s account. These transactions
are in the clear.</li>
<li>Have access to the full list of account ids.</li>
<li>Blacklist an account. Blacklisted accounts are not allowed to send, or receive, tokens.</li>
<li>Remove an account from the blacklist.</li>
</ol>
</li>
<li>Account-holders have the following abilities:
<ol>
<li>View their own balance.</li>
<li>If their account is not blacklisted, transfer funds to any other (non-blacklisted) account.</li>
</ol>
</li>
<li>General users:
<ol>
<li>Cannot see the balance of any account (other than their own).</li>
<li>Can see the total supply of tokens in circulation.</li>
<li>Can apply for a new account by interacting with the <code>issuer</code>.</li>
</ol>
</li>
<li>The possibility of the issuer charging a fee for transfers is not considered in this design.</li>
<li>The issuer can view the balance of account holders.</li>
<li>The issuer cannot unilaterally spend or seize funds from any account holder.</li>
</ol>
<p>Validator nodes validate all stablecoin transactions. In particular:</p>
<ol>
<li>Validator nodes cannot determine the value of any transaction.</li>
<li>However, they <em>are</em> able to, and MUST verify that
<ol>
<li>no coins are created or destroyed in the transaction, i.e. the sum of the parties' balances before and after
the transfer are equal,</li>
<li>the transfer value is positive,</li>
<li>the sender has a positive balance after the transaction,</li>
<li>the sender has authorised the transaction,</li>
<li>the sending party holds a valid account,</li>
<li>the sending party is not on the blacklist,</li>
<li>the receiving party holds a valid account,</li>
<li>the receiving party is not on the blacklist.</li>
</ol>
</li>
<li>If any of the conditions in 2 are not met, the transaction is invalid and the validator node MUST reject the
transaction.</li>
</ol>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>The broad strategy is as follows:</p>
<ul>
<li>The issuer mints stablecoin tokens in equal quantity to the amount of fiat currency deposited with the issuer.
These mint transactions are in the clear and anyone can ascertain the total circulating supply of the stablecoin.</li>
<li>Issuers can transfer tokens to any account. These transfers are also in the clear.</li>
<li>Transfers between account holders are confidential.</li>
<li>The issuer can carry out confidential transfers by first transferring tokens from the
cleartext issuer account to another, standard account controlled by the issuer, and then performing a confidential
transfer from there to the final destination account.</li>
<li>Balances are stored in Pedersen commitments, the masks of which are known only to account holders.</li>
<li>Balances are also verifiably encrypted to the issuer.</li>
<li>Users create a new account by interacting with the issuer. The issuer provides an account id that can be compared
against a blacklist for the purposes of determining whether the account is valid or not. The issuer may choose to
conduct a KYC procedure out-of-band as part of the account creation process.</li>
<li>The full list of accounts form part of a whitelist. Only the issuer can modify the whitelist.</li>
<li>A blacklist, which only the issuer can modify, comprises a list of accounts that may no longer participate in
stablecoin transactions.</li>
<li>Spending authority rests solely with the account owner and required knowledge of the account private key.</li>
<li>Transfers are done in two-steps, via the issuance of an e-cheque by the sender, followed by the claiming of the
e-cheque by the recipient.</li>
</ul>
<p>The remainder of this section describes the implementation in more detail.</p>
<div class="note">
This design is experimental and not yet suitable for production.
</div>
<h2 id="mathematical-furniture"><a class="header" href="#mathematical-furniture">Mathematical furniture</a></h2>
<p>As a point of notation, we sometimes use superscripts in mathematical notation in this note; unless otherwise indicated,
this is symbolic and not to be interpreted as indicating exponentiation.</p>
<h3 id="hash-functions-and-ciphers"><a class="header" href="#hash-functions-and-ciphers">Hash functions and ciphers</a></h3>
<p>We require the use of multiple cryptographic hash functions, which must be sampled independently.
It is possible to do this by carefully applying domain separation to a single cryptographic hash function.
We further require that when data is provided as input to such a hash function, it is done safely in a manner that is
canonical and cannot induce collisions.
We use a comma notation to indicate multiple input values, as in $H(a, b, c, \ldots)$.</p>
<p>We also require the use of a key-committing AEAD (authenticated encryption with additional data) construction.
It is possible to extend an arbitrary AEAD design in this manner by including a safe cryptographic hash of a derived
key.</p>
<p>Let $H_{\text{AEAD}}$ be a cryptographic hash function whose output is the AEAD key space, suitable for $H_
{\text{AEAD}}$ to operate as a key derivation function for the AEAD.</p>
<h3 id="proving-systems"><a class="header" href="#proving-systems">Proving systems</a></h3>
<p>The design will require several zero-knowledge proving systems that allow validators to assert correctness of operations
without revealing protected data.</p>
<h3 id="verifiable-encryption"><a class="header" href="#verifiable-encryption">Verifiable encryption</a></h3>
<p>We require the use of a verifiable ElGamal encryption proving system that asserts the value bound to a Pedersen
commitment matches the value encrypted to a given public key.
This will be used to assert that the issuer can decrypt account balances without knowing the opening to the account's
balance commitment.</p>
<p>The proving relation is </p>
<p>$\{ (C, E, R, P); (v, m, r) | C = vG + mH, E = vG + rP, R = rG \}$.</p>
<ul>
<li>The prover samples $x_v, x_m, x_r$ uniformly at random.</li>
<li>It computes $C' = x_v G + x_m H$, $E' = x_v G + x_r P$, and $R' = x_r G$ and sends them to the verifier.</li>
<li>The verifier samples nonzero $e$ uniformly at random and sends it to the prover.</li>
<li>The prover computes $s_v = ev + x_v$, $s_m = em + x_m$, and $s_r = er + x_r$ and sends them to the verifier.</li>
<li>The verifier accepts the proof if and only if $eC + C' = s_v G + s_m H$, $eE + E' = s_v G + s_r P$, and $eR + R' = s_r
G$.</li>
</ul>
<p>The proof can be made non-interactive using the Fiat-Shamir technique.
It is a sigma protocol for the relation that is complete, 2-special sound, and special honest-verifier zero knowledge.</p>
<h3 id="value-equality"><a class="header" href="#value-equality">Value equality</a></h3>
<p>We require the use of a value equality proving system that asserts two Pedersen commitments bind to the same value.
This will be used to assert that commitments used in transfers retain balance.</p>
<p>The proving relation is </p>
<p>$\{ (C_1, C_2); (v, m_1, m_2) | C_1 = vG + m_1 H, C_2 = vG + m_2 H \}$.</p>
<ul>
<li>The prover samples $x_v, x_{m_1}, x_{m_2}$ uniformly at random.</li>
<li>It computes $C_1' = x_v G + x_{m_1} H$ and $C_2' = x_v G + x_{m_2} H$ and sends them to the verifier.</li>
<li>The verifier samples nonzero $e$ uniformly at random and sends it to the prover.</li>
<li>The prover computes $s_v = ev + x_v$, $s_{m_1} = em_1 + x_{m_1}$, and $s_{m_2} = em_2 + x_{m_2}$ and sends them to the
verifier.</li>
<li>The verifier accepts the proof if and only if $eC_1 + C_1' = s_v G + s_{m_1} H$ and $eC_2 + C_2' = s_v G + s_{m_2} H$.</li>
</ul>
<p>The proof can be made non-interactive using the Fiat-Shamir technique.
It is a sigma protocol for the relation that is complete, 2-special sound, and special honest-verifier zero knowledge.</p>
<h3 id="schnorr-representation"><a class="header" href="#schnorr-representation">Schnorr representation</a></h3>
<p>We require the use of a Schnorr representation proving system that asserts knowledge of a discrete logarithm.
This will be used to sign messages, as well as to assert that a Pedersen commitment binds to a given value.</p>
<p>The proving relation is </p>
<p>$\{ P; p | P = pG \}$.</p>
<ul>
<li>The prover samples $x_p$ uniformly at random.</li>
<li>It computes $P' = x_p G$ and sends it to the verifier.</li>
<li>The verifier samples nonzero $e$ uniformly at random and sends it to the prover.</li>
<li>The prover computes $s_p = ep + x_p$ and sends it to the verifier.</li>
<li>The verifier accepts the proof if and only if $eP + P' = s_p G$.</li>
</ul>
<p>The proof can be made non-interactive using the Fiat-Shamir technique.
It is a sigma protocol for the relation that is complete, 2-special sound, and special honest-verifier zero knowledge.</p>
<p>To use this proving system to assert that a commitment $C$ binds to a given value $v$, we set $P = C - vG$ and use the
Schnorr representation proving system on this statement using the generator $H$ instead of $G$, and being careful to
bind $v$ into the Fiat-Shamir transcript.</p>
<h3 id="commitment-range"><a class="header" href="#commitment-range">Commitment range</a></h3>
<p>We require the use of a commitment range proving system that asserts that all Pedersen commitments in a set bind to
values in a specified range.
This will be used to prevent balance underflow and overflow that would inflate supply.
We assume the intended range is $[0, 2^n)$ for some globally-fixed $n$; in practice, $n = 64$ is typically used (since
it is often the case that $n$ must itself be a power of two).</p>
<p>The proving relation is </p>
<p>$\{ (C_j)_{j=0}^{m-1}; (v_j, m_j)_{j=0}^{m-1} : C_j = v_j G + m_j H, v_j \in [0, 2^n) \forall j \}$.</p>
<p>The popular and efficient Bulletproofs and <a href="https://github.com/tari-project/bulletproofs-plus">Bulletproofs+</a> range 
proving systems may be used for this purpose.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>We now describe the stablecoin design.</p>
<h3 id="issuer"><a class="header" href="#issuer">Issuer</a></h3>
<p>The stablecoin is instantiated by defining the issuer.</p>
<p>The issuer samples its secret key $p$ uniformly at random, and computes the corresponding public key $P = pG$.
It produces a Schnorr representation proof $\Pi_P$ using statement $P$ and witness $p$.
It sets up the stablecoin as follows:</p>
<ul>
<li>Public key: $P$</li>
<li>Public key proof: $\Pi_P$</li>
</ul>
<p>Validators check this operation by verifying $\Pi_P$.</p>
<p>The issuer also sets up an account for itself using the structure described below for users.</p>
<h3 id="users"><a class="header" href="#users">Users</a></h3>
<p>A user who wishes to open an account interacts with the issuer via a side channel.
The user samples its secret key $k$ uniformly at random, and computes the corresponding public key $K = kG$.
It produces a Schnorr representation proof $\Pi_K$ using statement $K$ and witness $k$.
The issuer checks that $K$ has not been used in any other approved account, and verifies $\Pi_K$.</p>
<p>If the issuer approves the account, it signs $K$ by generating a Schnorr representation proof $\Pi_{P, K}$ using
statement $P$ and witness $p$, binding $K$ into the Fiat-Shamir transcript.</p>
<p>The issuer sets up the account structure as follows:</p>
<ul>
<li>Public key: $K$</li>
<li>Public key proof: $\Pi_K$</li>
<li>Issuer proof: $\Pi_{P, K}$</li>
<li>State nonce: 0</li>
<li>Balance commitment: 0 (identity group element)</li>
<li>Issuer-encrypted balance: None</li>
<li>User-encrypted balance: None</li>
<li>Pending e-cheques: None</li>
</ul>
<ul>
<li>The <em>state nonce</em> is a value used to track changes to the account and avoid replaying messages.</li>
<li>The <em>issuer-encrypted balance</em> field will be populated with a verifiable encryption of the balance that can be 
decrypted by the issuer.</li>
<li>The <em>user-encrypted balance</em> field will be populated with an authenticated encryption of the value and mask
corresponding to the balance commitment that can be decrypted by the user for account recovery purposes.</li>
<li>The <em>pending e-cheques</em> field will be populated with <em>e-cheques</em> representing transfers that are destined for the 
account, but that the user has neither approved nor rejected.</li>
</ul>
<p>Validators check this operation by verifying $\Pi_K$ and $\Pi_{P, K}$, asserting that $K$ does not appear in any other
account, and asserting the other constant values are as expected.</p>
<h3 id="cheques"><a class="header" href="#cheques">Cheques</a></h3>
<p>When a user wishes to transfer funds to another user, it does so by generating an <em>e-cheque</em>.
Once validators check the e-cheque, it is added to the recipient's pending e-cheques list and the 
sender's account is updated.</p>
<p>The e-cheque remains until the recipient approves or rejects it, or until the e-cheque becomes abandoned, as 
described later.</p>
<p>Suppose the sender wishes to transfer value $v^\Delta$ to a recipient.</p>
<ul>
<li>Let $K_s = k_s G$ and $K_r$ be the sender and recipient keys, respectively.</li>
<li>Let $C = vG + mH$ be the sender balance commitment.</li>
<li>Let $i$ be the sender state nonce.</li>
</ul>
<p>The sender does the following:</p>
<ul>
<li>Samples a scalar $m_s^\Delta$ uniformly at random and uses it to generate a commitment $C_s^\Delta = v^\Delta G +
m_s^\Delta H$ to the transfer value.</li>
<li>Samples a scalar $m^\Delta$ uniformly at random and uses it to generate a commitment $C^\Delta = v^\Delta G + m^\Delta
H$ to the transfer value.</li>
<li>Generates a proof of value equality $\Pi_\Delta$ on the statement $(C_s^\Delta, C^\Delta)$ and witness $(v^\Delta,
m_s^\Delta, m^\Delta)$.</li>
<li>Samples a scalar $r$ uniformly at random, and computes $R = rG$.</li>
<li>Generates an AEAD key $H_{\text{AEAD}}(r K_r)$ and uses it to encrypt the tuple $(v^\Delta, m^\Delta)$, producing
authenticated ciphertext $c$.</li>
<li>Sets $E = (v - v^\Delta) G + rP$ as an ElGamal encryption of its new balance, and generates a verifiable encryption
proof $\Pi_{\text{enc}}$ on the statement $(C - C_s^\Delta, E, R, P)$ and witness $(v - v^\Delta, m - m_s^\Delta, r)$.</li>
<li>Generates a range proof $\Pi_{\text{range}}$ on the statement $\{ C_s^\Delta, C - C_s^\Delta \}$ and witness $\{ (
v^\Delta, m_s^\Delta), (v - v^\Delta, m - m_s^\Delta) \}$.</li>
<li>Generates an AEAD key $H_{\text{AEAD}}(k_s)$ and uses it to encrypt the tuple $(v - v^\Delta, m - m_s^\Delta)$,
producing authenticated ciphertext $c_s$.</li>
<li>Sets the e-cheque to be the tuple $t = (K_s, K_r, C, i, C_s^\Delta, C^\Delta, E, R, \Pi_\Delta, \Pi_{\text{enc}}, \Pi_
{\text{range}}, c_s, c_{sr})$.</li>
<li>Signs the e-cheque by generating a Schnorr representation proof $\Pi_t$ using statement $K_s$ and witness $k_s$, binding
$t$ into the Fiat-Shamir transcript.</li>
</ul>
<p>Prior to accepting the e-cheque as valid, validators perform the following checks:</p>
<ul>
<li>Assert that neither $K_s$ nor $K_r$ appear on the blacklist.</li>
<li>Verify the proof $\Pi_t$.</li>
<li>Look up the sender's account using $K_s$ and assert that $C$ and $i$ match the corresponding values in the account.</li>
<li>Verify the proofs $\Pi_\Delta$, $\Pi_{\text{enc}}$, and $\Pi_{\text{range}}$.</li>
</ul>
<p>If these checks pass, validators add the e-cheque to the recipient's pending e-cheques list, and update the sender's account
as follows:</p>
<ul>
<li>Increment the state nonce.</li>
<li>Set the balance commitment to $C - C_s^\Delta$.</li>
<li>Set the issuer-encrypted balance to the tuple $(E, R)$.</li>
<li>Set the user-encrypted balance to $c_s$.</li>
</ul>
<p>When the recipient sees the e-cheque, it can either <em>endorse</em> or <em>void</em> it.</p>
<p>Endorsement means the recipient intends to accept the funds and wishes to have its account updated accordingly.
Voiding means the recipient does not intend to accept the funds and wishes for the sender to be able to claim them back.
Prior to making this determination, the recipient does the following:</p>
<ul>
<li>Generates an AEAD key $H_{\text{AEAD}}(k_r R)$ and uses it to authenticate and decrypt $c$, producing the tuple $(
v^\Delta, m^\Delta)$.</li>
<li>Checks that $C^\Delta = v^\Delta G + m^\Delta H$.</li>
</ul>
<p>If these checks pass, it may choose to endorse or void the e-cheque.
If they fail, it must void the e-cheque.</p>
<h3 id="voiding-an-e-cheque"><a class="header" href="#voiding-an-e-cheque">Voiding an e-cheque</a></h3>
<p>Suppose the recipient wishes to void an e-cheque $t$.</p>
<p>It does the following:</p>
<ul>
<li>Sets the voiding to be the tuple $t_{\text{void}} = (t)$.</li>
<li>Signs the voiding by generating a Schnorr representation proof $\Pi_t$ using statement $K_r$ and witness $k_r$,
binding $t_{\text{void}}$ into the Fiat-Shamir transcript.</li>
</ul>
<p>Prior to accepting the voiding as valid, validators perform the following checks:</p>
<ul>
<li>Assert that neither $K_s$ nor $K_r$ appear on the blacklist.</li>
<li>Verify the proof $\Pi_t$.</li>
</ul>
<p>If these checks pass, validators annotate $t$ in the recipient's pending e-cheques list to indicate the voiding.</p>
<h3 id="endorsing-an-e-cheque"><a class="header" href="#endorsing-an-e-cheque">Endorsing an e-cheque</a></h3>
<p>Suppose the recipient wishes to endorse an e-cheque $t$ with $C^\Delta = v^\Delta G + m^\Delta H$ from its pending e-cheques
list.</p>
<p>Now let $C = vG + mH$ be the recipient balance commitment.</p>
<p>Let $i$ be the recipient state nonce.</p>
<p>The recipient does the following:</p>
<ul>
<li>Samples a scalar $m_r^\Delta$ uniformly at random, and uses it to generate a commitment $C_r^\Delta = v^\Delta G +
m_r^\Delta H$ to the transfer value.</li>
<li>Generates a proof of value equality $\Pi_\Delta$ on the statement $(C_r^\Delta, C^\Delta)$ and witness $(v^\Delta,
m_r^\Delta, m^\Delta)$.</li>
<li>Samples a scalar $r$ uniformly at random, and computes $R = rG$.</li>
<li>Sets $E = (v + v^\Delta) G + rP$ as an ElGamal encryption of its new balance, and generates a verifiable encryption
proof $\Pi_{\text{enc}}$ on the statement $(C + C_r^\Delta, E, R, P)$ and witness $(v + v^\Delta, m + m_r^\Delta, r)$.</li>
<li>Generates an AEAD key $H_{\text{AEAD}}(k_r)$ and uses it to encrypt the tuple $(v + v^\Delta, m + m_r^\Delta)$,
producing authenticated ciphertext $c_r$.</li>
<li>Sets the endorsement to be the tuple $t_{\text{end}} = (t, C, i, C_r^\Delta, E, R, \Pi_\Delta, \Pi_{\text{enc}},
c_r)$.</li>
<li>Signs the endorsement by generating a Schnorr representation proof $\Pi_t$ using statement $K_r$ and witness $k_r$,
binding $t_{\text{end}}$ into the Fiat-Shamir transcript.</li>
</ul>
<p>It is also possible for the original sender of an e-cheque to endorse it as well.
This can arise in two cases:</p>
<ul>
<li>The recipient of the e-cheque has voided it.</li>
<li>The recipient of the e-cheque has neither accepted nor voided it, and a protocol-specified period of time has passed.</li>
</ul>
<p>The process is the same as above, with the sender now playing the role of the recipient.</p>
<p>Prior to accepting the endorsement as valid, validators perform the following checks:</p>
<ul>
<li>Assert that neither $K_s$ nor $K_r$ appear on the blacklist.</li>
<li>Verify the proof $\Pi_t$.</li>
<li>Look up the recipient's account using $K_r$ and assert that $C$ and $i$ match the corresponding values in the account,
and that $t$ appears in the pending e-cheques list.</li>
<li>Verify the proofs $\Pi_\Delta$ and $\Pi_{\text{enc}}$.</li>
</ul>
<p>If these checks pass, validators remove the e-cheque $t$ from the recipient's pending e-cheques list, and update the
recipient's account as follows:</p>
<ul>
<li>Increment the state nonce.</li>
<li>Set the balance commitment to $C + C_r^\Delta$.</li>
<li>Set the issuer-encrypted balance to the tuple $(E, R)$.</li>
<li>Set the user-encrypted balance to $c_r$.</li>
</ul>
<h3 id="issuer-balance-visibility"><a class="header" href="#issuer-balance-visibility">Issuer balance visibility</a></h3>
<p>The issuer can privately view any user's balance at any time using ElGamal decryption.
Suppose it wishes to view the balance of a user whose issuer-encrypted balance is $(E, R)$.</p>
<p>It does the following:</p>
<ul>
<li>Sets $V = E - pR$.</li>
<li>Finds $v$ such that $V = vG$; this is the user's balance.</li>
</ul>
<p>Because the search space for balances is limited, the issuer can optimize this process.
For example, it could produce a lookup table mapping $vG \mapsto v$ for reasonable values $v$, or simply use brute force
on the search space.</p>
<h3 id="user-account-recovery"><a class="header" href="#user-account-recovery">User account recovery</a></h3>
<p>If the user loses access to their account balance, they can recover the opening to their balance commitment to regain 
access, provided they still hold the private key $k$.</p>
<p>Suppose such a user with key $k$ queries validators for its account's user-encrypted balance.</p>
<p>It does the following:</p>
<ul>
<li>Generates an AEAD key $H_{\text{AEAD}}(k)$ and uses it to authenticate and decrypt the user-encrypted balance,
producing the tuple $(v, m)$; this is the opening to their balance commitment.</li>
</ul>
<h3 id="issuer-transfers"><a class="header" href="#issuer-transfers">Issuer transfers</a></h3>
<p>When transferring funds from the issuer to a user, or from a user to the issuer, it is required that the value be
publicly visible for transparency purposes.
However, we wish to reuse as much of the existing design as possible, in order to simplify the design and reduce
engineering risk.</p>
<p>If the issuer wishes to transfer funds to a user, it produces an e-cheque with the following modifications:</p>
<ul>
<li>It sets $r = 0$.</li>
<li>It uses a zero key to produce $c_s$.</li>
</ul>
<p>When validating such an e-cheque, validators additionally do the following:</p>
<ul>
<li>Assert that $R = 0$.</li>
<li>Assert that $c_s$ decrypts using a zero key, and that the resulting opening is valid.</li>
<li>Decrypt $c_s$ and assert the resulting opening is valid.</li>
<li>Decrypt $c$ using a zero key and assert the resulting opening is valid.</li>
</ul>
<p>If a user wishes to transfer funds to the issuer, it produces an e-cheque with the following modifications:</p>
<ul>
<li>It sets $r = 0$.</li>
</ul>
<p>When validating such an e-cheque, validators additionally do the following:</p>
<ul>
<li>Assert that $R = 0$.</li>
<li>Decrypt $c$ using a zero key and asserting the resulting opening is valid.</li>
</ul>
<p>If the issuer wishes to accept transfer funds from a user, it produces an endorsement with the following modifications:</p>
<ul>
<li>It uses a zero key to produce $c_r$.</li>
</ul>
<p>When validating such an endorsement, validators additionally do the following:</p>
<ul>
<li>Assert that $c_r$ decrypts using a zero key, and that the resulting opening is valid.</li>
</ul>
<p>This design allows for transparent analysis of the issuer's balance and e-cheques.</p>
<h2 id="final-notes"><a class="header" href="#final-notes">Final notes</a></h2>
<p>There are several variations of this contract that could be implemented.</p>
<p>For example, removing the encrypted balance fields would make user balances opaque to the issuer as well, while also 
simplifying the design considerably.</p>
<p>The transfer process can be augmented to include dummy inputs and outputs, using a strategy similar to that 
used in <a href="https://ia.cr/2021/1173">Lelantus Spark</a>. This would obfuscate the parties in a transfer, dramatically
improving privacy.</p>
<p>The use of e-cheques as the primary value transfer vehicle opens up many possibilities for adding additional margin
of error to on-chain financial transactions:</p>
<ul>
<li>For example, e-cheques could have a holding time associated with them, to allow parties to validate payments 
out-of-band. </li>
<li>They could have additional claim constraints, which would simplify escrow contracts and swap contracts while 
improving security.</li>
</ul>
<h1 id="appendix-a---tether-usd-contract"><a class="header" href="#appendix-a---tether-usd-contract">Appendix A - Tether USD contract</a></h1>
<pre><code class="language-js">/**
 *Submitted for verification at Etherscan.io on 2017-11-28
*/

pragma solidity ^0.4.17;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b &lt;= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c &gt;= a);
        return c;
    }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of &quot;user permissions&quot;.
 */
contract Ownable {
    address public owner;

    /**
      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
      * account.
      */
    function Ownable() public {
        owner = msg.sender;
    }

    /**
      * @dev Throws if called by any account other than the owner.
      */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    /**
    * @dev Allows the current owner to transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

}

/**
 * @title ERC20Basic
 * @dev Simpler version of ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}

/**
 * @title ERC20 interface
 * @dev see https://github.com/ethereum/EIPs/issues/20
 */
contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is Ownable, ERC20Basic {
    using SafeMath for uint;

    mapping(address =&gt; uint) public balances;

    // additional variables for use if transaction fees ever became necessary
    uint public basisPointsRate = 0;
    uint public maximumFee = 0;

    /**
    * @dev Fix for the ERC20 short address attack.
    */
    modifier onlyPayloadSize(uint size) {
        require(!(msg.data.length &lt; size + 4));
        _;
    }

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
        uint fee = (_value.mul(basisPointsRate)).div(10000);
        if (fee &gt; maximumFee) {
            fee = maximumFee;
        }
        uint sendAmount = _value.sub(fee);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee &gt; 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(msg.sender, owner, fee);
        }
        Transfer(msg.sender, _to, sendAmount);
    }

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint representing the amount owned by the passed address.
    */
    function balanceOf(address _owner) public constant returns (uint balance) {
        return balances[_owner];
    }

}

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is BasicToken, ERC20 {

    mapping (address =&gt; mapping (address =&gt; uint)) public allowed;

    uint public constant MAX_UINT = 2**256 - 1;

    /**
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint the amount of tokens to be transferred
    */
    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {
        var _allowance = allowed[_from][msg.sender];

        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
        // if (_value &gt; _allowance) throw;

        uint fee = (_value.mul(basisPointsRate)).div(10000);
        if (fee &gt; maximumFee) {
            fee = maximumFee;
        }
        if (_allowance &lt; MAX_UINT) {
            allowed[_from][msg.sender] = _allowance.sub(_value);
        }
        uint sendAmount = _value.sub(fee);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(sendAmount);
        if (fee &gt; 0) {
            balances[owner] = balances[owner].add(fee);
            Transfer(_from, owner, fee);
        }
        Transfer(_from, _to, sendAmount);
    }

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {

        // To change the approve amount you first have to reduce the addresses`
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        require(!((_value != 0) &amp;&amp; (allowed[msg.sender][_spender] != 0)));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
    }

    /**
    * @dev Function to check the amount of tokens than an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint specifying the amount of tokens still available for the spender.
    */
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }

}


/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}

contract BlackList is Ownable, BasicToken {

    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////
    function getBlackListStatus(address _maker) external constant returns (bool) {
        return isBlackListed[_maker];
    }

    function getOwner() external constant returns (address) {
        return owner;
    }

    mapping (address =&gt; bool) public isBlackListed;

    function addBlackList (address _evilUser) public onlyOwner {
        isBlackListed[_evilUser] = true;
        AddedBlackList(_evilUser);
    }

    function removeBlackList (address _clearedUser) public onlyOwner {
        isBlackListed[_clearedUser] = false;
        RemovedBlackList(_clearedUser);
    }

    function destroyBlackFunds (address _blackListedUser) public onlyOwner {
        require(isBlackListed[_blackListedUser]);
        uint dirtyFunds = balanceOf(_blackListedUser);
        balances[_blackListedUser] = 0;
        _totalSupply -= dirtyFunds;
        DestroyedBlackFunds(_blackListedUser, dirtyFunds);
    }

    event DestroyedBlackFunds(address _blackListedUser, uint _balance);

    event AddedBlackList(address _user);

    event RemovedBlackList(address _user);

}

contract UpgradedStandardToken is StandardToken{
    // those methods are called by the legacy contract
    // and they must ensure msg.sender to be the contract address
    function transferByLegacy(address from, address to, uint value) public;
    function transferFromByLegacy(address sender, address from, address spender, uint value) public;
    function approveByLegacy(address from, address spender, uint value) public;
}

contract TetherToken is Pausable, StandardToken, BlackList {

    string public name;
    string public symbol;
    uint public decimals;
    address public upgradedAddress;
    bool public deprecated;

    //  The contract can be initialized with a number of tokens
    //  All the tokens are deposited to the owner address
    //
    // @param _balance Initial supply of the contract
    // @param _name Token Name
    // @param _symbol Token symbol
    // @param _decimals Token decimals
    function TetherToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[owner] = _initialSupply;
        deprecated = false;
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function transfer(address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[msg.sender]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);
        } else {
            return super.transfer(_to, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {
        require(!isBlackListed[_from]);
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);
        } else {
            return super.transferFrom(_from, _to, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function balanceOf(address who) public constant returns (uint) {
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).balanceOf(who);
        } else {
            return super.balanceOf(who);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {
        if (deprecated) {
            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);
        } else {
            return super.approve(_spender, _value);
        }
    }

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        if (deprecated) {
            return StandardToken(upgradedAddress).allowance(_owner, _spender);
        } else {
            return super.allowance(_owner, _spender);
        }
    }

    // deprecate current contract in favour of a new one
    function deprecate(address _upgradedAddress) public onlyOwner {
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        Deprecate(_upgradedAddress);
    }

    // deprecate current contract if favour of a new one
    function totalSupply() public constant returns (uint) {
        if (deprecated) {
            return StandardToken(upgradedAddress).totalSupply();
        } else {
            return _totalSupply;
        }
    }

    // Issue a new amount of tokens
    // these tokens are deposited into the owner address
    //
    // @param _amount Number of tokens to be issued
    function issue(uint amount) public onlyOwner {
        require(_totalSupply + amount &gt; _totalSupply);
        require(balances[owner] + amount &gt; balances[owner]);

        balances[owner] += amount;
        _totalSupply += amount;
        Issue(amount);
    }

    // Redeem tokens.
    // These tokens are withdrawn from the owner address
    // if the balance must be enough to cover the redeem
    // or the call will fail.
    // @param _amount Number of tokens to be issued
    function redeem(uint amount) public onlyOwner {
        require(_totalSupply &gt;= amount);
        require(balances[owner] &gt;= amount);

        _totalSupply -= amount;
        balances[owner] -= amount;
        Redeem(amount);
    }

    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {
        // Ensure transparency by hardcoding limit beyond which fees can never be added
        require(newBasisPoints &lt; 20);
        require(newMaxFee &lt; 50);

        basisPointsRate = newBasisPoints;
        maximumFee = newMaxFee.mul(10**decimals);

        Params(basisPointsRate, maximumFee);
    }

    // Called when new token are issued
    event Issue(uint amount);

    // Called when tokens are redeemed
    event Redeem(uint amount);

    // Called when contract is deprecated
    event Deprecate(address newAddress);

    // Called if contract ever adds fees
    event Params(uint feeBasisPoints, uint maxFee);
}
</code></pre>
<h1 id="appendix-b---circle-usd-contract"><a class="header" href="#appendix-b---circle-usd-contract">Appendix B - Circle USD contract</a></h1>
<p>The Circle USD contract runs as a proxy contract. Therefore the code that is actually active can be changed at any
time. The following is the contract code that was active as of 25 August 2023, deployed to address
<a href="https://etherscan.io/address/0xa2327a938febf5fec13bacfb16ae10ecbc4cbdcf"><code>0xa2327a938febf5fec13bacfb16ae10ecbc4cbdcf</code></a>.</p>
<pre><code class="language-js">/**
 *Submitted for verification at Etherscan.io on 2021-04-17
*/

// File: @openzeppelin/contracts/math/SafeMath.sol

// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, &quot;SafeMath: subtraction overflow&quot;);
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b &lt;= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, &quot;SafeMath: division by zero&quot;);
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b &gt; 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, &quot;SafeMath: modulo by zero&quot;);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

// File: @openzeppelin/contracts/token/ERC20/IERC20.sol

pragma solidity ^0.6.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
    external
    returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
    external
    view
    returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

// File: contracts/v1/AbstractFiatTokenV1.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

abstract contract AbstractFiatTokenV1 is IERC20 {
    function _approve(
        address owner,
        address spender,
        uint256 value
    ) internal virtual;

    function _transfer(
        address from,
        address to,
        uint256 value
    ) internal virtual;
}

// File: contracts/v1/Ownable.sol

/**
 * Copyright (c) 2018 zOS Global Limited.
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
pragma solidity 0.6.12;

/**
 * @notice The Ownable contract has an owner address, and provides basic
 * authorization control functions
 * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-labs/blob/3887ab77b8adafba4a26ace002f3a684c1a3388b/upgradeability_ownership/contracts/ownership/Ownable.sol
 * Modifications:
 * 1. Consolidate OwnableStorage into this contract (7/13/18)
 * 2. Reformat, conform to Solidity 0.6 syntax, and add error messages (5/13/20)
 * 3. Make public functions external (5/27/20)
 */
contract Ownable {
    // Owner of the contract
    address private _owner;

    /**
     * @dev Event to show ownership has been transferred
     * @param previousOwner representing the address of the previous owner
     * @param newOwner representing the address of the new owner
     */
    event OwnershipTransferred(address previousOwner, address newOwner);

    /**
     * @dev The constructor sets the original owner of the contract to the sender account.
     */
    constructor() public {
        setOwner(msg.sender);
    }

    /**
     * @dev Tells the address of the owner
     * @return the address of the owner
     */
    function owner() external view returns (address) {
        return _owner;
    }

    /**
     * @dev Sets a new owner address
     */
    function setOwner(address newOwner) internal {
        _owner = newOwner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == _owner, &quot;Ownable: caller is not the owner&quot;);
        _;
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(
            newOwner != address(0),
            &quot;Ownable: new owner is the zero address&quot;
        );
        emit OwnershipTransferred(_owner, newOwner);
        setOwner(newOwner);
    }
}

// File: contracts/v1/Pausable.sol

/**
 * Copyright (c) 2016 Smart Contract Solutions, Inc.
 * Copyright (c) 2018-2020 CENTRE SECZ0
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @notice Base contract which allows children to implement an emergency stop
 * mechanism
 * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/feb665136c0dae9912e08397c1a21c4af3651ef3/contracts/lifecycle/Pausable.sol
 * Modifications:
 * 1. Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018)
 * 2. Removed whenNotPause/whenPaused from pause/unpause (6/14/2018)
 * 3. Removed whenPaused (6/14/2018)
 * 4. Switches ownable library to use ZeppelinOS (7/12/18)
 * 5. Remove constructor (7/13/18)
 * 6. Reformat, conform to Solidity 0.6 syntax and add error messages (5/13/20)
 * 7. Make public functions external (5/27/20)
 */
contract Pausable is Ownable {
    event Pause();
    event Unpause();
    event PauserChanged(address indexed newAddress);

    address public pauser;
    bool public paused = false;

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     */
    modifier whenNotPaused() {
        require(!paused, &quot;Pausable: paused&quot;);
        _;
    }

    /**
     * @dev throws if called by any account other than the pauser
     */
    modifier onlyPauser() {
        require(msg.sender == pauser, &quot;Pausable: caller is not the pauser&quot;);
        _;
    }

    /**
     * @dev called by the owner to pause, triggers stopped state
     */
    function pause() external onlyPauser {
        paused = true;
        emit Pause();
    }

    /**
     * @dev called by the owner to unpause, returns to normal state
     */
    function unpause() external onlyPauser {
        paused = false;
        emit Unpause();
    }

    /**
     * @dev update the pauser role
     */
    function updatePauser(address _newPauser) external onlyOwner {
        require(
            _newPauser != address(0),
            &quot;Pausable: new pauser is the zero address&quot;
        );
        pauser = _newPauser;
        emit PauserChanged(pauser);
    }
}

// File: contracts/v1/Blacklistable.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title Blacklistable Token
 * @dev Allows accounts to be blacklisted by a &quot;blacklister&quot; role
 */
contract Blacklistable is Ownable {
    address public blacklister;
    mapping(address =&gt; bool) internal blacklisted;

    event Blacklisted(address indexed _account);
    event UnBlacklisted(address indexed _account);
    event BlacklisterChanged(address indexed newBlacklister);

    /**
     * @dev Throws if called by any account other than the blacklister
     */
    modifier onlyBlacklister() {
        require(
            msg.sender == blacklister,
            &quot;Blacklistable: caller is not the blacklister&quot;
        );
        _;
    }

    /**
     * @dev Throws if argument account is blacklisted
     * @param _account The address to check
     */
    modifier notBlacklisted(address _account) {
        require(
            !blacklisted[_account],
            &quot;Blacklistable: account is blacklisted&quot;
        );
        _;
    }

    /**
     * @dev Checks if account is blacklisted
     * @param _account The address to check
     */
    function isBlacklisted(address _account) external view returns (bool) {
        return blacklisted[_account];
    }

    /**
     * @dev Adds account to blacklist
     * @param _account The address to blacklist
     */
    function blacklist(address _account) external onlyBlacklister {
        blacklisted[_account] = true;
        emit Blacklisted(_account);
    }

    /**
     * @dev Removes account from blacklist
     * @param _account The address to remove from the blacklist
     */
    function unBlacklist(address _account) external onlyBlacklister {
        blacklisted[_account] = false;
        emit UnBlacklisted(_account);
    }

    function updateBlacklister(address _newBlacklister) external onlyOwner {
        require(
            _newBlacklister != address(0),
            &quot;Blacklistable: new blacklister is the zero address&quot;
        );
        blacklister = _newBlacklister;
        emit BlacklisterChanged(blacklister);
    }
}

// File: contracts/v1/FiatTokenV1.sol

/**
 *
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title FiatToken
 * @dev ERC20 Token backed by fiat reserves
 */
contract FiatTokenV1 is AbstractFiatTokenV1, Ownable, Pausable, Blacklistable {
    using SafeMath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    string public currency;
    address public masterMinter;
    bool internal initialized;

    mapping(address =&gt; uint256) internal balances;
    mapping(address =&gt; mapping(address =&gt; uint256)) internal allowed;
    uint256 internal totalSupply_ = 0;
    mapping(address =&gt; bool) internal minters;
    mapping(address =&gt; uint256) internal minterAllowed;

    event Mint(address indexed minter, address indexed to, uint256 amount);
    event Burn(address indexed burner, uint256 amount);
    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);
    event MinterRemoved(address indexed oldMinter);
    event MasterMinterChanged(address indexed newMasterMinter);

    function initialize(
        string memory tokenName,
        string memory tokenSymbol,
        string memory tokenCurrency,
        uint8 tokenDecimals,
        address newMasterMinter,
        address newPauser,
        address newBlacklister,
        address newOwner
    ) public {
        require(!initialized, &quot;FiatToken: contract is already initialized&quot;);
        require(
            newMasterMinter != address(0),
            &quot;FiatToken: new masterMinter is the zero address&quot;
        );
        require(
            newPauser != address(0),
            &quot;FiatToken: new pauser is the zero address&quot;
        );
        require(
            newBlacklister != address(0),
            &quot;FiatToken: new blacklister is the zero address&quot;
        );
        require(
            newOwner != address(0),
            &quot;FiatToken: new owner is the zero address&quot;
        );

        name = tokenName;
        symbol = tokenSymbol;
        currency = tokenCurrency;
        decimals = tokenDecimals;
        masterMinter = newMasterMinter;
        pauser = newPauser;
        blacklister = newBlacklister;
        setOwner(newOwner);
        initialized = true;
    }

    /**
     * @dev Throws if called by any account other than a minter
     */
    modifier onlyMinters() {
        require(minters[msg.sender], &quot;FiatToken: caller is not a minter&quot;);
        _;
    }

    /**
     * @dev Function to mint tokens
     * @param _to The address that will receive the minted tokens.
     * @param _amount The amount of tokens to mint. Must be less than or equal
     * to the minterAllowance of the caller.
     * @return A boolean that indicates if the operation was successful.
     */
    function mint(address _to, uint256 _amount)
    external
    whenNotPaused
    onlyMinters
    notBlacklisted(msg.sender)
    notBlacklisted(_to)
    returns (bool)
    {
        require(_to != address(0), &quot;FiatToken: mint to the zero address&quot;);
        require(_amount &gt; 0, &quot;FiatToken: mint amount not greater than 0&quot;);

        uint256 mintingAllowedAmount = minterAllowed[msg.sender];
        require(
            _amount &lt;= mintingAllowedAmount,
            &quot;FiatToken: mint amount exceeds minterAllowance&quot;
        );

        totalSupply_ = totalSupply_.add(_amount);
        balances[_to] = balances[_to].add(_amount);
        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);
        emit Mint(msg.sender, _to, _amount);
        emit Transfer(address(0), _to, _amount);
        return true;
    }

    /**
     * @dev Throws if called by any account other than the masterMinter
     */
    modifier onlyMasterMinter() {
        require(
            msg.sender == masterMinter,
            &quot;FiatToken: caller is not the masterMinter&quot;
        );
        _;
    }

    /**
     * @dev Get minter allowance for an account
     * @param minter The address of the minter
     */
    function minterAllowance(address minter) external view returns (uint256) {
        return minterAllowed[minter];
    }

    /**
     * @dev Checks if account is a minter
     * @param account The address to check
     */
    function isMinter(address account) external view returns (bool) {
        return minters[account];
    }

    /**
     * @notice Amount of remaining tokens spender is allowed to transfer on
     * behalf of the token owner
     * @param owner     Token owner's address
     * @param spender   Spender's address
     * @return Allowance amount
     */
    function allowance(address owner, address spender)
    external
    override
    view
    returns (uint256)
    {
        return allowed[owner][spender];
    }

    /**
     * @dev Get totalSupply of token
     */
    function totalSupply() external override view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @dev Get token balance of an account
     * @param account address The account
     */
    function balanceOf(address account)
    external
    override
    view
    returns (uint256)
    {
        return balances[account];
    }

    /**
     * @notice Set spender's allowance over the caller's tokens to be a given
     * value.
     * @param spender   Spender's address
     * @param value     Allowance amount
     * @return True if successful
     */
    function approve(address spender, uint256 value)
    external
    override
    whenNotPaused
    notBlacklisted(msg.sender)
    notBlacklisted(spender)
    returns (bool)
    {
        _approve(msg.sender, spender, value);
        return true;
    }

    /**
     * @dev Internal function to set allowance
     * @param owner     Token owner's address
     * @param spender   Spender's address
     * @param value     Allowance amount
     */
    function _approve(
        address owner,
        address spender,
        uint256 value
    ) internal override {
        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);
        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);
        allowed[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @notice Transfer tokens by spending allowance
     * @param from  Payer's address
     * @param to    Payee's address
     * @param value Transfer amount
     * @return True if successful
     */
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
    external
    override
    whenNotPaused
    notBlacklisted(msg.sender)
    notBlacklisted(from)
    notBlacklisted(to)
    returns (bool)
    {
        require(
            value &lt;= allowed[from][msg.sender],
            &quot;ERC20: transfer amount exceeds allowance&quot;
        );
        _transfer(from, to, value);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
        return true;
    }

    /**
     * @notice Transfer tokens from the caller
     * @param to    Payee's address
     * @param value Transfer amount
     * @return True if successful
     */
    function transfer(address to, uint256 value)
    external
    override
    whenNotPaused
    notBlacklisted(msg.sender)
    notBlacklisted(to)
    returns (bool)
    {
        _transfer(msg.sender, to, value);
        return true;
    }

    /**
     * @notice Internal function to process transfers
     * @param from  Payer's address
     * @param to    Payee's address
     * @param value Transfer amount
     */
    function _transfer(
        address from,
        address to,
        uint256 value
    ) internal override {
        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);
        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);
        require(
            value &lt;= balances[from],
            &quot;ERC20: transfer amount exceeds balance&quot;
        );

        balances[from] = balances[from].sub(value);
        balances[to] = balances[to].add(value);
        emit Transfer(from, to, value);
    }

    /**
     * @dev Function to add/update a new minter
     * @param minter The address of the minter
     * @param minterAllowedAmount The minting amount allowed for the minter
     * @return True if the operation was successful.
     */
    function configureMinter(address minter, uint256 minterAllowedAmount)
    external
    whenNotPaused
    onlyMasterMinter
    returns (bool)
    {
        minters[minter] = true;
        minterAllowed[minter] = minterAllowedAmount;
        emit MinterConfigured(minter, minterAllowedAmount);
        return true;
    }

    /**
     * @dev Function to remove a minter
     * @param minter The address of the minter to remove
     * @return True if the operation was successful.
     */
    function removeMinter(address minter)
    external
    onlyMasterMinter
    returns (bool)
    {
        minters[minter] = false;
        minterAllowed[minter] = 0;
        emit MinterRemoved(minter);
        return true;
    }

    /**
     * @dev allows a minter to burn some of its own tokens
     * Validates that caller is a minter and that sender is not blacklisted
     * amount is less than or equal to the minter's account balance
     * @param _amount uint256 the amount of tokens to be burned
     */
    function burn(uint256 _amount)
    external
    whenNotPaused
    onlyMinters
    notBlacklisted(msg.sender)
    {
        uint256 balance = balances[msg.sender];
        require(_amount &gt; 0, &quot;FiatToken: burn amount not greater than 0&quot;);
        require(balance &gt;= _amount, &quot;FiatToken: burn amount exceeds balance&quot;);

        totalSupply_ = totalSupply_.sub(_amount);
        balances[msg.sender] = balance.sub(_amount);
        emit Burn(msg.sender, _amount);
        emit Transfer(msg.sender, address(0), _amount);
    }

    function updateMasterMinter(address _newMasterMinter) external onlyOwner {
        require(
            _newMasterMinter != address(0),
            &quot;FiatToken: new masterMinter is the zero address&quot;
        );
        masterMinter = _newMasterMinter;
        emit MasterMinterChanged(masterMinter);
    }
}

// File: @openzeppelin/contracts/utils/Address.sol

pragma solidity ^0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;

        bytes32 accountHash
        = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            codehash := extcodehash(account)
        }
        return (codehash != accountHash &amp;&amp; codehash != 0x0);
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance &gt;= amount,
            &quot;Address: insufficient balance&quot;
        );

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }(&quot;&quot;);
        require(
            success,
            &quot;Address: unable to send value, recipient may have reverted&quot;
        );
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data)
    internal
    returns (bytes memory)
    {
        return functionCall(target, data, &quot;Address: low-level call failed&quot;);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
            target,
            data,
            value,
            &quot;Address: low-level call with value failed&quot;
        );
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance &gt;= value,
            &quot;Address: insufficient balance for call&quot;
        );
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), &quot;Address: call to non-contract&quot;);

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{
                value: weiValue
            }(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length &gt; 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol

pragma solidity ^0.6.0;

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transfer.selector, to, value)
        );
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.approve.selector, spender, value)
        );
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(
            value
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(
            value,
            &quot;SafeERC20: decreased allowance below zero&quot;
        );
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(
                token.approve.selector,
                spender,
                newAllowance
            )
        );
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(
            data,
            &quot;SafeERC20: low-level call failed&quot;
        );
        if (returndata.length &gt; 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(
                abi.decode(returndata, (bool)),
                &quot;SafeERC20: ERC20 operation did not succeed&quot;
            );
        }
    }
}

// File: contracts/v1.1/Rescuable.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

contract Rescuable is Ownable {
    using SafeERC20 for IERC20;

    address private _rescuer;

    event RescuerChanged(address indexed newRescuer);

    /**
     * @notice Returns current rescuer
     * @return Rescuer's address
     */
    function rescuer() external view returns (address) {
        return _rescuer;
    }

    /**
     * @notice Revert if called by any account other than the rescuer.
     */
    modifier onlyRescuer() {
        require(msg.sender == _rescuer, &quot;Rescuable: caller is not the rescuer&quot;);
        _;
    }

    /**
     * @notice Rescue ERC20 tokens locked up in this contract.
     * @param tokenContract ERC20 token contract address
     * @param to        Recipient address
     * @param amount    Amount to withdraw
     */
    function rescueERC20(
        IERC20 tokenContract,
        address to,
        uint256 amount
    ) external onlyRescuer {
        tokenContract.safeTransfer(to, amount);
    }

    /**
     * @notice Assign the rescuer role to a given address.
     * @param newRescuer New rescuer's address
     */
    function updateRescuer(address newRescuer) external onlyOwner {
        require(
            newRescuer != address(0),
            &quot;Rescuable: new rescuer is the zero address&quot;
        );
        _rescuer = newRescuer;
        emit RescuerChanged(newRescuer);
    }
}

// File: contracts/v1.1/FiatTokenV1_1.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title FiatTokenV1_1
 * @dev ERC20 Token backed by fiat reserves
 */
contract FiatTokenV1_1 is FiatTokenV1, Rescuable {

}

// File: contracts/v2/AbstractFiatTokenV2.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

abstract contract AbstractFiatTokenV2 is AbstractFiatTokenV1 {
    function _increaseAllowance(
        address owner,
        address spender,
        uint256 increment
    ) internal virtual;

    function _decreaseAllowance(
        address owner,
        address spender,
        uint256 decrement
    ) internal virtual;
}

// File: contracts/util/ECRecover.sol

/**
 * Copyright (c) 2016-2019 zOS Global Limited
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title ECRecover
 * @notice A library that provides a safe ECDSA recovery function
 */
library ECRecover {
    /**
     * @notice Recover signer's address from a signed message
     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65e4ffde586ec89af3b7e9140bdc9235d1254853/contracts/cryptography/ECDSA.sol
     * Modifications: Accept v, r, and s as separate arguments
     * @param digest    Keccak-256 hash digest of the signed message
     * @param v         v of the signature
     * @param r         r of the signature
     * @param s         s of the signature
     * @return Signer address
     */
    function recover(
        bytes32 digest,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 &lt; s &lt; secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (
            uint256(s) &gt;
            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
        ) {
            revert(&quot;ECRecover: invalid signature 's' value&quot;);
        }

        if (v != 27 &amp;&amp; v != 28) {
            revert(&quot;ECRecover: invalid signature 'v' value&quot;);
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(digest, v, r, s);
        require(signer != address(0), &quot;ECRecover: invalid signature&quot;);

        return signer;
    }
}

// File: contracts/util/EIP712.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title EIP712
 * @notice A library that provides EIP712 helper functions
 */
library EIP712 {
    /**
     * @notice Make EIP712 domain separator
     * @param name      Contract name
     * @param version   Contract version
     * @return Domain separator
     */
    function makeDomainSeparator(string memory name, string memory version)
    internal
    view
    returns (bytes32)
    {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return
            keccak256(
            abi.encode(
            // keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;)
                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,
                keccak256(bytes(name)),
                keccak256(bytes(version)),
                chainId,
                address(this)
            )
        );
    }

    /**
     * @notice Recover signer's address from a EIP712 signature
     * @param domainSeparator   Domain separator
     * @param v                 v of the signature
     * @param r                 r of the signature
     * @param s                 s of the signature
     * @param typeHashAndData   Type hash concatenated with data
     * @return Signer's address
     */
    function recover(
        bytes32 domainSeparator,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes memory typeHashAndData
    ) internal pure returns (address) {
        bytes32 digest = keccak256(
            abi.encodePacked(
                &quot;\x19\x01&quot;,
                domainSeparator,
                keccak256(typeHashAndData)
            )
        );
        return ECRecover.recover(digest, v, r, s);
    }
}

// File: contracts/v2/EIP712Domain.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title EIP712 Domain
 */
contract EIP712Domain {
    /**
     * @dev EIP712 Domain Separator
     */
    bytes32 public DOMAIN_SEPARATOR;
}

// File: contracts/v2/EIP3009.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title EIP-3009
 * @notice Provide internal implementation for gas-abstracted transfers
 * @dev Contracts that inherit from this must wrap these with publicly
 * accessible functions, optionally adding modifiers where necessary
 */
abstract contract EIP3009 is AbstractFiatTokenV2, EIP712Domain {
    // keccak256(&quot;TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)&quot;)
    bytes32
    public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;

    // keccak256(&quot;ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)&quot;)
    bytes32
    public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;

    // keccak256(&quot;CancelAuthorization(address authorizer,bytes32 nonce)&quot;)
    bytes32
    public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;

    /**
     * @dev authorizer address =&gt; nonce =&gt; bool (true if nonce is used)
     */
    mapping(address =&gt; mapping(bytes32 =&gt; bool)) private _authorizationStates;

    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);
    event AuthorizationCanceled(
        address indexed authorizer,
        bytes32 indexed nonce
    );

    /**
     * @notice Returns the state of an authorization
     * @dev Nonces are randomly generated 32-byte data unique to the
     * authorizer's address
     * @param authorizer    Authorizer's address
     * @param nonce         Nonce of the authorization
     * @return True if the nonce is used
     */
    function authorizationState(address authorizer, bytes32 nonce)
    external
    view
    returns (bool)
    {
        return _authorizationStates[authorizer][nonce];
    }

    /**
     * @notice Execute a transfer with a signed authorization
     * @param from          Payer's address (Authorizer)
     * @param to            Payee's address
     * @param value         Amount to be transferred
     * @param validAfter    The time after which this is valid (unix time)
     * @param validBefore   The time before which this is valid (unix time)
     * @param nonce         Unique nonce
     * @param v             v of the signature
     * @param r             r of the signature
     * @param s             s of the signature
     */
    function _transferWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        _requireValidAuthorization(from, nonce, validAfter, validBefore);

        bytes memory data = abi.encode(
            TRANSFER_WITH_AUTHORIZATION_TYPEHASH,
            from,
            to,
            value,
            validAfter,
            validBefore,
            nonce
        );
        require(
            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,
            &quot;FiatTokenV2: invalid signature&quot;
        );

        _markAuthorizationAsUsed(from, nonce);
        _transfer(from, to, value);
    }

    /**
     * @notice Receive a transfer with a signed authorization from the payer
     * @dev This has an additional check to ensure that the payee's address
     * matches the caller of this function to prevent front-running attacks.
     * @param from          Payer's address (Authorizer)
     * @param to            Payee's address
     * @param value         Amount to be transferred
     * @param validAfter    The time after which this is valid (unix time)
     * @param validBefore   The time before which this is valid (unix time)
     * @param nonce         Unique nonce
     * @param v             v of the signature
     * @param r             r of the signature
     * @param s             s of the signature
     */
    function _receiveWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        require(to == msg.sender, &quot;FiatTokenV2: caller must be the payee&quot;);
        _requireValidAuthorization(from, nonce, validAfter, validBefore);

        bytes memory data = abi.encode(
            RECEIVE_WITH_AUTHORIZATION_TYPEHASH,
            from,
            to,
            value,
            validAfter,
            validBefore,
            nonce
        );
        require(
            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,
            &quot;FiatTokenV2: invalid signature&quot;
        );

        _markAuthorizationAsUsed(from, nonce);
        _transfer(from, to, value);
    }

    /**
     * @notice Attempt to cancel an authorization
     * @param authorizer    Authorizer's address
     * @param nonce         Nonce of the authorization
     * @param v             v of the signature
     * @param r             r of the signature
     * @param s             s of the signature
     */
    function _cancelAuthorization(
        address authorizer,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        _requireUnusedAuthorization(authorizer, nonce);

        bytes memory data = abi.encode(
            CANCEL_AUTHORIZATION_TYPEHASH,
            authorizer,
            nonce
        );
        require(
            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == authorizer,
            &quot;FiatTokenV2: invalid signature&quot;
        );

        _authorizationStates[authorizer][nonce] = true;
        emit AuthorizationCanceled(authorizer, nonce);
    }

    /**
     * @notice Check that an authorization is unused
     * @param authorizer    Authorizer's address
     * @param nonce         Nonce of the authorization
     */
    function _requireUnusedAuthorization(address authorizer, bytes32 nonce)
    private
    view
    {
        require(
            !_authorizationStates[authorizer][nonce],
            &quot;FiatTokenV2: authorization is used or canceled&quot;
        );
    }

    /**
     * @notice Check that authorization is valid
     * @param authorizer    Authorizer's address
     * @param nonce         Nonce of the authorization
     * @param validAfter    The time after which this is valid (unix time)
     * @param validBefore   The time before which this is valid (unix time)
     */
    function _requireValidAuthorization(
        address authorizer,
        bytes32 nonce,
        uint256 validAfter,
        uint256 validBefore
    ) private view {
        require(
            now &gt; validAfter,
            &quot;FiatTokenV2: authorization is not yet valid&quot;
        );
        require(now &lt; validBefore, &quot;FiatTokenV2: authorization is expired&quot;);
        _requireUnusedAuthorization(authorizer, nonce);
    }

    /**
     * @notice Mark an authorization as used
     * @param authorizer    Authorizer's address
     * @param nonce         Nonce of the authorization
     */
    function _markAuthorizationAsUsed(address authorizer, bytes32 nonce)
    private
    {
        _authorizationStates[authorizer][nonce] = true;
        emit AuthorizationUsed(authorizer, nonce);
    }
}

// File: contracts/v2/EIP2612.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title EIP-2612
 * @notice Provide internal implementation for gas-abstracted approvals
 */
abstract contract EIP2612 is AbstractFiatTokenV2, EIP712Domain {
    // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;)
    bytes32
    public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    mapping(address =&gt; uint256) private _permitNonces;

    /**
     * @notice Nonces for permit
     * @param owner Token owner's address (Authorizer)
     * @return Next nonce
     */
    function nonces(address owner) external view returns (uint256) {
        return _permitNonces[owner];
    }

    /**
     * @notice Verify a signed approval permit and execute if valid
     * @param owner     Token owner's address (Authorizer)
     * @param spender   Spender's address
     * @param value     Amount of allowance
     * @param deadline  The time at which this expires (unix time)
     * @param v         v of the signature
     * @param r         r of the signature
     * @param s         s of the signature
     */
    function _permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        require(deadline &gt;= now, &quot;FiatTokenV2: permit is expired&quot;);

        bytes memory data = abi.encode(
            PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            _permitNonces[owner]++,
            deadline
        );
        require(
            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,
            &quot;EIP2612: invalid signature&quot;
        );

        _approve(owner, spender, value);
    }
}

// File: contracts/v2/FiatTokenV2.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

/**
 * @title FiatToken V2
 * @notice ERC20 Token backed by fiat reserves, version 2
 */
contract FiatTokenV2 is FiatTokenV1_1, EIP3009, EIP2612 {
    uint8 internal _initializedVersion;

    /**
     * @notice Initialize v2
     * @param newName   New token name
     */
    function initializeV2(string calldata newName) external {
        // solhint-disable-next-line reason-string
        require(initialized &amp;&amp; _initializedVersion == 0);
        name = newName;
        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(newName, &quot;2&quot;);
        _initializedVersion = 1;
    }

    /**
     * @notice Increase the allowance by a given increment
     * @param spender   Spender's address
     * @param increment Amount of increase in allowance
     * @return True if successful
     */
    function increaseAllowance(address spender, uint256 increment)
    external
    whenNotPaused
    notBlacklisted(msg.sender)
    notBlacklisted(spender)
    returns (bool)
    {
        _increaseAllowance(msg.sender, spender, increment);
        return true;
    }

    /**
     * @notice Decrease the allowance by a given decrement
     * @param spender   Spender's address
     * @param decrement Amount of decrease in allowance
     * @return True if successful
     */
    function decreaseAllowance(address spender, uint256 decrement)
    external
    whenNotPaused
    notBlacklisted(msg.sender)
    notBlacklisted(spender)
    returns (bool)
    {
        _decreaseAllowance(msg.sender, spender, decrement);
        return true;
    }

    /**
     * @notice Execute a transfer with a signed authorization
     * @param from          Payer's address (Authorizer)
     * @param to            Payee's address
     * @param value         Amount to be transferred
     * @param validAfter    The time after which this is valid (unix time)
     * @param validBefore   The time before which this is valid (unix time)
     * @param nonce         Unique nonce
     * @param v             v of the signature
     * @param r             r of the signature
     * @param s             s of the signature
     */
    function transferWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external whenNotPaused notBlacklisted(from) notBlacklisted(to) {
        _transferWithAuthorization(
            from,
            to,
            value,
            validAfter,
            validBefore,
            nonce,
            v,
            r,
            s
        );
    }

    /**
     * @notice Receive a transfer with a signed authorization from the payer
     * @dev This has an additional check to ensure that the payee's address
     * matches the caller of this function to prevent front-running attacks.
     * @param from          Payer's address (Authorizer)
     * @param to            Payee's address
     * @param value         Amount to be transferred
     * @param validAfter    The time after which this is valid (unix time)
     * @param validBefore   The time before which this is valid (unix time)
     * @param nonce         Unique nonce
     * @param v             v of the signature
     * @param r             r of the signature
     * @param s             s of the signature
     */
    function receiveWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external whenNotPaused notBlacklisted(from) notBlacklisted(to) {
        _receiveWithAuthorization(
            from,
            to,
            value,
            validAfter,
            validBefore,
            nonce,
            v,
            r,
            s
        );
    }

    /**
     * @notice Attempt to cancel an authorization
     * @dev Works only if the authorization is not yet used.
     * @param authorizer    Authorizer's address
     * @param nonce         Nonce of the authorization
     * @param v             v of the signature
     * @param r             r of the signature
     * @param s             s of the signature
     */
    function cancelAuthorization(
        address authorizer,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external whenNotPaused {
        _cancelAuthorization(authorizer, nonce, v, r, s);
    }

    /**
     * @notice Update allowance with a signed permit
     * @param owner       Token owner's address (Authorizer)
     * @param spender     Spender's address
     * @param value       Amount of allowance
     * @param deadline    Expiration time, seconds since the epoch
     * @param v           v of the signature
     * @param r           r of the signature
     * @param s           s of the signature
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) {
        _permit(owner, spender, value, deadline, v, r, s);
    }

    /**
     * @notice Internal function to increase the allowance by a given increment
     * @param owner     Token owner's address
     * @param spender   Spender's address
     * @param increment Amount of increase
     */
    function _increaseAllowance(
        address owner,
        address spender,
        uint256 increment
    ) internal override {
        _approve(owner, spender, allowed[owner][spender].add(increment));
    }

    /**
     * @notice Internal function to decrease the allowance by a given decrement
     * @param owner     Token owner's address
     * @param spender   Spender's address
     * @param decrement Amount of decrease
     */
    function _decreaseAllowance(
        address owner,
        address spender,
        uint256 decrement
    ) internal override {
        _approve(
            owner,
            spender,
            allowed[owner][spender].sub(
                decrement,
                &quot;ERC20: decreased allowance below zero&quot;
            )
        );
    }
}

// File: contracts/v2/FiatTokenV2_1.sol

/**
 * Copyright (c) 2018-2020 CENTRE SECZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

pragma solidity 0.6.12;

// solhint-disable func-name-mixedcase

/**
 * @title FiatToken V2.1
 * @notice ERC20 Token backed by fiat reserves, version 2.1
 */
contract FiatTokenV2_1 is FiatTokenV2 {
    /**
     * @notice Initialize v2.1
     * @param lostAndFound  The address to which the locked funds are sent
     */
    function initializeV2_1(address lostAndFound) external {
        // solhint-disable-next-line reason-string
        require(_initializedVersion == 1);

        uint256 lockedAmount = balances[address(this)];
        if (lockedAmount &gt; 0) {
            _transfer(address(this), lostAndFound, lockedAmount);
        }
        blacklisted[address(this)] = true;

        _initializedVersion = 2;
    }

    /**
     * @notice Version string for the EIP712 domain separator
     * @return Version string
     */
    function version() external view returns (string memory) {
        return &quot;2&quot;;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0323tarithrottle"><a class="header" href="#rfc-0323tarithrottle">RFC-0323/TariThrottle</a></h1>
<h2 id="the-tari-throttle-or-layer-2-burn-rate-controller"><a class="header" href="#the-tari-throttle-or-layer-2-burn-rate-controller">The Tari throttle, or Layer 2 burn rate controller</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-44"><a class="header" href="#licence-44">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-47"><a class="header" href="#language-47">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-47"><a class="header" href="#disclaimer-47">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-46"><a class="header" href="#goals-46">Goals</a></h2>
<p>This RFC provides an introductory exploratory analysis into the mechanisms behind a proposed Tari throttle: a Layer 
2 controller for the L2 fee burn rate to control the Tari circulating supply. </p>
<h2 id="related-requests-for-comment-39"><a class="header" href="#related-requests-for-comment-39">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0303_DanOverview.html">RFC-0303: The Digital Assets Network Overview</a></li>
<li><a href="RFC-0320_TurbineModel.html">RFC-0320: The turbine model</a></li>
</ul>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="RFC-0323_TariThrottle.html#summary">Summary</a></li>
<li><a href="RFC-0323_TariThrottle.html#pid-controllers">PID controllers</a></li>
<li><a href="RFC-0323_TariThrottle.html#tari-throttle">Tari throttle</a>
<ul>
<li><a href="RFC-0323_TariThrottle.html#controller-parameters">Controller parameters</a></li>
<li><a href="RFC-0323_TariThrottle.html#controller-inputs">Controller inputs</a>
<ul>
<li><a href="RFC-0323_TariThrottle.html#fee-models">Fee models</a></li>
<li><a href="RFC-0323_TariThrottle.html#emission-model">Emission model</a></li>
<li><a href="RFC-0323_TariThrottle.html#miscellaneous-parameters">Miscellaneous parameters</a></li>
<li><a href="RFC-0323_TariThrottle.html#integer-control">Integer control</a></li>
</ul>
</li>
<li><a href="RFC-0323_TariThrottle.html#the-simulations">The simulations</a>
<ul>
<li><a href="RFC-0323_TariThrottle.html#controller-parameters-1">Controller parameters</a></li>
<li><a href="RFC-0323_TariThrottle.html#target-supply">Target supply</a></li>
<li><a href="RFC-0323_TariThrottle.html#fee-models-1">Fee models</a></li>
</ul>
</li>
<li><a href="RFC-0323_TariThrottle.html#results">Results</a>
<ul>
<li><a href="RFC-0323_TariThrottle.html#21-billion-tari-target-supply">21 billion Tari target supply</a></li>
<li><a href="RFC-0323_TariThrottle.html#18-billion-tari-target-supply">18 billion Tari target supply</a></li>
<li><a href="RFC-0323_TariThrottle.html#15-billion-tari-target-supply">15 billion Tari target supply</a></li>
</ul>
</li>
<li><a href="RFC-0323_TariThrottle.html#discussion">Discussion</a>
<ul>
<li><a href="RFC-0323_TariThrottle.html#low-fees-growth">Low fees growth</a></li>
<li><a href="RFC-0323_TariThrottle.html#high-fees-growth">High fees growth</a></li>
<li><a href="RFC-0323_TariThrottle.html#unstable-fee-revenue">Unstable fee revenue</a></li>
<li><a href="RFC-0323_TariThrottle.html#slower-growth-with-tapering-fees">Slower growth with tapering fees</a></li>
<li><a href="RFC-0323_TariThrottle.html#strong-growth-with-tapering-fees">Strong growth with tapering fees</a></li>
</ul>
</li>
<li><a href="RFC-0323_TariThrottle.html#conclusions">Conclusions</a></li>
</ul>
</li>
</ul>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>TariThrottle is a simple process controller designed to modulate the layer two burn rate in order to achieve two 
goals:</p>
<ul>
<li>Primarily, keep the emission and burn rate roughly balanced (ensuring the long-term sustainability of Tari), and</li>
<li>Secondarily, to maintain the total circulating supply at a target value (satisfying an implicit assumption in 
cryptocurrencies that token supplies are finite).</li>
</ul>
<p>A proof-of-concept controller has been implemented and tested in a simulation environment (<a href="https://github.com/tari-project/burn-sim" title="TariThrottle simulation repository">repository</a>). As the 
results below attest, the controller logic is sufficient to achieve these goals, even under highly volatile layer 
two fee conditions. </p>
<p>However, the controller achieves the goals at the expense of a rapidly changing layer two burn rate, which may be 
detrimental to the sustainability of validator nodes. </p>
<p>At the risk of the tail wagging the dog, the primary conclusion of this study is that the TariThrottle controller 
should likely <em>not</em> aim to maintain a supply target, but instead to ensure a sustainable layer two ecosystem, to 
whit:</p>
<ul>
<li>maintain a constant demand gradient so that under normal circumstances there is <em>always</em> a demand for new Tari and 
thus Minotari are constantly being burnt to satisfy this demand,</li>
<li>marginal Validator Nodes are able to operate at or near break-even rates, while maintaining a healthy reserve of 
capacity for surge demand, </li>
<li>minimum transaction fees remain below $0.01 in today's money, and </li>
<li>the supply of Minotari is sustainable over the long-term.</li>
</ul>
<p>Therefore, the conclusion of this study is not to abandon the original targets of the TariThrottle completely, 
but to adjust the priority of the primary goal (a sustainable long-term balance), and make it subservient to the 
primary goal of ensuring a constant demand gradient.</p>
<p>A modified Tari throttle model that seeks to achieve these aims is outside of the scope of this RFC and is left for 
a follow-up study.</p>
<h2 id="pid-controllers"><a class="header" href="#pid-controllers">PID controllers</a></h2>
<p>TariThrottle is based on a simple
<a href="https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller">PID controller</a> design.</p>
<p>PID controllers are a type of control system that uses feedback to maintain a system in a desired state.  They are 
widely used in industrial control systems.</p>
<p>The PID controller has three components:</p>
<ul>
<li>Proportional: This component is proportional to the error between the setpoint and the current value.  It is
the primary component of the controller and is used to drive the system towards the setpoint.</li>
<li>Integral: This component is proportional to the integral of the error over time.  It is used to eliminate
steady-state error.</li>
<li>Derivative: This component is proportional to the rate of change of the error.  It is used to reduce overshoot
and oscillation.</li>
</ul>
<h2 id="tari-throttle"><a class="header" href="#tari-throttle">Tari throttle</a></h2>
<p>The <code>burn-sim</code> <a href="https://github.com/tari-project/burn-sim" title="TariThrottle simulation repository">repository</a> was used to generate the results in this exploratory study.</p>
<p>The primary module in the repository is the <code>TariThrottle</code> struct.</p>
<p>This struct holds the following data:</p>
<ul>
<li>The <a href="RFC-0323_TariThrottle.html#controller-parameters">controller parameters</a>,</li>
<li>The output variable, <code>burn_rate</code>. The burn rate is defined as the fraction of fees collected on the layer 2 that 
are burnt as exhaust (see the <a href="/RFC-0320_TurbineModel.html" title="Turbine model">turbine model</a>), and</li>
<li>The three functions that describe how the controller responds to the input variables.</li>
</ul>
<h2 id="controller-parameters"><a class="header" href="#controller-parameters">Controller parameters</a></h2>
<p>The controller parameters are used to tune the controller behaviour. They give operators the ability to fine-tune 
the behaviour of the controller without having to change the underlying code.</p>
<p>Specifically, the controller parameters are:</p>
<ul>
<li><code>kp</code>: determines the weight of the net burn component of the controller.  The net burn component is the difference
between the emission and the current rate of L2 token burn. When emission equals burn, the total supply of Tari
will remain constant.</li>
<li><code>ki</code>: determines the weight of the integral component of the controller.  This is calculated as the difference
between the current total supply and the target supply. If the total circulating supply is at the target value, 
then this term will be zero.</li>
<li><code>kd</code>: determines the weight of the derivative component of the controller.  This is currently not used, since the
controller is able to adequately control supply with just the proportional and integral terms.</li>
<li><code>target_supply</code>: the target circulating supply of Tari.</li>
<li><code>trigger_at</code>: the block height at which the controller logic becomes active.</li>
<li><code>max</code>: the maximum burn rate that the controller will allow.</li>
<li><code>min</code>: the minimum burn rate that the controller will allow. The maximum and minimum are important parameters to 
prevent extreme burn rates that could be detrimental to the sustainability of the network.</li>
</ul>
<h2 id="controller-inputs"><a class="header" href="#controller-inputs">Controller inputs</a></h2>
<p>The controller operates over <code>periods</code>. A period is the number of blocks over which the controller will operate 
without being able to change the burn rate. In practice, this is determined by the epoch length of the Layer two.</p>
<p>The total quantity of fees collected across the entire network is only known at the end of every epoch. This is a 
key input into the controller, and therefore we are limited to updating the burn rate at the end of each epoch as well.</p>
<p>For this study, the period length is set to 720 blocks, or roughly one day.</p>
<h3 id="fee-models"><a class="header" href="#fee-models">Fee models</a></h3>
<p>Since we don't know what the Tari fees will be in the future, we can only carry out simulations based on various 
<em>scenarios</em> of fee growth. For example, we can model a low fee environment, an exponential fee growth environment, a 
highly volatile fee environment, and so on. </p>
<p>In this study, we looked at the following fee models:</p>
<ul>
<li><code>Sigmoidal</code>: a sigmoidal growth model, which looks like an exponential growth model initially, but then levels off 
as the fees approach a maximum value. This is the most likely pattern to appear in practice, since it incorporates 
the idea that as fees become very high, the minimum transaction fee can be reduced so that total fee revenue 
grows sustainably, even as the network usage (in terms of transactions per second) continues to grow.</li>
<li><code>Exponential</code>: a simple exponential growth model. This model assumes a constant annual growth rate in network fees.</li>
<li><code>Sinusoidal</code>: a highly volatile fee environment, where the fees oscillate between a minimum and maximum value. This 
is the not likely scenario to appear in practice, but it is useful to test the robustness of the controller 
logic.</li>
</ul>
<h3 id="emission-model"><a class="header" href="#emission-model">Emission model</a></h3>
<p>The second input to the controller is the number of tokens emitted over the preceding period. This is straightforward 
to model, since the emission curve is known <em>a priori</em>. The currently proposed Minotari mainnet emission curve 
parameters were used to generate the emission inputs for this study, including a 30% premine and a 1% tail emission 
inflation rate.</p>
<h3 id="miscellaneous-parameters"><a class="header" href="#miscellaneous-parameters">Miscellaneous parameters</a></h3>
<p>The <code>trigger_at</code> parameter was generally set to start the controller after the first year of operation, when we 
expect the layer two to go live on mainnet.</p>
<p>The <code>target_supply</code> parameter was set to 15, 18 and 21 billion Tari to determine the effect of different supply 
targets.</p>
<p>The <code>initital_value</code>was set to <code>min</code> to allow the circulating supply to approach the target supply as quickly as 
possible.</p>
<p>The <code>min</code> and <code>max</code> parameters were set to 5% and 50% fee burn rates respectively.</p>
<p>THe <code>period</code> was set to 720 blocks, or roughly one day. The epoch length for Tari has not been finalised yet, but it 
should not be wildly different from this value.</p>
<h3 id="integer-based-division"><a class="header" href="#integer-based-division">Integer-based division</a></h3>
<p>Typical PID controllers use floating-point math in their control algorithms. However, the TariThrottle controller 
will be run on a distributed set of machines that may be operating under different models for floating-point 
operations, since the IEEE leaves some aspects of floating-point math 
<a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/">unspecified</a>.</p>
<p>This is not permissible in Tari, and therefore an integer-based approach to control is implemented in the <code>tari-sim</code> 
<a href="https://github.com/tari-project/burn-sim" title="TariThrottle simulation repository">repository</a>.</p>
<p>Simply put, this involves scaling the error values by a constant to convert them to integers of roughly the same 
order of magnitude, (via <code>error_i_scale</code>). The control parameters are also integers, expressed as &quot;parts per million&quot; 
so that a value of 500,000 corresponds to 0.5 for example, while 10 corresponds to 0.00001. This give sufficient
granularity to the control parameters to allow for effective tuning of the controller.</p>
<h2 id="the-simulations"><a class="header" href="#the-simulations">The simulations</a></h2>
<h3 id="controller-parameters-1"><a class="header" href="#controller-parameters-1">Controller parameters</a></h3>
<p>A preliminary batch of simulations was run to set the controller parameters to values that roughly achieve the stated 
goal above. These simulations are omitted for brevity, but the result indicate that the following parameter range 
provide a good balance between robustness and responsiveness of the Tari throttle:</p>
<ul>
<li><code>kp</code> = 0.0001 - 0.0003. A value closer to 100ppm gives more weight to achieving the target supply, while a value 
closer to 300ppm gives more weight to the net burn rate.  The simulations run scenarios for a <code>ki</code> values of 100,
200 and 300 ppm.</li>
<li><code>ki</code> = -0.00035. This value is negative, since if we're above the target supply, we must increase the burn rate, 
and vice versa.</li>
<li><code>kd</code> = 0. This value is not used in the current implementation, since the controller is able to adequately control 
supply with just the proportional and integral terms.</li>
</ul>
<h3 id="target-supply"><a class="header" href="#target-supply">Target supply</a></h3>
<p>The simulations were run for target circulating supplies of 15, 18 and 21 billion Tari. </p>
<p>Target values other than the quoted &quot;initial supply&quot; of 21 billion Tari were used, because it is actually quite 
difficult to achieve the 21 billion target in practice. This is because the earliest it is possible to even reach 
this value (at ZERO burn rate) is after about 15 years. </p>
<p>This offers very little flexibility to the control logic, and could easily introduce instability into the layer two 
ecosystem.</p>
<p>For this reason, simulations were run with alternative target supplies of 15 and 18 billion Tari to compare how the 
controller reacts with more scope to adjust the burn rate.</p>
<h3 id="fee-models-1"><a class="header" href="#fee-models-1">Fee models</a></h3>
<p>Five different fee models scenarios were employed:</p>
<ol>
<li>&quot;Strong growth, tapering fees&quot;. This scenario describes strong fee growth in the network, reaching 5,000,000 
Tari per day around 6 years after the launch of the layer 2. At a minimum fee of 0.01 Tari per transaction, this 
corresponds to a network activity of around 5,800 tx/s, or roughly double the average activity of the Visa 
network. The 'tapering fees' part of the scenario refers to the fact that this scenario does allow 
the network to continue to grow, but that the total fee revenue grows at a modest 100,000 XTR/d per year. This 
would be achieved by reducing the minimum transaction fee. This also matches the expectation that the price of 
XMR increases with network activity, and so reducing the transaction fee maintains sub-penny transaction fees in 
nominal USD terms.</li>
<li>&quot;Slower growth, tapering fees&quot;. This scenario is identical to &quot;Strong growth, tapering fees&quot;, but with a lower 
maximum fee rate of 1,000,000 Tari per day.</li>
<li>&quot;25% annual fee growth&quot;. This scenario describes a network that grows at 25% per year, without 
compensating by decreasing the minimum transaction fee.</li>
<li>&quot;10% annual fee growth&quot;. This scenario describes a network that grows at 10% per year, without 
compensating by decreasing the minimum transaction fee.</li>
<li>&quot;Unstable fees, low frequency&quot;. This scenario describes a network that has volatile fees, 
oscillating between 0 and 500,000 XTR per day over a 90-day period. This is not a realistic scenario, but it
is useful to test the robustness of the controller logic.</li>
<li>&quot;Unstable fees, high frequency&quot;. This scenario describes a network that has extremely volatile fees, 
oscillating between 0 and 1,000,000 XTR per day over a 14-day period. This is not a very realistic scenario, but it
is useful to test the robustness of the controller logic under extremely volatile conditions.</li>
</ol>
<h2 id="results"><a class="header" href="#results">Results</a></h2>
<p>A simulation was run for every combination of the variations in <code>kp</code>, <code>target_supply</code>, and <code>fee_model</code>. The results
of all 50+ simulation runs are given below.</p>
<h3 id="21-billion-tari-target-supply"><a class="header" href="#21-billion-tari-target-supply">21 billion Tari target supply</a></h3>
<p>All of the following simulations were run with a target supply of 21 billion Tari.</p>
<h3 id="10-annual-fee-growth-low-fee-scenario"><a class="header" href="#10-annual-fee-growth-low-fee-scenario">10% annual fee growth (low fee scenario)</a></h3>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_10%25%20annual%20fee%20growth_0.000100.svg" alt="10% annual fee growth" /></p>
<p>Figure 1. Supply target: 21 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_10%25%20annual%20fee%20growth_0.000200.svg" alt="10% annual fee growth" /></p>
<p>Figure 2. Supply target: 21 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_10%25%20annual%20fee%20growth_0.000300.svg" alt="10% annual fee growth" /></p>
<p>Figure 3. Supply target: 21 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000300.</p>
<h3 id="10-annual-fee-growth-high-fee-scenario"><a class="header" href="#10-annual-fee-growth-high-fee-scenario">10% annual fee growth (high fee scenario)</a></h3>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_25%25%20annual%20fee%20growth_0.000100.svg" alt="25% annual fee growth" /></p>
<p>Figure 4. Supply target: 21 billion XTR. 25% annual fee growth fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_25%25%20annual%20fee%20growth_0.000300.svg" alt="25% annual fee growth" /></p>
<p>Figure 5. Supply target: 21 billion XTR. 25% annual fee growth fee model. <code>kp</code> = 0.000300.</p>
<h3 id="slower-growth-tapering-fees"><a class="header" href="#slower-growth-tapering-fees">Slower growth, tapering fees</a></h3>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000100.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 6. Supply target: 21 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000200.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 7. Supply target: 21 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000300.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 8. Supply target: 21 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000300.</p>
<h3 id="strong-growth-tapering-fees"><a class="header" href="#strong-growth-tapering-fees">Strong growth, tapering fees</a></h3>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000100.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 9. Supply target: 21 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000200.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 10. Supply target: 21 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000300.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 11. Supply target: 21 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000300.</p>
<h3 id="unstable-fees-high-frequency"><a class="header" href="#unstable-fees-high-frequency">Unstable fees, high frequency</a></h3>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000100.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 12. Supply target: 21 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000300.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 13. Supply target: 21 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000300.</p>
<h3 id="unstable-fees-low-frequency"><a class="header" href="#unstable-fees-low-frequency">Unstable fees, low frequency</a></h3>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000100.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 14. Supply target: 21 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000200.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 15. Supply target: 21 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_21000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000300.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 16. Supply target: 21 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000300.</p>
<h3 id="18-billion-tari-target-supply"><a class="header" href="#18-billion-tari-target-supply">18 billion Tari target supply</a></h3>
<p>All of the following simulations were run with a target supply of 18 billion Tari.</p>
<h3 id="10-annual-fee-growth-low-fee-scenario-1"><a class="header" href="#10-annual-fee-growth-low-fee-scenario-1">10% annual fee growth (low fee scenario)</a></h3>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_10%25%20annual%20fee%20growth_0.000100.svg" alt="10% annual fee growth" /></p>
<p>Figure 17. Supply target: 18 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_10%25%20annual%20fee%20growth_0.000200.svg" alt="10% annual fee growth" /></p>
<p>Figure 18. Supply target: 18 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_10%25%20annual%20fee%20growth_0.000300.svg" alt="10% annual fee growth" /></p>
<p>Figure 19. Supply target: 18 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000300.</p>
<h3 id="10-annual-fee-growth-high-fee-scenario-1"><a class="header" href="#10-annual-fee-growth-high-fee-scenario-1">10% annual fee growth (high fee scenario)</a></h3>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_25%25%20annual%20fee%20growth_0.000100.svg" alt="25% annual fee growth" /></p>
<p>Figure 20. Supply target: 18 billion XTR. 25% annual fee growth fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_25%25%20annual%20fee%20growth_0.000200.svg" alt="25% annual fee growth" /></p>
<p>Figure 21. Supply target: 18 billion XTR. 25% annual fee growth fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_25%25%20annual%20fee%20growth_0.000300.svg" alt="25% annual fee growth" /></p>
<p>Figure 22. Supply target: 18 billion XTR. 25% annual fee growth fee model. <code>kp</code> = 0.000300.</p>
<h3 id="slower-growth-tapering-fees-1"><a class="header" href="#slower-growth-tapering-fees-1">Slower growth, tapering fees</a></h3>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000100.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 23. Supply target: 18 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000200.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 24. Supply target: 18 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000300.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 25. Supply target: 18 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000300.</p>
<h3 id="strong-growth-tapering-fees-1"><a class="header" href="#strong-growth-tapering-fees-1">Strong growth, tapering fees</a></h3>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000100.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 26. Supply target: 18 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000200.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 27. Supply target: 18 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000300.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 28. Supply target: 18 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000300.</p>
<h3 id="unstable-fees-high-frequency-1"><a class="header" href="#unstable-fees-high-frequency-1">Unstable fees, high frequency</a></h3>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000100.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 29. Supply target: 18 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000200.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 30. Supply target: 18 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000300.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 31. Supply target: 18 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000300.</p>
<h3 id="unstable-fees-low-frequency-1"><a class="header" href="#unstable-fees-low-frequency-1">Unstable fees, low frequency</a></h3>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000100.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 32. Supply target: 18 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000200.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 33. Supply target: 18 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_18000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000300.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 34. Supply target: 18 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000300.</p>
<h3 id="15-billion-tari-target-supply"><a class="header" href="#15-billion-tari-target-supply">15 billion Tari target supply</a></h3>
<p>All of the following simulations were run with a target supply of 15 billion Tari.</p>
<h3 id="10-annual-fee-growth-low-fee-scenario-2"><a class="header" href="#10-annual-fee-growth-low-fee-scenario-2">10% annual fee growth (low fee scenario)</a></h3>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_10%25%20annual%20fee%20growth_0.000100.svg" alt="10% annual fee growth" /></p>
<p>Figure 35. Supply target: 15 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_10%25%20annual%20fee%20growth_0.000200.svg" alt="10% annual fee growth" /></p>
<p>Figure 36. Supply target: 15 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_10%25%20annual%20fee%20growth_0.000300.svg" alt="10% annual fee growth" /></p>
<p>Figure 37. Supply target: 15 billion XTR. 10% annual fee growth fee model. <code>kp</code> = 0.000300.</p>
<h3 id="10-annual-fee-growth-high-fee-scenario-2"><a class="header" href="#10-annual-fee-growth-high-fee-scenario-2">10% annual fee growth (high fee scenario)</a></h3>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_25%25%20annual%20fee%20growth_0.000100.svg" alt="25% annual fee growth" /></p>
<p>Figure 38. Supply target: 15 billion XTR. 25% annual fee growth fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_25%25%20annual%20fee%20growth_0.000300.svg" alt="25% annual fee growth" /></p>
<p>Figure 39. Supply target: 15 billion XTR. 25% annual fee growth fee model. <code>kp</code> = 0.000300.</p>
<h3 id="slower-growth-tapering-fees-2"><a class="header" href="#slower-growth-tapering-fees-2">Slower growth, tapering fees</a></h3>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000100.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 40. Supply target: 15 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000200.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 41. Supply target: 15 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Slower%20growth%2C%20tapering%20fees_0.000300.svg" alt="Slower growth, tapering fees" /></p>
<p>Figure 42. Supply target: 15 billion XTR. Slower growth, tapering fees fee model. <code>kp</code> = 0.000300.</p>
<h3 id="strong-growth-tapering-fees-2"><a class="header" href="#strong-growth-tapering-fees-2">Strong growth, tapering fees</a></h3>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000100.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 43. Supply target: 15 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000200.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 44. Supply target: 15 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Strong%20growth%2C%20tapering%20fees_0.000300.svg" alt="Strong growth, tapering fees" /></p>
<p>Figure 45. Supply target: 15 billion XTR. Strong growth, tapering fees fee model. <code>kp</code> = 0.000300.</p>
<h3 id="unstable-fees-high-frequency-2"><a class="header" href="#unstable-fees-high-frequency-2">Unstable fees, high frequency</a></h3>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000100.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 46. Supply target: 15 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000200.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 47. Supply target: 15 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Unstable%20fees%2C%20high%20frequency_0.000300.svg" alt="Unstable fees, high frequency" /></p>
<p>Figure 48. Supply target: 15 billion XTR. Unstable fees, high frequency fee model. <code>kp</code> = 0.000300.</p>
<h3 id="unstable-fees-low-frequency-2"><a class="header" href="#unstable-fees-low-frequency-2">Unstable fees, low frequency</a></h3>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000100.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 49. Supply target: 15 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000100.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000200.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 50. Supply target: 15 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000200.</p>
<p><img src="/assets/rfc-323/throttle_15000000000.000000%20T_Unstable%20fees%2C%20low%20frequency_0.000300.svg" alt="Unstable fees, low frequency" /></p>
<p>Figure 51. Supply target: 15 billion XTR. Unstable fees, low frequency fee model. <code>kp</code> = 0.000300.</p>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<h3 id="low-fees-growth"><a class="header" href="#low-fees-growth">Low fees growth</a></h3>
<p>Figures 1-3, 17-19, and 35-37 show the results of the simulations for the 10% annual fee growth scenario. None of
these scenarios produce sufficient fees to reduce the circulating supply to the target within the 33-year simulation
timeframe. The common feature of these simulations is that the controller hits the maximum burn rate of 50% and stays
there for the remainder of the simulation. Increasing the <code>max</code> burn rate to a higher value might succeed in achieving
the target supply, but this might mean that validator nodes cannot operate at break-even rates.</p>
<p>Ultimately a poor growth in fee revenue -- in this model, never exceeding 30 tx/s over 30 years of operation, 
represents a failure mode, not just of the controller, but of the network as a whole, since Tari adoption has never 
taken off, and there's nothing a controller can do to fix that.</p>
<h3 id="high-fees-growth"><a class="header" href="#high-fees-growth">High fees growth</a></h3>
<p>At the other end of the spectrum, if Tari achieves runaway success, <em>and the minimum transaction fee is never 
reduced to compensate</em>, then the controller will be able to maintain the target circulating supply of Tari during the 
33-year simulation timeframe. </p>
<p>This is shown in Figures 4 and 5.
In Figures 20-21, and 38-39, the tapering of supply only begins towards the end of the simulation period.</p>
<p>However, it should be noted that indefinite fee growth is not sustainable from a token supply point of view, <em>unless 
the inflation rate of the emission curve is increased to compensate</em>. This is not evident in these charts, but if 
the simulation were to continue for several more years, the fee growth would eventually set the burn rate to its 
minimum of 5% and the total circulating supply would eventually fall to zero.</p>
<p>So, a few things to note about this scenario:</p>
<ul>
<li>It's very unlikely to happen in practice that 25% network growth is achieved consistently for 30-40 years. 
Therefore, this scenario is largely illustrative of the controller's ability to handle extreme fee growth. And 
within fairly wide limits, we demonstrate that the throttle manages this very well.</li>
<li>The minimum burn rate of 5% could be reduced further without negatively impacting validator node revenues (in fact 
reducing the burn rate is beneficial for validator nodes).</li>
<li>In practice, it is not unreasonable to expect that the price of Tari in nominal USD terms would increase as the 
network usage increases, and so the minimum transaction fee would have to be reduced to maintain sub-penny 
transaction fees -- keeping the Tari network cheap to use for the average user. This entails that the total fee 
revenue would taper off, even as the network continues to grow. The Sigmoidal <a href="RFC-0323_TariThrottle.html#fee-models">fee model</a> is a better 
representation of this eventuality.</li>
</ul>
<h3 id="unstable-fee-revenue"><a class="header" href="#unstable-fee-revenue">Unstable fee revenue</a></h3>
<p>Figures 12-16, 29-34, and 46-51 show the controller's response to various scenarios under which the fee revenue is 
oscillating wildly. Under some scenarios, notably Figures 12 and 13, the target supply cannot be achieved even with the 
controller at minimum burn rates. This is symptomatic of the point made previously that a target supply of 21 
billion offers very little room for the controller to maneuver. </p>
<p>In Figures 14-16, 32-34 and 46-51, the controller is able to maintain the supply target with very 
small amounts of oscillation, by synchronising the fee oscillation with an oscillating burn rate.</p>
<p>While this demonstrates that the throttle is able to achieve its design goals, one must question whether the
wildly oscillating burn rates needed to achieve these goals are healthy for the network. </p>
<p>To maintain a constant 
supply, as the fees increase, the burn rate <em>decreases</em> to try and match the emission (which is roughly constant 
over the oscillation period). From a validator node perspective, the portion of fees paid to them increases as fees 
increase. That sounds great, but when fees decrease, they receive a <em>smaller</em> percentage of the shrinking pool of 
fees, and so they are doubly disadvantaged. Marginal validator nodes will be hit twice as hard, and be forced off 
the network due to unfavourable economics, reducing the overall network capacity. When fees pick up again, 
additional capacity will come online, but the lag between the increased usage and capacity could well lead to a 
degradation in the user experience.</p>
<h3 id="slower-growth-with-tapering-fees"><a class="header" href="#slower-growth-with-tapering-fees">Slower growth with tapering fees</a></h3>
<p>The previous scenarios provide valuable insights into the controller's ability to handle extremes in network demand 
in terms of fee growth patterns. However, these scenarios are not likely to play out in reality, at least not for 
extended multi-decade periods.</p>
<p>The scenarios represented in the &quot;tapering fees&quot; series are more indicative of the long-term macro behaviour of the 
Tari fee growth. The two specific scenarios in this category reflect an initial exponential growth period followed 
by a more sustainable linear fee growth rate, corresponding to reducing the minimum transaction fee over time while the 
network continues to grow.</p>
<p>In the &quot;Slower growth&quot; variant, the fee revenue grows from zero to 1,000,000 XTR per day over 5 years, and then 
increases by 100,000 XTR/d per year after that.</p>
<p>Figures 6-8 are all quite similar. These all use 21 billion XTR as a target and differ only in the weighting applied 
to trying to achieve the target supply, vs. balancing burn rate and emission. </p>
<p>The slow growth rate allows the supply to reach the target value of 21 billion in about 20 years, at which point the 
burn rate adjusts slightly to between 15% and 20% to maintain the target supply.</p>
<p>Figures 23-25 shows what happens with a target supply of 18 billion XTR. Here the target is reached much sooner, 
after around 9 years of mainnet operation. In these simulations, the effect of the controller is more pronounced, 
since an additional 3 billion XTR must be burned to maintain the target supply compared to the scenario with a 21 
billion XTR target.</p>
<p>Figures 40-42 show the scenario with a target supply of 15 billion XTR. The lower target requires several years of 
<code>max</code> burn with the supply overshooting the target before being pulled back onto the target. </p>
<h3 id="strong-growth-with-tapering-fees"><a class="header" href="#strong-growth-with-tapering-fees">Strong growth with tapering fees</a></h3>
<p>The &quot;Strong growth&quot; variant of the tapering fees scenario assumes a much higher adoption rate, with fees growing to 
5,000,000 XTR/d over 3 years, and then growing by 100,000 XTR/d per year after that.</p>
<p>Figures 9-11 show the results of the simulations with a target supply of 21 billion XTR. Here the controller cannot 
meet the target supply since it would require a burn rate of under 5%. This is illustrated by the purple lines not 
moving off the <code>min</code> burn rate level for the entirety of the simulation period.</p>
<p>Figures 26-28 show the results of the simulations with a target supply of 18 billion XTR. Here the controller is 
able to meet the target supply, but only just. The burn rate rises only slightly above the <code>min</code> burn rate level
and is essentially &quot;just holding on&quot;.</p>
<p>Finally, Figures 43-45 tell a similar but slightly more exaggerated version of the story.</p>
<p>In practice, if the strong growth scenario were to play out, several interventions would be necessary to give the 
controller room to maneuver. These would include reducing the <code>min</code> burn rate, and reucing the minimum transaction
fee to maintain sub-penny transaction fees.</p>
<h2 id="conclusions"><a class="header" href="#conclusions">Conclusions</a></h2>
<p>This study shows that the TariThrottle controller is able to maintain a dual mandate of maintaining a target 
circulating supply of Tari as well as a steady net burn rate over a wide range of fee growth scenarios.</p>
<p>Some scenarios are unlikely to play out as described in practice. But they give valuable insights into how the 
controller would respond in stressful situations, short-term shocks and deviations, and offer an indication of the 
robustness of the controller algorithm.</p>
<p>The most common instances of the controller failing to achieve its target was when the fee growth was so low that 
the maximum burn rate was less than the tail emission. </p>
<p>Under these conditions, the tokens that are emitted exceed the maximum that can be burnt. In practice, this 
mode represents a failure of the Tari ecosystem as a whole and a limiting controller would not be the greatest 
concern at this point.</p>
<p>However, the biggest conclusion to draw from this study is that the stated dual mandate is ill-advised.</p>
<p>There are several scenarios where maintaining a target supply is detrimental to the sustainability of 
validator nodes and to the ability of the network to provide surge capacity during sudden high periods of network demand.</p>
<p>The oscillating fee revenue scenarios are particularly illuminating, since they demonstrate that as fees are falling,
the controller <em>increases</em> the burn rate to try and match the emission. This results in a double loss of revenue for
validator nodes, since they're receiving a smaller slice of a shrinking pie. This will force them offline sooner 
than they otherwise would have. When fees recover, it may take some time for those nodes to come back online, and as 
a result, users experience lags in the network.</p>
<p>Many scenarios illustrate that the controller can effectively do nothing for between 5 and 15 years while it waits 
for the circulating supply to reach its target. This effectively means that the controller is powerless to do 
anything to help with validator node profitability or excessive network fees during this period, because its 
control mandate is misaligned with the health of the network.</p>
<p>It's clear that some additional studies are needed. In particular, we need to identify and maximise for the health of 
the network, rather than a fixed supply target. Sometimes these two goals will be aligned, but it behooves us to 
remember which variables represent the tail, and which represent the dog.</p>
<p>As a minimum, the following factors should be considered, since they directly relate to the health of the ecosystem, 
in that they incentivise validation nodes to remain online and keep the Tari network affordable: </p>
<ul>
<li>There must be a <strong>near-constant</strong> driving force to burn Minotari and redeem them as Tari, similar to how a kite 
must always have tension in the string for the operator to be able to fly the kite. Brief periods of slack, 
corresponding to the price of Tari dropping below 1 XTR, are acceptable, since the operator can draw the slack 
in to regain tension (by continuing to burn Tari with no new redemptions), but if the situation persists, the kite 
will crash. </li>
<li>Marginal validator nodes must be able to operate at break-even rates at approximately 50% utilisation. Marginal 
VNs are those that can spin up very quickly to meet surge demand, but are more expensive to run because of this. 
Typically, VNs running on spot EC2 instances fall into this category.</li>
<li>Long-term validator nodes must be able to operate at break-even rates at approximately 20% utilisation. These 
nodes are those that are always online, and are typically running on reserved EC2 instances or even cheaper server 
infrastructure. The 20% value means that they will stay online all the time, whilst keeping 5x surge capacity 
in reserve.</li>
<li>The supply of Minotari never goes to zero.</li>
<li>The minimum transaction fee should be under 1c in USD terms.</li>
</ul>
<p>A controller model that incorporates these target conditions will be the subject of future work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deprecated-rfc"><a class="header" href="#deprecated-rfc">Deprecated RFC</a></h1>
<p>The following documents are either obsolete, or have been superseded by newer RFC documents.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0010codestructure"><a class="header" href="#rfc-0010codestructure">RFC-0010/CodeStructure</a></h1>
<h2 id="tari-code-structure-and-organization"><a class="header" href="#tari-code-structure-and-organization">Tari Code Structure and Organization</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-45"><a class="header" href="#licence-45">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2018 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-48"><a class="header" href="#language-48">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-48"><a class="header" href="#disclaimer-48">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-47"><a class="header" href="#goals-47">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe and explain the Tari codebase layout.</p>
<h2 id="related-requests-for-comment-40"><a class="header" href="#related-requests-for-comment-40">Related Requests for Comment</a></h2>
<p>None.</p>
<h2 id="description-28"><a class="header" href="#description-28">Description</a></h2>
<p>The code follows a Domain-driven Design (<a href="https://en.wikipedia.org/wiki/Domain-driven_design" title="Wikipedia: Domain Driven Design">DDD</a>) layout, with top-level directories falling into infrastructure, domain
and application layers.</p>
<h3 id="infrastructure-layer"><a class="header" href="#infrastructure-layer">Infrastructure Layer</a></h3>
<p>The infrastructure layer provides a set of crates that have general infrastructural utility. The rest of the Tari codebase can make use
of these crates to obtain persistence, communication and cryptographic services. The infrastructure layer doesn't know
anything about blockchains, transactions or digital assets.</p>
<p>We recommend that code in this layer generalizes infrastructure services behind abstraction layers as much as is
reasonable, so that specific implementations can be swapped out with relative ease.</p>
<h3 id="domain-layer"><a class="header" href="#domain-layer">Domain Layer</a></h3>
<p>The domain layer houses the Tari &quot;business logic&quot;. All protocol-related concepts and procedures are defined and
implemented here.</p>
<p>This means that any and all terms defined in the <a href="../Glossary.html" title="Glossary">Glossary</a> will have a software implementation here, and only here.
They can be <em>used</em> in the application layer, but must be <em>implemented</em> in the domain layer.</p>
<p>The domain layer can make use of crates in the infrastructure layer to achieve its goals.</p>
<h3 id="application-layer"><a class="header" href="#application-layer">Application Layer</a></h3>
<p>In the application layer, applications build on top of the domain layer to produce the executable software that is
deployed as part of the Tari network.</p>
<p>As an example, the following base layer applications may be developed as part of the Tari protocol release:</p>
<ul>
<li>A base node executable (tari_base_node)</li>
<li>A Command Line Interface (CLI) wallet for the Tari cryptocurrency (tari_console_wallet)</li>
<li>A standalone miner (tari_miner)</li>
<li>A mining proxy to enable merge mining Monero (tari_merge_mining_proxy)</li>
<li>An Application Programming Interface (API) server for the base node (REST, gRPC, etc.)</li>
</ul>
<h3 id="code-layout"><a class="header" href="#code-layout">Code Layout</a></h3>
<ol>
<li>Tari Protocol</li>
</ol>
<p>Github: <a href="https://github.com/tari-project/tari">tari-project/tari</a></p>
<p>The Tari Protocol code repository is a Rust <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">workspace</a> consisting of multiple packages. A package is a set of <a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">crates</a>, which is the source code of a binary or library.</p>
<p>The source code is organized into the following directories.</p>
<ul>
<li>
<p><code>applications</code> contains crates for all the application-layer executables that form part of the Tari codebase.</p>
<ul>
<li><code>tari_base_node</code> - the Base Node application</li>
<li><code>tari_console_wallet</code> - the CLI Wallet application</li>
<li><code>tari_miner</code> - the SHA3 Miner (CPU)</li>
<li><code>tari_merge_mining_proxy</code> - the Merge Mining Proxy</li>
<li><code>tari_explorer</code> - a local web based block explorer</li>
</ul>
</li>
<li>
<p><code>base_layer</code> is the fundamental domain-layer directory and contains multiple packages and crates.</p>
<ul>
<li><code>core</code> - core classes and traits, such as <a href="../Glossary.html#transaction">Transaction</a>s, <a href="../Glossary.html#block">Block</a>s, and consensus, mempool, and blockchain database code;</li>
<li><code>key_manager</code> - construction and storage of key derivations and mnemonic seed phrases;</li>
<li><code>mmr</code> - an independent implementation of a Merkle Mountain Range;</li>
<li><code>p2p</code> - the block and transaction propagation module;</li>
<li><code>service_framework</code> - asynchronous service stack builder;</li>
<li><code>wallet</code> - a wallet library including services and storage classes to create Tari wallets;</li>
<li><code>wallet_ffi</code> - a <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign Function Interface</a> (FFI) library to create Tari wallets in other programming languages;</li>
</ul>
</li>
<li>
<p><code>comms</code> is the networking and messaging subsystem, used across the base layer and applications;</p>
</li>
<li>
<p><code>infrastructure</code> contains application-layer code and is not Tari-specific. It holds the following crates:</p>
<ul>
<li><code>derive</code> - a crate to contain <code>derive(...)</code> macros;</li>
<li><code>shutdown</code> - a convenient way for threads to let each other know to stop working;</li>
<li><code>storage</code> - data persistence services, including a Lightning Memory-mapped Database (LMDB) persistence implementation;</li>
</ul>
</li>
<li>
<p>other utility and test libraries.</p>
</li>
</ul>
<ol start="2">
<li>Tari Cryptography</li>
</ol>
<p>Github: <a href="https://github.com/tari-project/tari-crypto">tari-project/tari-crypto</a></p>
<p>Tari Crypto was refactored into its own <a href="https://crates.io/crates/tari_crypto">crate</a>, for ease of use and integration across different projects.
It includes all cryptographic services, including a Curve25519 implementation.</p>
<h1 id="change-log-36"><a class="header" href="#change-log-36">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Description</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">21 Dec 2018</td><td style="text-align: left">First draft</td><td style="text-align: left">CjS77</td></tr>
<tr><td style="text-align: left">14 Jan 2022</td><td style="text-align: left">Deprecated in favour of README</td><td style="text-align: left">CjS77</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0121consensus-encoding"><a class="header" href="#rfc-0121consensus-encoding">RFC-0121/Consensus Encoding</a></h1>
<h2 id="consensus-encoding"><a class="header" href="#consensus-encoding">Consensus Encoding</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-46"><a class="header" href="#licence-46">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-49"><a class="header" href="#language-49">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-49"><a class="header" href="#disclaimer-49">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-48"><a class="header" href="#goals-48">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the encoding used for various consensus-critical data types, as well as the construction of hash pre-images and 
signature challenges used in base-layer consensus. </p>
<h2 id="related-requests-for-comment-41"><a class="header" href="#related-requests-for-comment-41">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0120_Consensus.html">RFC-0120: Consensus</a></li>
</ul>
<h2 id="description-29"><a class="header" href="#description-29">Description</a></h2>
<p>A Tari base node must validate each block containing a <a href="RFCD-0121_ConsensusEncoding.html#block-header" title="Block header">block header</a> as well as set of transaction inputs, transaction outputs and transaction kernels,
each containing a number of fields pertinent to their function within the [base layer]. The data contained within these structures needs to be consistently encoded
(represented as bytes) across platforms and implementations so that the network can agree on a single correct state.</p>
<p>This RFC defines the low-level specification for how these data types MUST be encoded to construct a valid hash and signature on the Tari network.</p>
<h3 id="consensus-encoding-1"><a class="header" href="#consensus-encoding-1">Consensus Encoding</a></h3>
<p>The primary goal of consensus encoding is to provide a consistent data format that is committed to in hashes and signatures.</p>
<p>Consensus encoding defines what &quot;raw&quot; data is included in the encoding, the order in which it should appear and the length for variable length elements.
To keep encoding as simple as possible, no type information, field names etc. are catered for in the format as this is always statically known. 
This is particularly appropriate for hashes and signatures where many fields must be consistently represented and concatenated together.</p>
<p>The rest of this section defines some encodings for common primitives used in the Tari codebase.</p>
<h4 id="unsigned-integer-encoding"><a class="header" href="#unsigned-integer-encoding">Unsigned integer encoding</a></h4>
<p>Varint encoding is used for integer fields greater than 1 byte. Describing varint is out of scope for this RFC but there are many resources online
to understand this fairly basic encoding. The only rule we apply is that the encoding has a limit of 10 bytes, a little more than
what is required to store a 64-bit integer.</p>
<h4 id="dynamically-sized-vec-encoding"><a class="header" href="#dynamically-sized-vec-encoding">Dynamically-sized vec encoding</a></h4>
<p>This type refers to a contiguous block of data of any length. Because the size is dynamic, the size is included in the encoding.</p>
<pre><code class="language-text">|len(data)| data for type | data for type | ...
</code></pre>
<h4 id="fixed-size-arrays"><a class="header" href="#fixed-size-arrays">Fixed size arrays</a></h4>
<p>If the size of the array is constant (static). The length is omitted and the data is encoded.</p>
<pre><code class="language-text">| data for type | ...
</code></pre>
<h4 id="optional-or-nullable-encoding"><a class="header" href="#optional-or-nullable-encoding">Optional or nullable encoding</a></h4>
<p>An optional field starts with a 0x00 byte to indicate the value is not provided (<code>None</code>, <code>null</code>, <code>nil</code> etc) or a 0x01 byte 
to indicate that the value is provided followed by the encoding of the value.</p>
<pre><code class="language-text">| 0 or 1 | encoding for type |
</code></pre>
<h4 id="ristretto-keys"><a class="header" href="#ristretto-keys">Ristretto Keys</a></h4>
<p><code>RistrettoPublicKey</code> and <code>RistrettoPrivateKey</code> types defined in the <code>tari_crypto</code> crate both have 32-byte canonical formats
and are encoded as a 32-byte fixed array.</p>
<p>The <a href="https://github.com/tari-project/tari-crypto"><code>tari_crypto</code></a> Rust crate provides an FFI interface that allows
generating of the canonical byte formats in any language that supports FFI.</p>
<h4 id="commitment"><a class="header" href="#commitment">Commitment</a></h4>
<p>A commitment is a <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a> and so has identical encoding.</p>
<h4 id="schnorr-signature"><a class="header" href="#schnorr-signature">Schnorr Signature</a></h4>
<p>See the <a href="https://tlu.tarilabs.com/cryptography/introduction-schnorr-signatures">TLU on Schnorr Signatures</a></p>
<p>A Schnorr signature tuple is <code>&lt;R, s&gt;</code> where <code>R</code> is a <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a> and <code>s</code> is a the signature scalar wrapped in <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPrivateKey</a>.</p>
<p>The encoding is fixed at 64-bytes:</p>
<pre><code class="language-text">| 32-byte public key | 32-byte scalar |
</code></pre>
<h4 id="signature"><a class="header" href="#signature">Signature</a></h4>
<p>A signature tuple consists of a <code>&lt;R, s&gt;</code> where <code>R</code> is the public nonce and <code>s</code> is the signature scalar.</p>
<p>The encoding is fixed at 64-bytes:</p>
<pre><code class="language-text">| 32-byte commitment (R) | 32-byte scalar (s) |
</code></pre>
<h4 id="commitment-signature"><a class="header" href="#commitment-signature">Commitment Signature</a></h4>
<p>A commitment signature tuple consists of a <code>&lt;R, u, v&gt;</code> where <code>R</code> is the <a href="./Glossary.html#commitment">Pederson commitment</a> \(r_u.G + r_v.H\)
for the signature scalars <code>u</code> and <code>v</code>.</p>
<p>The encoding is fixed at 96-bytes:</p>
<pre><code class="language-text">| 32-byte commitment (R) | 32-byte scalar (u) | 32-byte scalar (v) |
</code></pre>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<p>Given the following data and types:</p>
<pre><code class="language-javascript">{
  // Type: Fixed array of 5 bytes
  short_id: [1,2,3,4,5],
  // Type: variable length bytes
  name: Buffer.from(&quot;Case&quot;),
  // Type: unsigned integer
  age: 40,
  // Type: struct
  details: {
      // Type: variable length bytes
      kind: Buffer.from(&quot;Hacker&quot;),
  },
  // Type: nullable varint
  dob: null
}
</code></pre>
<p>Encoded (hex) as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>short id</th><th>len</th><th>name</th><th>age</th><th>len</th><th>kind</th><th>null?</th><th>dob</th></tr></thead><tbody>
<tr><td>0102030405</td><td>04</td><td>43617365</td><td>28</td><td>05</td><td>4861636b6572</td><td>00</td><td></td></tr>
</tbody></table>
</div>
<p>Note that nested structs are flattened and the order must be preserved to allow decoding.
The <code>00</code> null byte is important so that for e.g. the <code>kind</code> bytes cannot be manipulated to 
produce the same encoding as non-null <code>dob</code>.</p>
<h3 id="block-header-1"><a class="header" href="#block-header-1">Block Header</a></h3>
<p>The block hash pre-image is constructed by first constructing the merge mining hash. Each encoding is concatenated in order as follows:</p>
<ol>
<li><code>version</code> - 1 byte</li>
<li><code>height</code> - varint</li>
<li><code>prev_hash</code> - fixed 32-bytes </li>
<li><code>timestamp</code> - varint</li>
<li><code>input_mr</code> - fixed 32-bytes</li>
<li><code>output_mr</code> - fixed 32-bytes</li>
<li><code>output_mmr_size</code> - varint</li>
<li><code>witness_mr</code> - fixed 32-bytes</li>
<li><code>kernel_mr</code> - fixed 32-bytes</li>
<li><code>kernel_mmr_size</code> - `varint</li>
<li><code>total_kernel_offset</code> - 32-byte Scalar, see <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPrivateKey</a></li>
<li><code>total_script_offset</code> - 32-byte Scalar, see <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPrivateKey</a></li>
</ol>
<p>This pre-image is hashed and block hash is constructed, in order, as follows:</p>
<ol>
<li><code>merge_mining_hash</code> - As above</li>
<li><code>pow_algo</code> - enumeration of types of PoW as a single unsigned byte, where <code>Monero = 0x00</code> and <code>Sha3 = 0x01</code></li>
<li><code>pow_data</code> - raw variable bytes (no length varint)</li>
<li><code>nonce</code> - the PoW nonce, <code>u64</code> converted to a fixed 8-byte array (little endian)</li>
</ol>
<h4 id="output-features"><a class="header" href="#output-features">Output Features</a></h4>
<pre><code class="language-rust ignore">pub struct OutputFeatures {
  pub version: OutputFeaturesVersion,
  pub maturity: u64,
  pub flags: OutputFlags,
  pub metadata: Vec&lt;u8&gt;,
  pub unique_id: Option&lt;Vec&lt;u8&gt;&gt;,
  pub parent_public_key: Option&lt;PublicKey&gt;,
  pub asset: Option&lt;AssetOutputFeatures&gt;,
  pub mint_non_fungible: Option&lt;MintNonFungibleFeatures&gt;,
  pub sidechain_checkpoint: Option&lt;SideChainCheckpointFeatures&gt;,
}</code></pre>
<p>Output features consensus encoding is defined as follows (in order):</p>
<ol>
<li><code>version</code> - 1 unsigned byte. This should always be <code>0x00</code> but is reserved for future proofing.</li>
<li><code>maturity</code> - <a href="RFCD-0121_ConsensusEncoding.html#unsigned-integer-encoding">varint</a></li>
<li><code>flags</code> - 1 unsigned byte</li>
<li><code>metadata</code> - <a href="RFCD-0121_ConsensusEncoding.html#dynamically-sized-vec-encoding">dynamic vector</a></li>
<li><code>unique_id</code> - <a href="RFCD-0121_ConsensusEncoding.html#optional-or-nullable-encoding">nullable</a> + <a href="RFCD-0121_ConsensusEncoding.html#dynamically-sized-vec-encoding">dynamic vector</a></li>
<li><code>parent_public_key</code> - <a href="RFCD-0121_ConsensusEncoding.html#optional-or-nullable-encoding">nullable</a> + 32-byte compressed public key </li>
<li><code>asset</code> - <a href="RFCD-0121_ConsensusEncoding.html#optional-or-nullable-encoding">nullable</a> + <a href="RFCD-0121_ConsensusEncoding.html#assetoutputfeatures">AssetOutputFeatures</a></li>
<li><code>mint_non_fungible</code> - <a href="RFCD-0121_ConsensusEncoding.html#optional-or-nullable-encoding">nullable</a> + <a href="RFCD-0121_ConsensusEncoding.html#mintnonfungiblefeatures">MintNonFungibleFeatures</a></li>
<li><code>sidechain_checkpoint</code> - <a href="RFCD-0121_ConsensusEncoding.html#optional-or-nullable-encoding">nullable</a> + <a href="RFCD-0121_ConsensusEncoding.html#sidechaincheckpointfeatures">SideChainCheckpointFeatures</a></li>
</ol>
<h5 id="assetoutputfeatures"><a class="header" href="#assetoutputfeatures">AssetOutputFeatures</a></h5>
<ul>
<li><code>public_key</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a> </li>
<li><code>template_ids</code> - <a href="RFCD-0121_ConsensusEncoding.html#dynamically-sized-vec-encoding">dynamic vector</a> + <a href="RFCD-0121_ConsensusEncoding.html#unsigned-integer-encoding">varint</a></li>
<li><code>template_parameters</code> - <a href="RFCD-0121_ConsensusEncoding.html#dynamically-sized-vec-encoding">dynamic vector</a></li>
</ul>
<h5 id="mintnonfungiblefeatures"><a class="header" href="#mintnonfungiblefeatures">MintNonFungibleFeatures</a></h5>
<ul>
<li><code>asset_public_key</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a> </li>
<li><code>asset_owner_commitment</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a> </li>
</ul>
<h5 id="sidechaincheckpointfeatures"><a class="header" href="#sidechaincheckpointfeatures">SideChainCheckpointFeatures</a></h5>
<ul>
<li><code>merkle_root</code> - <a href="RFCD-0121_ConsensusEncoding.html#fixed-size-arrays">fixed sized array</a></li>
<li><code>committee</code> - <a href="RFCD-0121_ConsensusEncoding.html#dynamically-sized-vec-encoding">dynamic vector</a> + <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
</ul>
<h4 id="transaction-output-1"><a class="header" href="#transaction-output-1">Transaction Output</a></h4>
<pre><code class="language-rust ignore">pub struct TransactionOutput {
    pub version: TransactionInputVersion,
    pub features: OutputFeatures,
    pub commitment: Commitment,
    pub proof: RangeProof,
    pub script: TariScript,
    pub sender_offset_public_key: PublicKey,
    pub metadata_signature: ComSignature,
    pub covenant: Covenant,
}</code></pre>
<p>The canonical output hash is appended to the output Merkle tree and commits to the common data between an output 
and the input spending that output i.e. <code>output_hash = Hash(version | features | commitment | script | covenant)</code>. </p>
<p>The encoding is defined as follows:</p>
<ul>
<li><code>version</code> - 1 byte</li>
<li><code>features</code> - <a href="RFCD-0121_ConsensusEncoding.html#output-features">OutputFeatures</a></li>
<li><code>commitment</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
<li><code>script</code> - byte length as <a href="RFCD-0121_ConsensusEncoding.html#unsigned-integer-encoding">varint</a> + <a href="https://github.com/tari-project/tari-crypto/blob/09cc52787272ced3a1a8c9f2edc1e0221f9d8faa/src/script/op_codes.rs#L101">TariScript</a></li>
<li><code>covenant</code> - byte length as <a href="RFCD-0121_ConsensusEncoding.html#unsigned-integer-encoding">varint</a> + <a href="RFC-0250_Covenants.html">Covenant</a></li>
</ul>
<h5 id="witness-hash"><a class="header" href="#witness-hash">Witness hash</a></h5>
<p>The witness hash is appended to the witness Merkle tree.</p>
<ul>
<li><code>proof</code> - Raw proof bytes encoded using <a href="RFCD-0121_ConsensusEncoding.html#dynamically-sized-vec-encoding">dynamic vector</a> encoding</li>
<li><code>metadata_signature</code> - [CommitmentSignature]</li>
</ul>
<h5 id="metadata-signature-challenge"><a class="header" href="#metadata-signature-challenge">Metadata signature challenge</a></h5>
<p>See <a href="./Glossary.html#metadata-signature">Metadata Signature</a> for details.</p>
<ul>
<li><code>public_commitment_nonce</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
<li><code>script</code> - byte length as <a href="RFCD-0121_ConsensusEncoding.html#unsigned-integer-encoding">varint</a> + <a href="https://github.com/tari-project/tari-crypto/blob/09cc52787272ced3a1a8c9f2edc1e0221f9d8faa/src/script/op_codes.rs#L101">TariScript</a></li>
<li><code>features</code> - <a href="RFCD-0121_ConsensusEncoding.html#output-features">OutputFeatures</a></li>
<li><code>sender_offset_public_key</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
<li><code>commitment</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
<li><code>covenant</code>- byte length as <a href="RFCD-0121_ConsensusEncoding.html#unsigned-integer-encoding">varint</a> + <a href="RFC-0250_Covenants.html">Covenant</a></li>
</ul>
<h3 id="transaction-input-1"><a class="header" href="#transaction-input-1">Transaction Input</a></h3>
<p>The following struct represents the full transaction input data for reference. The actual input struct does not duplicate the output data
to optimise storage and transmission of the input. </p>
<pre><code class="language-rust ignore">pub struct TransactionInput {
  pub version: u8,
  pub input_data: ExecutionStack,
  pub script_signature: ComSignature,
  pub output_version: TransactionOutputVersion,
  pub features: OutputFeatures,
  pub commitment: Commitment,
  pub script: TariScript,
  pub sender_offset_public_key: PublicKey,
  pub covenant: Covenant, 
}</code></pre>
<p>The transaction input canonical hash pre-image is constructed as follows:</p>
<ul>
<li><code>input_version</code> - 1 byte</li>
<li><code>output_hash</code> - See [TransactionOutput]</li>
<li><code>sender_offset_public_key</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
<li><code>input_data</code> - <a href="https://github.com/tari-project/tari-crypto/blob/09cc52787272ced3a1a8c9f2edc1e0221f9d8faa/src/script/stack.rs#L51">TariScript Stack</a></li>
<li><code>script_signature</code> - [CommitmentSignature]</li>
</ul>
<h3 id="transaction-kernel"><a class="header" href="#transaction-kernel">Transaction Kernel</a></h3>
<p>The following struct represents the full transaction input data for reference. The actual input struct does not duplicate the output data
to optimise storage and transmission of the input.</p>
<pre><code class="language-rust ignore">pub struct TransactionKernel {
    pub version: TransactionKernelVersion,
    pub features: KernelFeatures,
    pub fee: MicroTari,
    pub lock_height: u64,
    pub excess: Commitment,
    pub excess_sig: Signature,
}</code></pre>
<p>The transaction kernel is encoded as follows:</p>
<ul>
<li><code>input_version</code> - 1 byte</li>
<li><code>features</code> - <a href="RFCD-0121_ConsensusEncoding.html#output-features">OutputFeatures</a></li>
<li><code>fee</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
<li><code>lock_height</code> - <a href="https://github.com/tari-project/tari-crypto/blob/09cc52787272ced3a1a8c9f2edc1e0221f9d8faa/src/script/stack.rs#L51">TariScript Stack</a></li>
<li><code>excess</code> - <a href="RFCD-0121_ConsensusEncoding.html#commitment">Commitment</a></li>
<li><code>excess_sig</code> - [Signature]</li>
</ul>
<p>The canonical hash pre-image is constructed from this encoding.</p>
<h4 id="script-challenge"><a class="header" href="#script-challenge">Script Challenge</a></h4>
<p>For details see <a href="./RFC-0201_TariScript.html">RFC-0201_TariScript.md</a>.</p>
<p>The script challenge is constructed as follows:</p>
<ul>
<li><code>nonce_commitment</code> - <a href="RFCD-0121_ConsensusEncoding.html#commitment">Commitment</a></li>
<li><code>script</code> - <a href="https://github.com/tari-project/tari-crypto/blob/09cc52787272ced3a1a8c9f2edc1e0221f9d8faa/src/script/op_codes.rs#L101">TariScript</a></li>
<li><code>input_data</code> - <a href="https://github.com/tari-project/tari-crypto/blob/09cc52787272ced3a1a8c9f2edc1e0221f9d8faa/src/script/stack.rs#L51">TariScript Stack</a></li>
<li><code>script_public_key</code> - <a href="RFCD-0121_ConsensusEncoding.html#ristretto-keys">RistrettoPublicKey</a></li>
<li><code>commitment</code> - <a href="RFCD-0121_ConsensusEncoding.html#commitment">Commitment</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0130mining"><a class="header" href="#rfc-0130mining">RFC-0130/Mining</a></h1>
<h2 id="full-node-mining-on-tari-base-layer-1"><a class="header" href="#full-node-mining-on-tari-base-layer-1">Full-node Mining on Tari Base Layer</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-47"><a class="header" href="#licence-47">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2018 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-50"><a class="header" href="#language-50">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-50"><a class="header" href="#disclaimer-50">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-49"><a class="header" href="#goals-49">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to provide a brief overview of the Tari merged mining process and introduce 
the primary functionality required of the Mining Server and Mining Worker.</p>
<h2 id="related-requests-for-comment-42"><a class="header" href="#related-requests-for-comment-42">Related Requests for Comment</a></h2>
<ul>
<li><a href="./RFC-0111_BaseNodeArchitecture.html">RFC-0111: Base Node Architecture</a></li>
<li><a href="RFC-0110_BaseNodes.html">RFC-0110: Base Nodes</a></li>
</ul>
<h2 id="description-30"><a class="header" href="#description-30">Description</a></h2>
<h3 id="assumptions-4"><a class="header" href="#assumptions-4">Assumptions</a></h3>
<ul>
<li>The Tari <a href="Glossary.html#blockchain">blockchain</a> will be merged mined with Monero.</li>
<li>The Tari <a href="Glossary.html#base-layer">Base Layer</a> has a network of <a href="Glossary.html#base-node">Base Node</a>s that verify and propagate valid <a href="Glossary.html#transaction">transaction</a>s and <a href="Glossary.html#block">block</a>s. </li>
</ul>
<h3 id="abstract-3"><a class="header" href="#abstract-3">Abstract</a></h3>
<p>The process of merged mining Tari with Monero on the Tari Base Layer is performed by <a href="Glossary.html#mining-server">Mining Server</a>s and <a href="Glossary.html#mining-worker">Mining 
Worker</a>s. Mining Servers are responsible for constructing new blocks by bundling transactions from the <a href="Glossary.html#mempool">mempool</a> 
of a connected Base Node. They then distribute Proof-of-Work (PoW) tasks to Mining Workers in an attempt to solve 
newly created blocks. Solved solutions and shares are sent by the Mining Workers to the Mining Server, which in turn 
verifies the solution and distributes the newly created blocks to the Base Node and Monero Node for inclusion in 
their respective blockchains.</p>
<h3 id="merged-mining-on-tari-base-layer"><a class="header" href="#merged-mining-on-tari-base-layer">Merged Mining on Tari Base Layer</a></h3>
<p>This document is divided into three parts:</p>
<ul>
<li>A brief overview of the merged mining process and the interactions between the Base Node, Mining 
Server and Mining Worker.</li>
<li>The primary functionality required of the Mining Server.</li>
<li>The primary functionality required of the Mining Worker.</li>
</ul>
<h4 id="overview-of-tari-merged-mining-process-using-mining-servers-and-mining-workers"><a class="header" href="#overview-of-tari-merged-mining-process-using-mining-servers-and-mining-workers">Overview of Tari Merged Mining Process using Mining Servers and Mining Workers</a></h4>
<p>Mining on the Tari Base Layer consists of three primary entities: the Base Nodes, Mining Servers and Mining Workers. 
A description of the Base Node is provided in <a href="https://tari-project.github.io/tari/RFC-0110_BaseNodes.html">RFC-0110/Base Nodes</a>.
A Mining Server is connected locally or remotely to a Tari Base Node and a Monero Node, and is responsible for 
constructing Tari and Monero Blocks from their respective mempools. The Mining Server should retrieve transactions 
from the mempool of the connected Base Node and assemble a new Tari block by bundling transactions together.</p>
<p>Mining servers may re-verify transactions before including them in a new Tari block, but this enforcement of 
verification and transaction rules such as signatures and timelocks is the responsibility of the connected Base Node. 
Mining Servers are responsible for <a href="Glossary.html#cut-through">cut-through</a>, as this is required for scalability and privacy.</p>
<p>To enable merged mining of Tari with Monero, both a Tari and a Monero block need to be created and linked. First, 
a new Tari block is created and then the block header hash of the new Tari block is included in the coinbase 
transaction of the new Monero block. Once a new merged mined Monero block has been constructed, PoW tasks can 
be sent to the connected Mining Workers, which will attempt to solve the block by performing the latest released 
version of the PoW algorithm selected by Monero.</p>
<p>Assuming the Tari difficulty is less than the Monero difficulty, miners get rewarded for solving the PoW at any 
difficulty above the Tari difficulty. If the block is solved above the Tari difficulty, a new Tari block is mined. 
If the difficulty is also greater than the Monero difficulty, a new Monero block is mined as well. In either event, 
the header for the candidate Monero block is included in the Tari block header.</p>
<p>If the PoW solution was sufficient to meet the difficult level of both the Tari and Monero blockchains, then the 
individual blocks for each blockchain can be sent from the Mining Server to the Base Node and Monero Node to be 
added to the respective blockchains.</p>
<p>Every Tari block must include the solved Monero block's information (block header hash, Merkle tree branch and 
hash of the coinbase transaction) in the PoW summary section of the Tari block header. 
If the PoW solution found by the Mining Workers only solved the problem at the Tari difficulty, the Monero block can be discarded. </p>
<p>This process will ensure that the Tari difficulty remains independent. Adjusting the difficulty will ensure that 
the Tari block times are preserved. Also, the Tari block time can be less than, equal to or greater than the Monero block 
times. A more detailed description of the merged mining process between a Primary and Auxiliary blockchain is provided 
in the <a href="https://tlu.tarilabs.com/merged-mining/merged-mining.html">Merged Mining TLU report</a>.</p>
<h4 id="functionality-required-by-tari-mining-server"><a class="header" href="#functionality-required-by-tari-mining-server">Functionality Required by Tari Mining Server</a></h4>
<ul>
<li>The Tari blockchain MUST have the ability to be merged mined with Monero. </li>
<li>The Tari Mining Server:
<ul>
<li>MUST maintain a local or remote connection with a Base Node and a Monero Node.</li>
<li>MUST have a mechanism to construct a new Tari and Monero block by selecting transactions from the different 
Tari and Monero mempools that need to be included in the different blocks.</li>
<li>MUST apply <a href="Glossary.html#cut-through">cut-through</a> when mining Tari transactions from the <a href="Glossary.html#mempool">mempool</a> and only add the excess to the list of new Tari block transactions. </li>
<li>MAY have a configurable transaction selection mechanism for the block construction process. </li>
<li>MAY have the ability to re-verify transactions before including them in a new Tari block.</li>
<li>MUST have the ability to include the block header hash of the new Tari block in the coinbase section of a 
newly created Monero block to enable merged mining.</li>
<li>MUST be able to include the Monero block header hash, Merkle tree branch and hash of the coinbase transaction 
of the Monero block into the PoW summary field of the new Tari block header. </li>
<li>MUST have the ability to transmit and distribute PoW tasks for the newly created Monero block, which contains 
the Tari block information, to connected Mining Workers.</li>
<li>MUST verify PoW solutions received from Mining Workers and MUST reject and discard invalid solutions or 
solutions that do not meet the minimum required difficulty.</li>
<li>MAY keep track of mining share contributions of the connected Mining Workers. </li>
<li>MUST submit completed Tari blocks to the Tari Base Node.</li>
<li>MUST submit completed Monero blocks to the Monero Network.</li>
</ul>
</li>
</ul>
<h4 id="functionality-required-by-tari-mining-worker"><a class="header" href="#functionality-required-by-tari-mining-worker">Functionality Required by Tari Mining Worker</a></h4>
<p>The Tari Mining Worker:</p>
<ul>
<li>MUST maintain a local or remote connection to a Mining Server.</li>
<li>MUST have the ability to receive PoW tasks from the connected Mining Server. </li>
<li>MUST have the ability to perform the latest released version of Monero's PoW algorithm on the received PoW tasks.</li>
<li>MUST attempt to solve the PoW task at the difficulty specified by the Mining Server. </li>
<li>MUST submit completed shares to the connected Mining Server. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0152emojiid"><a class="header" href="#rfc-0152emojiid">RFC-0152/EmojiId</a></h1>
<h2 id="emoji-id-specification"><a class="header" href="#emoji-id-specification">Emoji Id specification</a></h2>
<p><img src="theme/images/status-stable.svg" alt="status: stable" /></p>
<p><strong>Maintainer(s)</strong>:<a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-48"><a class="header" href="#licence-48">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022. The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-51"><a class="header" href="#language-51">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-51"><a class="header" href="#disclaimer-51">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-50"><a class="header" href="#goals-50">Goals</a></h2>
<p>This document describes the specification for Emoji Ids. Emoji Ids are encoded node ids used for humans to verify peer node addresses easily
and for machines to verify that the address is being used in the correct context.</p>
<h2 id="related-requests-for-comment-43"><a class="header" href="#related-requests-for-comment-43">Related Requests for Comment</a></h2>
<p>None</p>
<h2 id="description-31"><a class="header" href="#description-31">Description</a></h2>
<p>Tari <a href="Glossary.html#communication-node">Communication Node</a>s are identified on the network via their <a href="Glossary.html#node-id">Node ID</a>; which in turn are derived from the node's
public key. Both the node id and public key are simple large integer numbers.</p>
<p>The most common practice for human beings to copy large numbers in cryptocurrency software is scanning a QR code or copying and pasting a value from one application to another. These numbers are typically encoded using hexadecimal or Base58
encoding. The user will then typically scan (parts) of the string by eye to ensure that the value was transferred
correctly.</p>
<p>For Tari, we propose encoding values, the node ID in particular and masking the network identifier, for Tari, using emojis. The advantages of this approach are:</p>
<ul>
<li>Emoji are more easily identifiable; and, if selected carefully, less prone to identification errors (e.g., mistaking an
O for a 0).</li>
<li>The alphabet can be considerably larger than hexadecimal (16) or Base58 (58), resulting in shorter character sequences
in the encoding.</li>
<li>Should be be able to detect if the address used belongs to the correct network. </li>
</ul>
<h2 id="the-specification-1"><a class="header" href="#the-specification-1">The specification</a></h2>
<h3 id="emoji-map"><a class="header" href="#emoji-map">Emoji map</a></h3>
<p>An emoji alphabet of 256 characters is selected. Each emoji is assigned a unique index from 0 to 255 inclusive. The
list of selected emojis is:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>🦋</td><td>📟</td><td>🌈</td><td>🌊</td><td>🎯</td><td>🐋</td><td>🌙</td><td>🤔</td><td>🌕</td><td>⭐</td><td>🎋</td><td>🌰</td><td>🌴</td><td>🌵</td><td>🌲</td><td>🌸</td></tr>
<tr><td>🌹</td><td>🌻</td><td>🌽</td><td>🍀</td><td>🍁</td><td>🍄</td><td>🥑</td><td>🍆</td><td>🍇</td><td>🍈</td><td>🍉</td><td>🍊</td><td>🍋</td><td>🍌</td><td>🍍</td><td>🍎</td></tr>
<tr><td>🍐</td><td>🍑</td><td>🍒</td><td>🍓</td><td>🍔</td><td>🍕</td><td>🍗</td><td>🍚</td><td>🍞</td><td>🍟</td><td>🥝</td><td>🍣</td><td>🍦</td><td>🍩</td><td>🍪</td><td>🍫</td></tr>
<tr><td>🍬</td><td>🍭</td><td>🍯</td><td>🥐</td><td>🍳</td><td>🥄</td><td>🍵</td><td>🍶</td><td>🍷</td><td>🍸</td><td>🍾</td><td>🍺</td><td>🍼</td><td>🎀</td><td>🎁</td><td>🎂</td></tr>
<tr><td>🎃</td><td>🤖</td><td>🎈</td><td>🎉</td><td>🎒</td><td>🎓</td><td>🎠</td><td>🎡</td><td>🎢</td><td>🎣</td><td>🎤</td><td>🎥</td><td>🎧</td><td>🎨</td><td>🎩</td><td>🎪</td></tr>
<tr><td>🎬</td><td>🎭</td><td>🎮</td><td>🎰</td><td>🎱</td><td>🎲</td><td>🎳</td><td>🎵</td><td>🎷</td><td>🎸</td><td>🎹</td><td>🎺</td><td>🎻</td><td>🎼</td><td>🎽</td><td>🎾</td></tr>
<tr><td>🎿</td><td>🏀</td><td>🏁</td><td>🏆</td><td>🏈</td><td>⚽</td><td>🏠</td><td>🏥</td><td>🏦</td><td>🏭</td><td>🏰</td><td>🐀</td><td>🐉</td><td>🐊</td><td>🐌</td><td>🐍</td></tr>
<tr><td>🦁</td><td>🐐</td><td>🐑</td><td>🐔</td><td>🙈</td><td>🐗</td><td>🐘</td><td>🐙</td><td>🐚</td><td>🐛</td><td>🐜</td><td>🐝</td><td>🐞</td><td>🐢</td><td>🐣</td><td>🐨</td></tr>
<tr><td>🦀</td><td>🐪</td><td>🐬</td><td>🐭</td><td>🐮</td><td>🐯</td><td>🐰</td><td>🦆</td><td>🦂</td><td>🐴</td><td>🐵</td><td>🐶</td><td>🐷</td><td>🐸</td><td>🐺</td><td>🐻</td></tr>
<tr><td>🐼</td><td>🐽</td><td>🐾</td><td>👀</td><td>👅</td><td>👑</td><td>👒</td><td>🧢</td><td>💅</td><td>👕</td><td>👖</td><td>👗</td><td>👘</td><td>👙</td><td>💃</td><td>👛</td></tr>
<tr><td>👞</td><td>👟</td><td>👠</td><td>🥊</td><td>👢</td><td>👣</td><td>🤡</td><td>👻</td><td>👽</td><td>👾</td><td>🤠</td><td>👃</td><td>💄</td><td>💈</td><td>💉</td><td>💊</td></tr>
<tr><td>💋</td><td>👂</td><td>💍</td><td>💎</td><td>💐</td><td>💔</td><td>🔒</td><td>🧩</td><td>💡</td><td>💣</td><td>💤</td><td>💦</td><td>💨</td><td>💩</td><td>➕</td><td>💯</td></tr>
<tr><td>💰</td><td>💳</td><td>💵</td><td>💺</td><td>💻</td><td>💼</td><td>📈</td><td>📜</td><td>📌</td><td>📎</td><td>📖</td><td>📿</td><td>📡</td><td>⏰</td><td>📱</td><td>📷</td></tr>
<tr><td>🔋</td><td>🔌</td><td>🚰</td><td>🔑</td><td>🔔</td><td>🔥</td><td>🔦</td><td>🔧</td><td>🔨</td><td>🔩</td><td>🔪</td><td>🔫</td><td>🔬</td><td>🔭</td><td>🔮</td><td>🔱</td></tr>
<tr><td>🗽</td><td>😂</td><td>😇</td><td>😈</td><td>🤑</td><td>😍</td><td>😎</td><td>😱</td><td>😷</td><td>🤢</td><td>👍</td><td>👶</td><td>🚀</td><td>🚁</td><td>🚂</td><td>🚚</td></tr>
<tr><td>🚑</td><td>🚒</td><td>🚓</td><td>🛵</td><td>🚗</td><td>🚜</td><td>🚢</td><td>🚦</td><td>🚧</td><td>🚨</td><td>🚪</td><td>🚫</td><td>🚲</td><td>🚽</td><td>🚿</td><td>🧲</td></tr>
</tbody></table>
</div>
<p>The emoji have been selected such that:</p>
<ul>
<li>Similar-looking emoji are excluded from the map. For example, neither 😁 or 😄 should be included. Similarly, the Irish and
Côte d'Ivoire flags look very similar, and both should be excluded.</li>
<li>Modified emoji (skin tones, gender modifiers) are excluded. Only the &quot;base&quot; emoji are considered.</li>
</ul>
<p>The selection of an alphabet with 256 symbols means there is a direct mapping between bytes and emoji.</p>
<h3 id="encoding-1"><a class="header" href="#encoding-1">Encoding</a></h3>
<p>The emoji ID is calculated from a node public key <code>B</code> (serialized as 32 bytes) and a network identifier <code>N</code> (serialized as 8 bits) as follows:</p>
<ul>
<li>Use the <a href="https://github.com/cypherstack/dammsum">DammSum</a> algorithm with <code>k = 8</code> and <code>m = 32</code> to compute an 8-bit checksum <code>C</code> using <code>B</code> as input.</li>
<li>Compute the masked checksum <code>C' = C XOR N</code>.</li>
<li>Encode <code>B</code> into an emoji string using the emoji map.</li>
<li>Encode <code>C'</code> into an emoji character using the emoji map.</li>
<li>Concatenate <code>B</code> and <code>C'</code> as the emoji ID.</li>
</ul>
<p>The result is 33 emoji characters.</p>
<h3 id="decoding"><a class="header" href="#decoding">Decoding</a></h3>
<p>The node public key is obtained from an emoji ID and a network identifier <code>N</code> (serialized to 8 bits) as follows:</p>
<ul>
<li>Assert that the emoji ID contains exactly 33 valid emoji characters from the emoji alphabet. If not, return an error.</li>
<li>Decode the emoji ID as an emoji string by mapping each emoji character to a byte value using the emoji map, producing
33 bytes. Let <code>B</code> be the first 32 bytes and <code>C'</code> be the last byte.</li>
<li>Compute the unmasked checksum <code>C = C' XOR N</code>.</li>
<li>Use the DammSum validation algorithm on <code>B</code> to assert that <code>C</code> is the correct checksum. If not, return an error.</li>
<li>Attempt to deserialize <code>B</code> as a public key. If this fails, return an error. If it succeeds, return the public key.</li>
</ul>
<h4 id="checksum-effectiveness"><a class="header" href="#checksum-effectiveness">Checksum effectiveness</a></h4>
<p>It is important to note that masking the checksum reduces its effectiveness.
Namely, if an emoji ID is presented with a different network identifier, and if there is a transmission error, it is possible for the result to decode in a seemingly valid way with a valid checksum after unmasking.
If both conditions occur randomly, the likelihood of this occurring is <code>n / 256</code> for <code>n</code> possible network identifiers.</p>
<p>Since emoji ID will typically be copied digitally and therefore not particularly subject to transmission errors, so it seems unlikely for these conditions to coincide in practice.</p>
<h2 id="change-log-37"><a class="header" href="#change-log-37">Change Log</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">2022-11-10</td><td style="text-align: left">Initial stable</td><td style="text-align: left">SWvHeerden</td></tr>
<tr><td style="text-align: left">2022-11-11</td><td style="text-align: left">Algorithm improvements</td><td style="text-align: left">AaronFeickert</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0180-bulletproof-range-proof-rewinding"><a class="header" href="#rfc-0180-bulletproof-range-proof-rewinding">RFC-0180: Bulletproof range proof rewinding</a></h1>
<h2 id="bulletproof-range-proof-rewinding"><a class="header" href="#bulletproof-range-proof-rewinding">Bulletproof range proof rewinding</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/hansieodendaal">Hansie Odendaal</a></p>
<h1 id="licence-49"><a class="header" href="#licence-49">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2020 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-52"><a class="header" href="#language-52">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT
RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h2 id="disclaimer-52"><a class="header" href="#disclaimer-52">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-51"><a class="header" href="#goals-51">Goals</a></h2>
<p>This Request for Comment (RFC) presents a proposal for Bulletproof range proof rewinding in the Tari blockchain to 
enable advanced usages like wallet recovery and one‑sided payments.</p>
<h2 id="related-requests-for-comment-44"><a class="header" href="#related-requests-for-comment-44">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0150_Wallets.html">RFC-0150: Wallets</a></li>
</ul>
<h2 id="introduction-11"><a class="header" href="#introduction-11">Introduction</a></h2>
<p>We use <code>dalek-cryptography/bulletproofs</code> in the Tari project and have a need to do wallet recovery from seed values and 
also to recover the value in the value commitment from the Unspent Transaction Output (UTXO). Pull requests 
<a href="https://github.com/dalek-cryptography/bulletproofs/pull/340">PR#340</a> for the <code>dalek-cryptography/bulletproofs</code> crate 
and <a href="https://github.com/zkcrypto/bulletproofs/pull/6">PR#6</a> for the <code>zkcrypto/bulletproofs</code> crate were submitted to add 
Bulletproofs rewinding functionality to the Bulletproofs crate as a user option.</p>
<p>The methodology presented here is closely modelled on Grin's solution 
<a href="https://github.com/mimblewimble/grin-wallet/issues/105">as discussed here</a>, but using two private keys instead of one.</p>
<h2 id="rewind-scheme"><a class="header" href="#rewind-scheme">Rewind Scheme</a></h2>
<p>Bulletproofs per say are not be discussed in this RFC, only how the rewinding scheme works. Readers who require 
background information on Bulletproofs can read the excellent documentation created by the Dalek team 
<a href="https://doc-internal.dalek.rs/bulletproofs/index.html">here</a>. Important to note is that Dalek only implemented 
the aggregated Multiparty Computation Protocol (MCP) for range proofs and that proving a single range proof is handled a 
special case.</p>
<h3 id="constructing-a-rewindable-bulletproof-range-proof"><a class="header" href="#constructing-a-rewindable-bulletproof-range-proof">Constructing a rewindable Bulletproof range proof</a></h3>
<p>Our scheme is discussed with reference to the 
<a href="https://doc-internal.dalek.rs/bulletproofs/range_proof/index.html#party-and-dealers-algorithm">Party and Dealer's algorithm</a>
and using notation defined <a href="https://doc-internal.dalek.rs/bulletproofs/notes/index.html#notation">here</a>.</p>
<p>In this scheme three additional parameters are introduced when creating a range proof for a Pedersen commitment 
(termed <em>value commitment</em> by Dalek because it is a commitment to the value of the token):</p>
<ul>
<li>Private rewind key:   $ r_{key} $</li>
<li>Private blinding key:   $ b_{key} $</li>
<li>Twenty three (23) bytes proof message:   $ p_{msg} $.</li>
</ul>
<p>The 23 bytes worth of proof message can be any message a user wants to embed within the proof. Internally the two 
private keys, in combination with the value commitment, are converted into two rewind nonces and two blinding nonces:</p>
<ul>
<li>Rewind nonce 1:   $ r_{n1} = \text{H}( \ \text{H}(r_{key} \cdot \widetilde{B}) \ || \ V_{(j)} \ ) $</li>
<li>Rewind nonce 2:   $ r_{n2} = \text{H}( \ \text{H}(b_{key} \cdot \widetilde{B}) \ || \ V_{(j)} \ ) $</li>
<li>Blinding nonce 1:   $ b_{n1} = \text{H}( \ \text{H}(r_{key}) \ || \ V_{(j)} \ ) $</li>
<li>Blinding nonce 2:   $ b_{n2} = \text{H}( \ \text{H}(b_{key}) \ || \ V_{(j)} \ ) $</li>
</ul>
<p>These four values are seen as nonces due to the fact that each value commitment is unique, whereas the $ r_{key} $ 
and $ b_{key} $ can be used over and over without leaking any information. </p>
<p>The value $ v_{(j)} $ is an 8 byte word, and $ p_{msg} $ is a 23 byte word. The bytes of these two words can be 
concatenated to form a 32 byte word and when XORed with $ r_{n2} $ ,  it can be used to embed the value and proof message. $ r_{n2} $ is modified as follows:</p>
<p>$$
\begin{aligned}
r^\backprime_{n2}  = r_{n2} \ \mathbin{\oplus} \ (v_{(j)_{\ bytes \ 1..8}}  \ || \ p_{msg_{\ bytes \ 9..31}} )
\end{aligned}
\tag{1}
$$</p>
<p>Consider the start of the protocol where each party $ j $ computes three commitments: to the value $ v_{(j)} $, to the 
bits of that value $ \mathbf{a}_{L, (j)}, \mathbf{a}_{R, (j)} $, and to the per-bit blinding factors 
$ \mathbf{s}_{L, (j)}, \mathbf{s}_{R, (j)} $:</p>
<p>$$
\begin{aligned}
V_{(j)} &amp;\gets \operatorname{Com}(v_{(j)}, {\widetilde{v}_{(j)}})               &amp;&amp; = v_{(j)} \cdot B + {\widetilde{v}_{(j)}} \cdot {\widetilde{B}} \\
A_{(j)} &amp;\gets \operatorname{Com}({\mathbf{a}}_{L, (j)}, {\mathbf{a}}_{R, (j)}) &amp;&amp; = {\langle {\mathbf{a}}_{L, (j)}, {\mathbf{G}_{(j)}} \rangle} + {\langle {\mathbf{a}}_{R, (j)}, {\mathbf{H}_{(j)}} \rangle} + {\widetilde{a}_{(j)}} {\widetilde{B}} \\
S_{(j)} &amp;\gets \operatorname{Com}({\mathbf{s}}_{L, (j)}, {\mathbf{s}}_{R, (j)}) &amp;&amp; = {\langle {\mathbf{s}}_{L, (j)}, {\mathbf{G}_{(j)}} \rangle} + {\langle {\mathbf{s}}_{R, (j)}, {\mathbf{H}_{(j)}} \rangle} + {\widetilde{s}_{(j)}} {\widetilde{B}} \\
\end{aligned}
\tag{2}
$$</p>
<p>where $ \widetilde{v}_{(j)}, \widetilde{a}_{(j)}, \widetilde{s}_{(j)} $ are sampled randomly from $ {\mathbb Z_p} $. 
(Note that $ \widetilde{v}_{(j)} $ is the blinding factor of the value commitment.)</p>
<p>In our scheme:</p>
<ul>
<li>blinding factor $ {\widetilde{a}_{(j)}} $ is replaced by $ r_{n1} $</li>
<li>blinding factor $ {\widetilde{s}_{(j)}} $ is replaced by $ r^\backprime_{n2} $</li>
</ul>
<p>Consider where the party commits to the terms $ t_{1, (j)}, t_{2, (j)} $:</p>
<p>$$
\begin{aligned}
T_{1, (j)} &amp;\gets \operatorname{Com}(t_{1, (j)}, {\tilde{t}_{(j1}})  &amp;&amp; = t_{1, (j)} \cdot B + {\tilde{t}_{1, (j)}} \cdot {\widetilde{B}} \\
T_{2, (j)} &amp;\gets \operatorname{Com}(t_{2, (j)}, {\tilde{t}_{2, (j)}})  &amp;&amp; = t_{2, (j)} \cdot B + {\tilde{t}_{2, (j)}} \cdot {\widetilde{B}}
\end{aligned}
\tag{3}
$$</p>
<p>where $ \tilde{t}_{1, (j)}, \tilde{t}_{2, (j)} $ are sampled randomly from $ {\mathbb Z_p} $.</p>
<p>In our scheme:</p>
<ol>
<li>blinding factor $ \tilde{t}_{1, (j)} $ is replaced by $ b_{n1} $</li>
<li>blinding factor $ \tilde{t}_{2, (j)} $ is replaced by $ b_{n2} $</li>
</ol>
<p>The synthetic blinding factors calculation below is key, as it will be used to extract the data when playing the 
Bulletproof in reverse:</p>
<p>$$
\begin{aligned}
{\tilde{t}}_{(j)}(x) &amp;\gets z^{2} {\tilde{v}}_{(j)} + x {\tilde{t}}_{1, (j)} + x^{2} {\tilde{t}}_{2, (j)} \\
\end{aligned}
\tag{4}
$$</p>
<p>$$
\begin{aligned}
\tilde{e}_{(j)}     &amp;\gets {\widetilde{a}}_{(j)}   + x {\widetilde{s}}_{(j)}
\end{aligned}
\tag{5}
$$</p>
<p>In the end, the complete range proof consists of these elements:</p>
<p>$$
\begin{aligned}
\lbrace A, S, T_1, T_2, t(x), {\tilde{t}}(x), \tilde{e}, L_k, R_k, \dots, L_1, R_1, a, b \rbrace 
\end{aligned}
\tag{6}
$$</p>
<p><strong>Note:</strong> This scheme has been improved in what has been presented in by 
<a href="https://github.com/mimblewimble/grin-wallet/issues/105">Grin</a> after being commented on by Dalek, by not using the same 
rewind nonce for $ {\widetilde{a}_{(j)}} $ and $ {\widetilde{s}_{(j)}} $ nor the same blinding nonce for 
$ \tilde{t}_{1, (j)} $ and $ \tilde{t}_{2, (j)} $.</p>
<h3 id="extracting-data"><a class="header" href="#extracting-data">Extracting data</a></h3>
<p>Note the presence of $ {\tilde{t}}_{(j)} $ and $ \tilde{e} $ in (6). The Dalek Bulletproofs are constructed using 
<a href="https://doc-internal.dalek.rs/merlin/index.html">Merlin Transcripts</a> to automate the Fiat-Shamir transform, so that 
non-interactive protocols can be implemented as if they were interactive. The prover adds each step of the Bulletproof 
range proof creation to the protocol transcript, so the verifier has to do the same.</p>
<p>The extraction procress starts by adding the values $ A $ and $ S $ are to the protocol transcript to obtain challenge 
scalars $ z $ and $ x $ from the transcript.</p>
<p>There after, $ {\widetilde{s}_{(j)}} $ is extracted from (5) by replacing $ {\widetilde{a}_{(j)}} $ with $ r_{n1} $  :</p>
<p>$$
\begin{aligned}
{\widetilde{s}}_{(j)} = ( \tilde{e}_{(j)} - r_{n1} ) \cdot \frac{1}x 
\end{aligned}
\tag{7}
$$</p>
<p>Next, the value and proof message are extracted from $ {\widetilde{s}_{(j)}} $ when XORed with $ r_{n2} $ :</p>
<p>$$
\begin{aligned}
v_{(j)} &amp;= ( r_{n2} \ \mathbin{\oplus} \ {\widetilde{s}}_{(j)} ) | _{\ bytes \ 1..8} \\
p_{msg} &amp;= ( r_{n2} \ \mathbin{\oplus} \ {\widetilde{s}}_{(j)} ) | _{\ bytes \ 9..31} 
\end{aligned}
\tag{8}
$$</p>
<p>Finally, the blinding factor is extracted from (4):</p>
<p>$$
\begin{aligned}
\widetilde{v} = \frac{1}{z^2} \cdot ( {\tilde{t}}(x) - x \cdot \tilde{t}_{1, (j)} - x^2 \cdot \tilde{t}_{2, (j)} )
\end{aligned}
\tag{9}
$$</p>
<h2 id="some-notes-on-usage-and-use-cases"><a class="header" href="#some-notes-on-usage-and-use-cases">Some notes on usage and use cases</a></h2>
<p>Rewinding a Bulletproof can take place according to one or both of these steps:</p>
<ul>
<li><strong>Peak value only:</strong> Using this step returns the value and proof message only, but <em>returning garbage data if 
the wrong rewind nonces are provided</em>, or,</li>
<li><strong>Rewind fully:</strong> Using this step returns the value, blinding factor and proof message, <em>returning an error if 
the wrong rewind and blinding nonces are provided</em>. Note that this step is independent from peaking the value only, 
thus do not have ot be preceded by it. If many range proofs need to be scanned to uncover those that belong to a 
particuler wallet, peaking the value only before fully rewinfing it will provide a performance benefit.</li>
</ul>
<p>The main use case has to do with wallet recovery. A user would normally have a backup of their unique wallet seed 
words somewhere, but could more easily lose their entire wallet without having made any backups or only having old 
backups. If a wallet can derive one or more sets of private keys from the seed words and use them in every UTXO 
construction as proposed, it can enable wallet recovery using Bulletproof rewinding.</p>
<p>A secondary use case would be for trusted 3rd parties to identify spending, by only having access to the public rewind 
key and the embedded proof message. The public rewind keys can be shared with a 3rd party out of band. The owner and/or 
delegated 3rd party can then use these keys in conjunction with a specific value commitment to calculate candidate 
rewind nonces for its proof. The returned proof message from the <em>peak value only</em> rewind step can be used to narrow 
down the probability that the particular proof belongs to a specific collection. In this mode the owner alone will be 
able to use both sets of pub-pvt key pairs in conjunction with a specific value commitment to calculate candidate rewind 
and blinding nonces for its proof. The <em>rewind fully</em> step will reveal the details of the value commitment and proof 
message if successful.</p>
<p>The use for this protocol, as opposed to simply revealing the original value along with the blinding factor to whoever 
wants the plain value, is to protect the UTXO. In Mimblewimble, if the value commitment can be opened, it can be spent 
without the owners knowledge.</p>
<p>The proof message is private or can be shared with a trusted 3rd party in the same way one would share the public 
rewind keys, but not common public knowledge. It is totally arbitrary, but known data, to enable identifying beyond a 
doubt if the returned value $ v_{(j)} $ is from a specific collection of value commitments $ V_{(j)} $.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p>Using the Application Programmers Interface (API) it is possible to:</p>
<ul>
<li>create a rewindable Zero-knowledge (ZK) proof with up to 23 bytes of additional embedded proof message  $ p_{msg} $ 
 ;</li>
<li>extract the value $ v_{(j)} $ and 23 bytes proof messsage $ p_{msg} $ only;</li>
<li>extract the value $ v_{(j)} $  ,   blinding factor $ \widetilde{v} $ and 23 bytes proof messsage $ p_{msg} $ 
 .</li>
</ul>
<h2 id="credits-2"><a class="header" href="#credits-2">Credits</a></h2>
<ul>
<li><a href="https://github.com/jaspervdm">@jaspervdm</a> for his improved bulletproof rewind scheme, used as precurser.</li>
<li><a href="https://github.com/cathieyun">@cathieyun</a> for provifing valuable feedback to improve this scheme.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0300dan"><a class="header" href="#rfc-0300dan">RFC-0300/DAN</a></h1>
<h2 id="digital-assets-network-2"><a class="header" href="#digital-assets-network-2">Digital Assets Network</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-50"><a class="header" href="#licence-50">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2018 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-53"><a class="header" href="#language-53">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-53"><a class="header" href="#disclaimer-53">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-52"><a class="header" href="#goals-52">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the key features of the Tari second layer, also known as the 
Digital Assets Network (DAN)</p>
<h2 id="related-requests-for-comment-45"><a class="header" href="#related-requests-for-comment-45">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0311_AssetTemplates.html">RFC-0311: Digital Assets</a></li>
<li><a href="RFCD-0340_VNConsensusOverview.html">RFCD-0340: VN Consensus Overview</a></li>
<li><a href="RFCDD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
</ul>
<h2 id="description-32"><a class="header" href="#description-32">Description</a></h2>
<h3 id="abstract-4"><a class="header" href="#abstract-4">Abstract</a></h3>
<p><a href="Glossary.html#digital-asset">Digital Asset</a>s (DAs) are managed by committees of special nodes called <a href="Glossary.html#validator-node">Validator Node</a>s (VNs):</p>
<ul>
<li>VNs manage digital asset state change and ensure that the rules of the asset contracts are enforced.</li>
<li>VNs form a peer-to-peer communication network that together defines the Tari DAN.</li>
<li>VNs register themselves on the <a href="Glossary.html#base-layer">base layer</a> and commit collateral to prevent Sybil attacks.</li>
<li>Scalability is achieved by sacrificing decentralization. Not <em>all</em> VNs manage <em>every</em> asset. Assets are managed by
subsets of the DAN, called VN <a href="Glossary.html#committee">committees</a>. These committees reach consensus on DA state amongst themselves.</li>
<li>VNs earn fees for their efforts.</li>
<li>DA contracts are not Turing complete, but are instantiated by <a href="Glossary.html#asset-issuer">Asset Issuer</a>s (AIs) using <a href="Glossary.html#digitalassettemplate">DigitalAssetTemplate</a>s that are defined
in the DAN protocol code.</li>
</ul>
<h3 id="digital-assets"><a class="header" href="#digital-assets">Digital Assets</a></h3>
<ul>
<li>DA contracts are <em>not</em> Turing complete, but are selected from a set of <a href="Glossary.html#digitalassettemplate">DigitalAssetTemplate</a>s that govern
the behaviour of each contract type. For example, there could be a Single-use Token template for simple ticketing systems, a
Coupon template for loyalty programmes, and so on.</li>
<li>The template system is intended to be highly flexible and additional templates can be added to the protocol periodically.</li>
<li>Asset issuers can link a Registered Asset Issuer Domain (RAID) ID in an OpenAlias TXT public Domain Name System (DNS) 
record to a Fully Qualified Domain Name (FQDN) that they own. This is to help disambiguate similar
contracts and improve the signal-to-noise ratio from scam or copycat contracts.</li>
</ul>
<p>An AI will issue a DA by constructing a contract from one of the supported set of <a href="Glossary.html#digitalassettemplate">DigitalAssetTemplate</a>s. The AI will choose
how large the committee of VNs will be for this DA, and have the option to nominate <a href="Glossary.html#trusted-node">Trusted Node</a>s to be part of the VN 
committee for the DA.
Any remaining spots on the committee will be filled by permissionless VNs that are selected according to a 
<a href="Glossary.html#committeeselectionstrategy">CommitteeSelectionStrategy</a>. This is a strategy that an AI will use to select from the set of potential candidate VNs 
that nominated themselves for a position on the committee when the AI broadcast a public call for VNs during the asset 
creation process. For the VNs to accept the appointment to the committee, they will need to put up the specified collateral.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0301namespaceregistration"><a class="header" href="#rfc-0301namespaceregistration">RFC-0301/NamespaceRegistration</a></h1>
<h2 id="namespace-registration-on-base-layer"><a class="header" href="#namespace-registration-on-base-layer">Namespace Registration on Base Layer</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/hansieodendaal">Hansie Odendaal</a></p>
<h1 id="licence-51"><a class="header" href="#licence-51">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-54"><a class="header" href="#language-54">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-54"><a class="header" href="#disclaimer-54">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-53"><a class="header" href="#goals-53">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe and specify the process for creating and linking an <a href="Glossary.html#asset-issuer">asset issuer</a> 
specified domain name with a <a href="Glossary.html#digital-asset">digital asset</a> on the Digital Assets Network (<a href="Glossary.html#digital-asset-network">DAN</a>).</p>
<h2 id="related-requests-for-comment-46"><a class="header" href="#related-requests-for-comment-46">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0341D_AssetRegistration.html">RFCD-0341/AssetRegistration</a></li>
<li><a href="RFCD-0311_AssetTemplates.html">RFCD-0310/AssetTemplates</a></li>
</ul>
<br>
<h1 id="description-33"><a class="header" href="#description-33">Description</a></h1>
<h2 id="background-2"><a class="header" href="#background-2">Background</a></h2>
<h3 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h3>
<p>In order to easily differentiate <a href="Glossary.html#digital-asset">digital asset</a>s in the DAN, apart from some unique unpronounceable 
character string, a human-readable identifier (domain name) is required. It is perceived that shorter names will have 
higher value due to branding and marketability. The question is, how this can be managed elegantly? It is also 
undesirable if, for example, the real Disney is forced to use the long versioned &quot;<em>disney.com-goofy-is-my-asset-yes</em>&quot; 
because some fake Disneys claimed &quot;<em>goofy</em>&quot; and &quot;<em>disney.com-goofy</em>&quot; and everything in-between.</p>
<p>One method to curb name space squatting is to register names on the <a href="Glossary.html#base-layer">base layer</a> layer with a domain name registration 
transaction. Let us call such a name a Registered Asset Issuer Name (RAIN). To make registering RAINs difficult enough 
to prevent spamming the network, a certain amount of <a href="Glossary.html#tari-coin">Tari coins</a> must be committed in a burn (permanently destroy) or 
a time-locked pay-to-self type transaction. Lots of management overhead will be associated with such a scheme, even if 
domainless assets are allowed. However, it would be impossible to stop someone 
from registering, say, a &quot;<em>disney.com</em>&quot; RAIN if they did not own the real &quot;<em>disney.com</em>&quot; Fully Qualified Domain Name (FQDN).</p>
<p>Another approach would be to make use of the public Domain Name System (DNS) and to link the FQDNs that are already 
registered, to the <a href="Glossary.html#digital-asset">digital asset</a>s in the DAN, making use of <a href="https://openalias.org/">OpenAlias</a> text (TXT) DNS 
records on an FQDN. Let us call this a Registered Asset Issuer Domain (RAID) TXT record. If we hash a public key and 
FQDN pair, it will provide us with a unique RAID_ID (RAID Identification). The RAID_ID will serve a similar purpose in 
the DAN as a Top Level Domain (TLD) in a DNS, as all digital assets belonging to a specific <a href="Glossary.html#asset-issuer">asset issuer</a> could then 
be grouped under the FQDN by inference. To make this scheme more elaborate, but potentially unnecessary, all such 
RAID_IDs could also be registered on the <a href="Glossary.html#base-layer">base layer</a>, similar to the RAIN scheme.</p>
<p>If the standard Mimblewimble protocol is followed, a new output feature can be defined to cater for a RAID tuple 
<code>(RAID_ID, PubKey)</code> that is linked to a specific Unspent Transaction Output (<a href="Glossary.html#unspent-transaction-outputs">UTXO</a>). The <code>RAID_ID</code> could be based on 
a <a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58Check</a> variant applied to <code>Hash256(PubKey || FQDN)</code>. If the 
amount of Tari coins associated with the RAID tuple transaction is burned, <code>(RAID_ID, PubKey)</code> will forever be present 
on the blockchain and can increase blockchain bloat. On the other hand, if those <a href="Glossary.html#tari-coin">Tari coins</a> are spent back to their 
owner with a specific time lock, it will be possible to spend and prune that UTXO later on. While that UTXO remains 
unspent, the RAID tuple will be valid, but when all or part of it is spent, the RAID tuple will disappear from the 
blockchain. Such a UTXO will thus be &quot;coloured&quot; while unspent, as it will have different properties to a normal UTXO. It 
will also be possible to recreate the original RAID tuple by registering it using the original <code>Hash256(PubKey || FQDN)</code>.</p>
<p>Thinking about the make-up of the <code>RAID_ID</code>, it is evident that it can easily be calculated on the fly using the public 
key and FQDN, the values of which will always be known. The biggest advantage of having the RAID tuple on the <a href="Glossary.html#base-layer">base 
layer</a> is that of embedded consensus, where it will be validated (as no duplicates can be allowed) and mined before it 
can be used. However, this comes at the cost of more complex code, a more elaborate asset registration process and 
higher asset registration fees.</p>
<h3 id="this-request-for-comment"><a class="header" href="#this-request-for-comment">This Request for Comment</a></h3>
<p>This RFC explores the creation and use of RAID TXT records to link asset issuer-specified domain names with 
digital assets on the <a href="Glossary.html#digital-asset-network">DAN</a>, without RAID_IDs being registered on the <a href="Glossary.html#base-layer">base layer</a>.</p>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<h3 id="openalias-txt-dns-records"><a class="header" href="#openalias-txt-dns-records">OpenAlias TXT DNS Records</a></h3>
<p>An OpenAlias TXT DNS record [<a href="https://docs.rs/openalias/0.2.0/openalias/index.html" title="Crate openalias">1</a>] on an FQDN is a single string and starts with &quot;<em>oa1:&lt;name&gt;</em>&quot; field followed by a 
number of key-value pairs. Standard (optional) key values are: &quot;<em>recipient_address</em>&quot;; &quot;<em>recipient_name</em>&quot;; 
&quot;<em>tx_description</em>&quot;; &quot;<em>tx_amount</em>&quot;; &quot;<em>tx_payment_id</em>&quot;; &quot;<em>address_signature</em>&quot;; and &quot;<em>checksum</em>&quot;. Additional key values 
may also be defined. Only entities with write access to a specific DNS record will be able to create the required TXT 
DNS record entries.</p>
<p>TXT DNS records are limited to multiple strings of size 255, and as the User Datagram Protocol (UDP) size is 512 bytes, 
a TXT DNS record that exceeds that limit is less optimal [<a href="https://tools.ietf.org/html/rfc7208" title="RFC 7208">2</a>, Sections 3.3 and 3.4]. Some hosting sites also place 
limitations on TXT DNS record string lengths and concatenation of multiple strings as per [<a href="https://tools.ietf.org/html/rfc7208" title="RFC 7208">2</a>]. The basic idea of this 
specification is to make the implementation robust and flexible at the same time.</p>
<p><strong>Req</strong> - Integration with public DNS records MUST be used to ensure valid ownership of an FQDN that needs to be 
linked to a <a href="Glossary.html#digital-asset">digital asset</a> on the DAN. </p>
<p><strong>Req</strong> - The total size of the OpenAlias TXT DNS record SHOULD NOT exceed 255 characters.</p>
<p><strong>Req</strong> - The total size of the OpenAlias TXT DNS record MUST NOT exceed 512 characters.</p>
<p><strong>Req</strong> - The OpenAlias TXT DNS record implementation MUST make provision to interpret entries that are made up of more 
than one string as defined in [<a href="https://tools.ietf.org/html/rfc7208" title="RFC 7208">2</a>].</p>
<p><strong>Req</strong> - The OpenAlias TXT DNS record SHOULD adhere to the formatting requirements as specified in [<a href="https://docs.rs/openalias/0.2.0/openalias/index.html" title="Crate openalias">1</a>].</p>
<p><strong>Req</strong> - The OpenAlias TXT DNS record MUST be constructed as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>OpenAlias TXT DNS Record Field</th><th>OpenAlias TXT DNS Record Data</th></tr></thead><tbody>
<tr><td>oa1:&lt;name&gt;</td><td>&quot;oa1:tari&quot;</td></tr>
<tr><td>pk</td><td>&lt;256 bit public key, in hexadecimal format (64 characters), that is converted into a <code>Base58</code> encoded string (44 characters)&gt;</td></tr>
<tr><td>raid_id</td><td>&lt;<code>RAID_ID</code> (<em>refer to <a href="RFCD-0301_NamespaceRegistration.html#raid_id">RAID_ID</a></em>) (15 characters)&gt;</td></tr>
<tr><td>nonce</td><td>&lt;256 bit public nonce, in hexadecimal format (64 characters), that is converted into a <code>Base58</code> encoded string (44 characters)&gt;</td></tr>
<tr><td>sig</td><td>&lt;<a href="Glossary.html#asset-issuer">Asset issuer</a>'s 256 bit Schnorr signature for the <code>RAID_ID</code> (<em>refer to <a href="RFCD-0301_NamespaceRegistration.html#raid_id">RAID_ID</a></em>), in hexadecimal format (64 characters), that is converted into a <code>Base58</code> encoded string (44 characters)&gt;</td></tr>
<tr><td>desc</td><td>&lt;Optional RAID description&gt;; ASCII String; Up to 48 characters for the condensed version (using only one string) and up to 235 characters (when spanning two strings).</td></tr>
<tr><td>crc</td><td>&lt;CRC-32 checksum of the entire record, up to but excluding the checksum key-value pair (starting at &quot;<strong>oa1:tari</strong>&quot; and ending at the last &quot;<strong>;</strong>&quot; before the checksum key-value pair) in hexadecimal format (eight characters)&gt;</td></tr>
</tbody></table>
</div>
<p>    <strong>Examples:</strong> Two example OpenAlias TXT DNS records are shown; the first is a condensed version and 
the second spans two strings:</p>
<pre><code class="language-text">RAID_ID:
public key    = ca469346d7643336c19155fdf5c6500a5232525ce4eba7e4db757639159e9861
FQDN          = disney.com
 -&gt; id        = RYqMMuSmBZFQkgp
   
base58 encodings:
public key    = ca469346d7643336c19155fdf5c6500a5232525ce4eba7e4db757639159e9861
 -&gt; base58    = EcbmnM6PLosBzpyCcBz1TikpNXRKcucpm73ez6xYfLtg
public nonce  = fc2c5fce596338f43f70dc0ce14659fdfea1ba3e588a7c6fa79957fc70aa1b4b
 -&gt; base58    = 5ctFNnCfBrP99rT1AFmj1WPyMD8uAdNUTESHhLoV3KBZ
signature     = 7dc54ec98da2350b0c8ed0561537517ac6f93a37f08a34482824e7df3514ce0d
 -&gt; base58    = 9TxTorviyTJAaVJ4eY4AQPixwLb6SDL4dieHff6MFUha
   
OpenAlias TXT DNS record (condensed: 212 characters):
IN   TXT = &quot;oa1:tari pk=EcbmnM6PLosBzpyCcBz1TikpNXRKcucpm73ez6xYfLtg;id=RYqMMuSmBZFQkgp;
nonce=5ctFNnCfBrP99rT1AFmj1WPyMD8uAdNUTESHhLoV3KBZ;sig=9TxTorviyTJAaVJ4eY4AQPixwLb6SDL4dieHff6MFUha;
desc=Cartoon characters;crc=176BE80C&quot;

OpenAlias TXT DNS record (spanning two strings: string 1 = 179 characters and string 2 = 250 characters):
IN   TXT = &quot;oa1:tari pk=EcbmnM6PLosBzpyCcBz1TikpNXRKcucpm73ez6xYfLtg; id=RYqMMuSmBZFQkgp; 
nonce=5ctFNnCfBrP99rT1AFmj1WPyMD8uAdNUTESHhLoV3KBZ; sig=9TxTorviyTJAaVJ4eY4AQPixwLb6SDL4dieHff6MFUha; &quot;
&quot;desc=Cartoon characters: Mickey Mouse\; Minnie Mouse\; Goofy\; Donald Duck\; Pluto\; Daisy Duck\; 
Scrooge McDuck\; Launchpad McQuack\; Huey, Dewey and Louie\; Bambi\; Thumper\; Flower\; Faline\; 
Tinker Bell\; Peter Pan and Captain Hook.; crc=54465902&quot;
</code></pre>
<h3 id="raid_id"><a class="header" href="#raid_id">RAID_ID</a></h3>
<p>Because the <code>RAID_ID</code> does not exist as an entity on the base layer or in the <a href="Glossary.html#digital-asset-network">DAN</a>, it cannot be owned or 
transferred, but can only be verified as part of the OpenAlias TXT DNS record [<a href="https://docs.rs/openalias/0.2.0/openalias/index.html" title="Crate openalias">1</a>] verification. If an asset creator 
chooses not to link a <code>RAID_ID</code> and FQDN, a default network-assigned <code>RAID_ID</code> will be used in the digital asset 
registration process.</p>
<p><strong>Req</strong> - A default <code>RAID_ID</code> MUST be used where it will not be linked to an FQDN, e.g. it MAY be derived
from a default input string <code>&quot;No FQDN&quot;</code>.</p>
<p><strong>Req</strong> - An FQDN-linked (non-default) <code>RAID_ID</code> MUST be derived from the concatenation <code>PubKey || &lt;FQDN&gt;</code>.</p>
<p><strong>Req</strong> - All concatenations of inputs for any hash algorithm MUST be done without adding any spaces.</p>
<p><strong>Req</strong> - The hash algorithm MUST be <code>Blake2b</code> using a 32 byte digest size, unless otherwise specified.</p>
<p><strong>Req</strong> - Deriving a <code>RAID_ID</code> MUST be calculated as follows:</p>
<ul>
<li>Inputs for all hashing algorithms used to calculate the <code>RAID_ID</code> MUST be lower-case characters.</li>
<li>Stage 1 - MUST select the input string to use (either <code>&quot;No FQDN&quot;</code> or <code>PubKey || &lt;FQDN&gt;</code>).
<ul>
<li>Example: Mimblewimble public key <code>ca469346d7643336c19155fdf5c6500a5232525ce4eba7e4db757639159e9861</code> and FQDN 
<code>disney.com</code> are used here, resulting in <code>ca469346d7643336c19155fdf5c6500a5232525ce4eba7e4db757639159e9861disney.com</code>.</li>
</ul>
</li>
<li>Stage 2 - MUST perform <code>Blake2b</code> hashing on the result of stage 1 using a 10 byte digest size.
<ul>
<li>Example: In hexadecimal representation <code>ff517a1387153cc38009</code> or binary representation<code>\xffQz\x13\x87\x15&lt;\xc3\x80\t</code>.</li>
</ul>
</li>
<li>Stage 3 - MUST concatenate the <code>RAID_ID</code> identifier byte, <code>0x62</code>, with the result of stage 2.
<ul>
<li>Example: <code>62ff517a1387153cc38009</code> `.</li>
</ul>
</li>
<li>Stage 4 - MUST convert the result of stage 3 from a byte string into a <code>Base58</code> encoded string. 
This will result in a 15 character string starting with <code>R</code>.
<ul>
<li>Example: The resulting <code>RAID_ID</code> will be <code>RYqMMuSmBZFQkgp</code>.</li>
</ul>
</li>
</ul>
<p><strong>Req</strong> - A valid <code>RAID_ID</code> signature MUST be a 256 bit Schnorr signature defined as <code>s = PvtNonce + e·PvtKey</code> with 
the challenge <code>e</code> being <code>e = Blake2b(PubNonce || PubKey || RAID_ID)</code>.</p>
<h3 id="sequence-of-events"><a class="header" href="#sequence-of-events">Sequence of Events</a></h3>
<p>The sequence of events leading up to digital asset registration is perceived as follows:</p>
<ol>
<li>
<p>The <a href="Glossary.html#asset-issuer">asset issuer</a> will decide if the default <code>RAID_ID</code> or a <code>RAID_ID</code> that is linked to an FQDN must be used for 
asset registration. 
(<em><strong>Note:</strong> A single linked (<code>RAID_ID</code>, FQDN) tuple may be associated with multiple digital assets from the same 
asset issuer.</em>)</p>
</li>
<li>
<p><strong>Req</strong> - If a default <code>RAID_ID</code> is required:</p>
<ol>
<li>The asset issuer MUST use the default <code>RAID_ID</code> (refer to <a href="RFCD-0301_NamespaceRegistration.html#raid_id">RAID_ID</a>).</li>
<li>The asset issuer MUST NOT sign the <code>RAID_ID</code>.</li>
</ol>
</li>
<li>
<p><strong>Req</strong> - If a linked (<code>RAID_ID</code>, FQDN) tuple is required:</p>
<ol>
<li>The asset issuer MUST create a <code>RAID_ID</code>.</li>
<li>The asset issuer MUST sign the <code>RAID_ID</code> as specified (refer to <a href="RFCD-0301_NamespaceRegistration.html#raid_id">RAID_ID</a>).</li>
<li>The asset issuer MUST create a valid TXT DNS record (refer to <a href="RFCD-0301_NamespaceRegistration.html#openalias-txt-dns-records">OpenAlias TXT DNS Records</a>).</li>
</ol>
</li>
<li>
<p><strong>Req</strong> - <a href="Glossary.html#validator-node">Validator Node</a>s (VNs) MUST only allow a valid <code>RAID_ID</code> to be used in the digital asset registration 
process.</p>
</li>
<li>
<p><strong>Req</strong> - VNs MUST verify the OpenAlias TXT DNS record if a linked (<code>RAID_ID</code>, FQDN) tuple is used:</p>
<ol>
<li>Verify that all fields have been completed as per the specification (refer to 
<a href="RFCD-0301_NamespaceRegistration.html#openalias-txt-dns-records">OpenAlias TXT DNS Records</a>).</li>
<li>Verify that the <code>RAID_ID</code> can be calculated from information provided in the TXT DNS record and the FQDN of the 
public DNS record it is in.</li>
<li>Verify that the asset issuer's <code>RAID_ID</code> signature is valid.</li>
<li>Verify the checksum.</li>
</ol>
</li>
</ol>
<h3 id="confidentiality-and-security"><a class="header" href="#confidentiality-and-security">Confidentiality and Security</a></h3>
<p>To prevent client lookups from leaking, OpenAlias recommends making use of <a href="https://dnscrypt.info/">DNSCrypt</a>, 
resolution via DNSCrypt-compatible resolvers that support Domain Name System Security Extensions (DNSSEC) and without 
DNS requests being logged.</p>
<p><strong>Req</strong> - <a href="Glossary.html#token-wallet">Token Wallet</a>s (TWs) and VNs SHOULD implement the following confidentiality and security measures when 
dealing with OpenAlias TXT DNS records:</p>
<ul>
<li>All queries SHOULD make use of the DNSCrypt protocol.</li>
<li>Resolution SHOULD be forced via DNSCrypt-compatible resolvers that:
<ul>
<li>support DNSSEC;</li>
<li>do not log DNS requests.</li>
</ul>
</li>
<li>The DNSSEC trust chain validity:
<ul>
<li>SHOULD be verified;</li>
<li>SHOULD be reported back to the <a href="Glossary.html#asset-issuer">asset issuer</a>.</li>
</ul>
</li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p>[<a href="https://docs.rs/openalias/0.2.0/openalias/index.html" title="Crate openalias">1</a>] Crate Openalias [online]. Available: <a href="https://docs.rs/openalias/0.2.0/openalias/index.html">https://docs.rs/openalias/0.2.0/openalias/index.html</a>. 
Date accessed: 2019-03-05.</p>
<p>[<a href="https://tools.ietf.org/html/rfc7208" title="RFC 7208">2</a>] RFC 7208: Sender Policy Framework (SPF) for Authorizing Use of Domains in Email, Version 1 [online]. 
Available: <a href="https://tools.ietf.org/html/rfc7208">https://tools.ietf.org/html/rfc7208</a>. Date accessed: 2019-03-06.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0302validatornode"><a class="header" href="#rfc-0302validatornode">RFC-0302/ValidatorNode</a></h1>
<h2 id="validator-nodes-1"><a class="header" href="#validator-nodes-1">Validator Nodes</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-52"><a class="header" href="#licence-52">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2018 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-55"><a class="header" href="#language-55">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-55"><a class="header" href="#disclaimer-55">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-54"><a class="header" href="#goals-54">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the responsibilities of Validator Nodes (VNs) on the Digital 
Asset Network (DAN).</p>
<h2 id="related-requests-for-comment-47"><a class="header" href="#related-requests-for-comment-47">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0322_VNRegistration.html">RFCD-0322: Validator Node Registration</a></li>
<li><a href="RFCD-0304_VNCommittees.html">RFCD-0304: Validator Node Committee Selection</a></li>
<li><a href="RFCD-0340_VNConsensusOverview.html">RFCD-0340: VN Consensus Overview</a></li>
</ul>
<h2 id="description-34"><a class="header" href="#description-34">Description</a></h2>
<h3 id="abstract-5"><a class="header" href="#abstract-5">Abstract</a></h3>
<p><a href="Glossary.html#validator-node">Validator Node</a>s form the basis of the second-layer DAN. All actions on this network take place by interacting with VNs. 
Some examples of actions
that VNs will facilitate are:</p>
<ul>
<li>issuing a <a href="Glossary.html#digital-asset">Digital Asset</a> (DA);</li>
<li>querying the state of a DA and its constituent <a href="Glossary.html#digital-asset-tokens">tokens</a>; and</li>
<li>issuing an instruction to change the state of a DA or tokens.</li>
</ul>
<p>VNs will also perform archival functions for the assets they manage. The lifetime of these archives and the fee structure 
for this function are
still being discussed.</p>
<h4 id="registration"><a class="header" href="#registration">Registration</a></h4>
<p>VNs register themselves on the <a href="Glossary.html#base-layer">Base Layer</a> using a special <a href="Glossary.html#transaction">transaction</a> type.</p>
<p>Validator node registration is described in <a href="RFC-0322_VNRegistration.html">RFC-0322</a>.</p>
<h4 id="execution-of-instructions"><a class="header" href="#execution-of-instructions">Execution of Instructions</a></h4>
<p>VNs are expected to manage the state of DAs on behalf of DA issuers. They receive fees as reward
for doing this.</p>
<ul>
<li>DAs consist of an initial state plus a set of state transition rules. These rules are set by the Tari
protocol, but will usually provide parameters that must be specified by the <a href="Glossary.html#asset-issuer">Asset Issuer</a>.</li>
<li>The set of VNs that participate in managing state of a specific DA is called a <a href="Glossary.html#committee">Committee</a>. A committee is selected 
during the asset
issuance process and membership of the committee can be updated at <a href="Glossary.html#checkpoint">Checkpoint</a>s.</li>
<li>The VN is responsible for ensuring that every state change in a DA conforms to the contract's rules.</li>
<li>VNs accept DA <a href="Glossary.html#instructions">Instructions</a> from clients and peers. Instructions allow for creating, updating, expiring and 
archiving DAs on the DAN.</li>
<li>VNs provide additional collateral, called <a href="Glossary.html#assetcollateral">AssetCollateral</a>, when accepting an offer to manage an asset, which is 
stored in a multi-signature (multi-sig)
Unspent Transaction Output (UTXO) on the base layer. This collateral can be taken from the VN if it is proven that the 
VN engaged in
malicious behaviour.</li>
<li>VNs participate in fraud-proof validations in the event of consensus disputes (which could result in the malicious VN's
collateral being slashed).</li>
<li>DA metadata (e.g. large images) is managed by VNs. The large data itself will not be stored on the VNs, but 
in an external location, and a hash of the data can be stored. Whether the data is considered part of the state
(and thus checkpointed) or out of state depends on the type of DA contract employed.</li>
</ul>
<h4 id="fees"><a class="header" href="#fees">Fees</a></h4>
<p>Fees will be paid to VNs based on the amount of work they did during a checkpoint period. The fees will be paid from a 
fee pool, which will be collected
and reside in a UTXO that is accessible by the committee. The exact mechanism for the payment of the fees by the 
committee and who pays the various
types of fees is still under discussion.</p>
<h4 id="checkpoints"><a class="header" href="#checkpoints">Checkpoints</a></h4>
<p>VNs periodically post checkpoint summaries to the <a href="Glossary.html#base-layer">base layer</a> for each asset that they are managing. The checkpoints 
will form an immutable
record of the DA state on the base layer. There will be two types of checkpoints:</p>
<ul>
<li>
<p>An Opening Checkpoint (OC) will:</p>
<ul>
<li>specify the members of the VN committee;</li>
<li>lock up the collateral for the committee members for this checkpoint period; and</li>
<li>collect the fee pool for this checkpoint period from the Asset Issuer into a multi-sig UTXO under the control of the 
committee.
This can be a top-up of the fees or a whole new fee pool.</li>
</ul>
</li>
<li>
<p>A Closing Checkpoint (CC) will:</p>
<ul>
<li>summarize the DA state on the base layer;</li>
<li>release the fee payouts;</li>
<li>release the collateral for the committee members for this checkpoint period; and</li>
<li>allow for committee members to resign from the committee.</li>
</ul>
</li>
</ul>
<p>After a DA is issued, there will immediately be an OC. After a checkpoint period there will then be a 
CC, followed
immediately by an OC for the next period. We will call this set of checkpoints an Intermediate checkpoint, which could be a compressed combination of an OC and CC. This will continue
until the end of the asset's lifetime, when there will be a final CC that will be followed by the retirement of the asset.</p>
<div class="mermaid">
graph LR;
    subgraph Asset Issuance
    IssueAsset-->OC1;
    end
    OC1-->CC1;
    subgraph Intermediate Checkpoint
    CC1-->OC2;
    end
    OC2-->CC2;
    subgraph Intermediate Checkpoint
    CC2-->OC3;
    end
    OC3-->CC3;
    subgraph Asset Retirement
    CC3-->RetireAsset;
    end
</div>
<h4 id="consensus-1"><a class="header" href="#consensus-1">Consensus</a></h4>
<p>Committees of VNs will use a <a href="Glossary.html#consensusstrategy">ConsensusStrategy</a> to manage the process of:</p>
<ul>
<li>propagating signed instructions between members of the committee; and</li>
<li>determining when the threshold has been reached for an instruction to be considered valid.</li>
</ul>
<p>Part of the Consensus Strategy will be mechanisms for detecting actions by <a href="Glossary.html#bad-actor">Bad Actor</a>s. The nature of the enforcement 
actions that can be taken
against bad actors is still to be decided.</p>
<h3 id="network-communication"><a class="header" href="#network-communication">Network Communication</a></h3>
<p>The VNs will communicate using a Peer-to-Peer (P2P) network. To facilitate this, the VNs must perform the following functions:</p>
<ul>
<li>VNs MUST maintain a list of peers, including which assets each peer is managing.</li>
<li>VNs MUST relay <a href="Glossary.html#instructions">instructions</a> to members of the committee that are managing the relevant asset.</li>
<li>VNs MUST respond to requests for information about DAs that they manage on the DAN.</li>
<li>VNs and clients can advertise public keys to facilitate P2P communication encryption.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0304vncommittees"><a class="header" href="#rfc-0304vncommittees">RFC-0304/VNCommittees</a></h1>
<h2 id="validator-node-committee-selection-1"><a class="header" href="#validator-node-committee-selection-1">Validator Node Committee Selection</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-53"><a class="header" href="#licence-53">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-56"><a class="header" href="#language-56">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-56"><a class="header" href="#disclaimer-56">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-55"><a class="header" href="#goals-55">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the process an <a href="Glossary.html#asset-issuer">Asset Issuer</a> (AI) will go through in order to 
select the committee of <a href="Glossary.html#validator-node">Validator Node</a>s
(VNs) that will serve a given <a href="Glossary.html#digital-asset">Digital Asset</a> (DA).</p>
<h2 id="related-requests-for-comment-48"><a class="header" href="#related-requests-for-comment-48">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0311_AssetTemplates.html">RFCD-0311: Digital Asset Templates</a></li>
<li><a href="RFCD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
<li><a href="RFCD-0341_AssetRegistration.html">RFCD-0341: Asset Registration</a></li>
</ul>
<h2 id="description-35"><a class="header" href="#description-35">Description</a></h2>
<h3 id="abstract-6"><a class="header" href="#abstract-6">Abstract</a></h3>
<p><a href="Glossary.html#digital-asset">Digital Asset</a>s (DAs) are managed by <a href="Glossary.html#committee">committee</a>s of nodes called <a href="Glossary.html#validator-node">Validator Node</a>s (VNs), as described in 
<a href="RFCD-0300_DAN.html">RFC-0300</a> and <a href="RFCD-0302_ValidatorNodes.html">RFC-0302</a>. During the asset creation process, described in
<a href="RFC-0341D_AssetRegistration.html">RFC-0341</a>, the <a href="Glossary.html#asset-issuer">Asset Issuer</a> (AI) MUST select a committee of VNs to manage their asset.
This process consists of the following steps:</p>
<ol>
<li>Candidate VNs MUST be nominated to be considered for selection by the AI.</li>
<li>The AI MUST employ a <a href="Glossary.html#committeeselectionstrategy">CommitteeSelectionStrategy</a> to select VNs from the set of nominated candidates.</li>
<li>The AI MUST make an offer of committee membership to the selected VNs.</li>
<li>Selected VNs MAY accept the offer to become part of the committee by posting the required <a href="Glossary.html#assetcollateral">AssetCollateral</a>.</li>
</ol>
<h3 id="nomination"><a class="header" href="#nomination">Nomination</a></h3>
<p>The first step in assembling a committee is to nominate candidate VNs. As described in 
<a href="RFC-0311_AssetTemplates.html">RFC-0311</a>, an asset can be created with two possible <code>committee_modes</code> - <code>CREATOR_NOMINATION</code> 
or <code>PUBLIC_NOMINATION</code>:</p>
<ul>
<li>In <code>CREATOR_NOMINATION</code> mode, the AI nominates candidate committee members directly. The AI will have a list of permissioned 
<a href="Glossary.html#trusted-node">Trusted Node</a>s that they want to act as the committee. The AI will contact the candidate VNs directly to inform them of 
their nomination.</li>
<li>In <code>PUBLIC_NOMINATION</code> mode, the AI does not have a list of <a href="Glossary.html#trusted-node">Trusted Node</a>s and wants to source unknown VNs from the 
network. In this case, the AI broadcasts a public call for nomination to the Tari network using the peer-to-peer messaging 
protocol described in <a href="RFC-0172_PeerToPeerMessagingProtocol.html">RFC-0172</a>. This call for nomination contains all the 
details of the asset. VNs that want to participate will then nominate themselves by contacting the AI.</li>
</ul>
<h3 id="selection"><a class="header" href="#selection">Selection</a></h3>
<p>Once the AI has received a list of nominated VNs, it must make a selection, assuming enough VNs were nominated to populate 
the committee. The AI will employ some <a href="Glossary.html#committeeselectionstrategy">CommitteeSelectionStrategy</a> in order to select the committee from the candidate 
VNs that have been nominated. This strategy might aim for a perfectly random selection, or perhaps it will consider some 
metrics about the candidate VNs, such as the length of their VN registrations. These metrics might indicate that they are reliable 
and have not been denylisted for poor or malicious performance.</p>
<p>A consideration when selecting a committee in <code>PUBLIC_NOMINATION</code> mode will be the size of the pool of nominated VNs. 
The size of this pool relative to the size of the committee to be selected will be linked to a risk profile. If the pool 
contains very few candidates, then it will be much easier for an attacker to have nominated their own nodes in order to 
obtain a majority membership of the committee. For example, if the AI is selecting a committee of 10 members using a uniformly 
random selection strategy and only 12 public nominations are received, an attacker only requires control of six VNs to 
achieve a majority position in the committee. In contrast, if 100 nominations are received and the AI performs a 
uniformly random selection, an attacker would need to control more than 50 of the nominated nodes in order to achieve a 
majority position in the committee.</p>
<h3 id="offer-acceptance"><a class="header" href="#offer-acceptance">Offer Acceptance</a></h3>
<p>Once the selection has been made by the AI, the selected VNs will be informed and they will be made an offer of membership. 
If the VNs are still inclined to join the committee, they will accept the offer by posting the <a href="Glossary.html#assetcollateral">AssetCollateral</a> 
required by the asset to the <a href="Glossary.html#base-layer">base layer</a> during the initial <a href="Glossary.html#checkpoint">Checkpoint</a> transaction built to commence the operation of 
the asset.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0306dantemplateregistration"><a class="header" href="#rfc-0306dantemplateregistration">RFC-0306/DANTemplateRegistration</a></h1>
<h2 id="digital-asset-network-dan-template-registration"><a class="header" href="#digital-asset-network-dan-template-registration">Digital Asset Network (DAN) Template Registration</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/sdbondi">Stanley Bondi</a></p>
<h1 id="licence-54"><a class="header" href="#licence-54">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-57"><a class="header" href="#language-57">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-57"><a class="header" href="#disclaimer-57">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-56"><a class="header" href="#goals-56">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the layer 2 code template registration procedure.
Code templates are composable and reusable building blocks that define state and operations on any given
side-chain contract.</p>
<p>Registering these on the base layer accomplishes these goals:</p>
<ol>
<li>Provides a public register of code templates with an immutable notary (the Tari base layer).</li>
<li>Provides a source of truth that <a href="RFC-0302_ValidatorNodes.html">Validator Node</a>s and potentially others can use to ensure the correct code templates are being run.</li>
<li>Provides reusable building-blocks available to anyone wishing to build side-chain contracts.</li>
<li>Provides other metadata, such as versioning and authorship.</li>
</ol>
<p>This registration scheme seeks to enable template indexing services and possibly marketplaces for template authors.</p>
<h2 id="related-requests-for-comment-49"><a class="header" href="#related-requests-for-comment-49">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
</ul>
<h2 id="description-36"><a class="header" href="#description-36">Description</a></h2>
<p>A template author registers a template on the <a href="Glossary.html#base-layer">Base layer</a> creating a special <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> on the base layer.
The registration <a href="Glossary.html#transaction">transaction</a> requires the spending of a certain minimum deposit amount of <a href="Glossary.html#tari-coin">Tari coin</a>, in addition to
weighted <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> fees, to discourage spam.</p>
<p>It is helpful to describe what a template is and how it relates to a running side-chain contract. Rather than
being a fully-fledged smart-contract, templates define single-concern state and state-transition functions that can be
composed with other templates and run, by a set of layer 2 <a href="RFC-0302_ValidatorNodes.html">validator node</a>s.</p>
<p>This RFC is primarily concerned with the mechanism for making these templates available to other parties wishing to
build contracts and run them. The most important aspect of this is to allow any <a href="RFC-0302_ValidatorNodes.html">validator node</a> to verify that they
are running the same code as other members of the same committee.</p>
<h2 id="template-registration-utxo-fields"><a class="header" href="#template-registration-utxo-fields">Template Registration UTXO fields</a></h2>
<p>A base-layer template registration <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> MUST have the <code>TEMPLATE_REGISTRATION</code> output flag set and contain the following data:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>author_public_key</td><td>ECC public key</td><td>Public key of the author</td></tr>
<tr><td>author_signature</td><td>Schnorr signature</td><td>Signature that signs remaining fields</td></tr>
<tr><td>template_id</td><td>256-bit hash</td><td>Hash of <code>TEMPLATE_REGISTRATION</code> fields (see below)</td></tr>
<tr><td>template_name</td><td>String (255)</td><td>A descriptive name for the template</td></tr>
<tr><td>template_version</td><td>Varint</td><td>Code version as a single number</td></tr>
<tr><td>build_info</td><td>BuildInfo struct</td><td>Information on the binary build</td></tr>
<tr><td>binary_checksum</td><td>SHA2 checksum</td><td>A SHA2 checksum of the WASM binary.</td></tr>
<tr><td>binary_address</td><td><a href="https://multiformats.io/multiaddr/">Multiaddr</a></td><td>A <a href="https://multiformats.io/multiaddr/">multiaddr</a> pointing to the WASM module binary download. This may be an HTTP, ONION, p2p, or IPFS address. Maximum byte length: 255</td></tr>
</tbody></table>
</div>
<p>We define the <code>template_id</code> as a hash of <code>author_public_key</code>, <code>template_name</code>, <code>template_version</code>, <code>build_info</code>, <code>binary_checksum</code>, and <code>binary_address</code>.
The <code>author_signature</code> is a Schnorr proof that commits to the <code>template_id</code>.</p>
<p>The base node acts as a notary for this data, it is not responsible for the validity of the template fields. However, it must
not allow malformed/invalid data to be committed to the blockchain.</p>
<p>Therefore, some additional base-layer consensus rules are required for a <code>TEMPLATE_REGISTRATION</code> <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>:</p>
<ul>
<li>A base node MUST validate the <code>author_signature</code>; and</li>
<li>the <code>template_id</code> MUST be unique within the unspent set.</li>
</ul>
<p>To reference a template within a contract:</p>
<ul>
<li>the contract includes a reference to the specific template registration <code>template_id</code>.</li>
<li>Alternative: the <code>TEMPLATE_REGISTRATION</code> information is copied into the contract definition <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>.</li>
</ul>
<p>A base node SHOULD NOT check that the <code>binary_address</code> points to a valid template binary.</p>
<p>** BuildInfo struct **</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>build_image</td><td>Url</td><td>A docker build environment used to build the binary</td></tr>
<tr><td>repo_link</td><td>Url</td><td>A public link to the source code repository</td></tr>
<tr><td>commit_hash</td><td>SHA2 hash</td><td>The commit hash of the code used to build the binary</td></tr>
</tbody></table>
</div>
<p>The <code>build_image</code> field SHOULD contain a link to a publicly-accessible docker image that contains the exact build
environment used to build the binary. The build environment refers to the specific compiler and OS used. Typically,
this will be a docker image with a specific version of the rust compiler, LLVM and the <code>wasm-unknown-unknown</code> target
provided by the Tari community.</p>
<p>Anyone wishing to execute the template MAY build the binary themselves and compare checksums.
It's worth noting that identical build environments do not guarantee deterministic builds.
If you're curious about the kinds of issues encountered with deterministic builds using the rust language,
<a href="https://dev.to/gnunicorn/hunting-down-a-non-determinism-bug-in-our-rust-wasm-build-4fk1">read this post</a>.</p>
<h2 id="obtaining-the-template-binary"><a class="header" href="#obtaining-the-template-binary">Obtaining the Template Binary</a></h2>
<p>The <a href="RFC-0312_DANHighLevelSpecification.html#contract-definition">contract definition</a> specifies the [binary_checksum] for each template. Once the <a href="RFC-0302_ValidatorNodes.html">validator node</a> has been
assigned a contract via the <a href="RFC-0312_DANHighLevelSpecification.html#contract-definition">contract definition</a>, the <a href="RFC-0302_ValidatorNodes.html">validator node</a> performs the following actions to obtain a template:</p>
<ol>
<li>It scans the blockchain for a template matching the <code>binary_checksum</code>;</li>
<li>it downloads the WASM binary and verifies the checksum and stores the binary and associated registration <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> metadata;</li>
<li>a validator node operator may choose to build the binary from source as per <code>BuildInfo</code> and use the resulting binary;</li>
</ol>
<p>In the event that a new validator is added to [contract constitution], but the original template registration is unavailable,
the <a href="RFC-0302_ValidatorNodes.html">validator node</a> SHOULD make the template available to new committee members. New committee members SHOULD confirm the checksum
with a 2/3 majority of the validator committee to ensure that the correct copy is received.</p>
<h2 id="spending-the-template-registration-utxo"><a class="header" href="#spending-the-template-registration-utxo">Spending the Template Registration UTXO</a></h2>
<p>These cases apply to spending the template registration <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>:</p>
<ol>
<li>The author MAY spend into another template registration <a href="Glossary.html#unspent-transaction-outputs">UTXO</a></li>
</ol>
<ul>
<li>This effectively withdraws (yanks) the previous version of the template.</li>
<li>The template name and author SHOULD be identical. This MAY be enforced by covenant.</li>
<li>The template version number MUST be incremented by one from the version number in the spent input.</li>
<li>It is RECOMMENDED that live contracts upgrade their definitions to run the new template.</li>
</ul>
<ol start="2">
<li>The author MAY spend to a &quot;vanilla&quot; <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> to reclaim their deposit.</li>
</ol>
<ul>
<li>This effectively withdraws (yanks) the template.</li>
<li>The template MAY remain in use on existing contracts. In fact, anyone may now re-register the template.</li>
</ul>
<p>Alternatives:</p>
<ul>
<li>Consensus rule that prevents spending of the template while used by other contracts</li>
<li>The contract definition may have copy the template binary_checksum etc. Validator nodes may mirror the code for new VNs</li>
</ul>
<h2 id="upgrading-a-template"><a class="header" href="#upgrading-a-template">Upgrading a Template</a></h2>
<p>If a <a href="RFC-0302_ValidatorNodes.html">validator node</a> detects an update to the <a href="RFC-0312_DANHighLevelSpecification.html#contract-definition">contract definition</a> that includes a template update, the <a href="RFC-0302_ValidatorNodes.html">validator node</a></p>
<ul>
<li>MUST fetch the new template(s) as per the previous procedure.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0311assettemplates"><a class="header" href="#rfc-0311assettemplates">RFC-0311/AssetTemplates</a></h1>
<h2 id="digital-asset-templates"><a class="header" href="#digital-asset-templates">Digital Asset Templates</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-55"><a class="header" href="#licence-55">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-58"><a class="header" href="#language-58">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-58"><a class="header" href="#disclaimer-58">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-57"><a class="header" href="#goals-57">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe the Tari Digital Asset templating system for smart contract 
definition.</p>
<p>The term “smart contracts” in this document is used to refer to a set of rules enforced by computers. These smart
contracts are not Turing complete, such as those executed by the Ethereum Virtual Machine (VM).</p>
<h2 id="related-requests-for-comment-50"><a class="header" href="#related-requests-for-comment-50">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: The Digital Assets Network</a></li>
<li><a href="RFCD-0301_NamespaceRegistration.html">RFCD-0301: Namespace Registration</a></li>
<li><a href="RFCD-0340_VNConsensusOverview.html">RFCD-0340: Validator Node Consensus</a></li>
<li><a href="RFCD-0345_AssetLifeCycle.html">RFCD-0345: Asset Life cycle</a></li>
</ul>
<h2 id="description-37"><a class="header" href="#description-37">Description</a></h2>
<h3 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h3>
<p>The reasons for issuing assets on Tari under a templating system, rather than a scripting language (whether Turing
complete or not), are manifold:</p>
<ul>
<li>A scripting language, irrespective of how simple it is, limits the target market for asset issuers to developers, or
people who pay developers.</li>
<li>The market doesn’t want general smart contracts. This is evidenced by the fact that the vast majority of Ethereum
transactions go through ERC-20 or ERC-721 contracts, which are literally contract templates.</li>
<li>The attack surface for smart contracts is reduced considerably, to the node software itself.</li>
<li>Bugs can be fixed for all contracts simultaneously by using a template versioning system. Existing assets can opt in
to fixes by migrating assets to a new version of the contract.</li>
<li>Contracts will have better Quality Assurance (QA), since more eyes are looking at fewer contract code sets.</li>
<li>Transmission, storage and processing of contracts will be more efficient, as one only has to deal with the parameters,
and not the logic of the contract. Furthermore, the cost for users is usually lower, since there's no need to add
friction or extra costs to contract execution (e.g. Ethereum gas) to work around the halting problem.</li>
</ul>
<h3 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h3>
<p>Assets are created on the Tari network by issuing a <code>create_asset</code> instruction from a wallet or client, and broadcasting
it to the Tari Digital Assets Network (DAN).</p>
<p>The instruction is in JSON format and MUST contain the following fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Asset Description</strong></td><td></td><td></td></tr>
<tr><td>issuer</td><td>PubKey</td><td>The public key of the creator of the asset. Refer to <a href="RFCD-0311_AssetTemplates.html#issuer">issuer</a>.</td></tr>
<tr><td>name</td><td><code>string[64]</code></td><td>The name or identifier for the asset. Refer to <a href="RFCD-0311_AssetTemplates.html#name-and-description">Name and Description</a>.</td></tr>
<tr><td>description</td><td><code>string[216]</code></td><td>A short description of the asset - with name, fits in a tweet. Refer to <a href="RFCD-0311_AssetTemplates.html#name-and-description">Name and Description</a>.</td></tr>
<tr><td>raid_id</td><td><code>string[15]</code></td><td>The <a href="RFCD-0311_AssetTemplates.html#raid-id">Registered Asset Issuer Domain (RAID_ID)</a> for the asset.</td></tr>
<tr><td>fqdn</td><td><code>string[*]</code></td><td>The Fully Qualified Domain Name (FQDN) corresponding to the <code>raid_id</code>. Up to 255 characters in length; or &quot;No_FQDN&quot; to use the default.</td></tr>
<tr><td>public_nonce</td><td>PubKey</td><td>Public nonce part of the creator signature.</td></tr>
<tr><td>template_id</td><td><code>u64</code></td><td>The template descriptor. Refer to <a href="RFCD-0311_AssetTemplates.html#template-id">Template ID</a>.</td></tr>
<tr><td>asset_expiry</td><td><code>u64</code></td><td>A timestamp or block height after which the asset will automatically expire. Zero for arbitrarily long-lived assets.</td></tr>
<tr><td><strong>Validation Committee Selection</strong></td><td></td><td></td></tr>
<tr><td>committee_mode</td><td><code>u8</code></td><td>The validation committee nomination mode, either <code>CREATOR_NOMINATION</code> (0) or <code>PUBLIC_NOMINATION</code> (1).</td></tr>
<tr><td>committee_parameters</td><td>Object</td><td>Refer to <a href="RFCD-0311_AssetTemplates.html#committee-parameters">Committee Parameters</a>.</td></tr>
<tr><td>asset_creation_fee</td><td><code>u64</code></td><td>The fee the issuer is paying, in microTari, for the asset creation process.</td></tr>
<tr><td>commitment</td><td><code>u256</code></td><td>A time-locked commitment for the asset creation fee.</td></tr>
<tr><td>initial_state_hash</td><td><code>u256</code></td><td>The hash of the canonical serialization of the initial template state (of the template-specific data).</td></tr>
<tr><td>initial_state_length</td><td><code>u64</code></td><td>Size in bytes of initial state.</td></tr>
<tr><td><strong>Template-specific Data</strong></td><td>Object</td><td>Template-specific metadata can be defined in this section.</td></tr>
<tr><td><strong>Signatures</strong></td><td></td><td></td></tr>
<tr><td>metadata_hash</td><td><code>u256</code></td><td>A hash of the previous three sections' data, in canonical format (<code>m</code>).</td></tr>
<tr><td>creator_sig</td><td><code>u256</code></td><td>A digital signature of the message <code>H(R ‖ P ‖ RAID_ID ‖ m)</code>, using the asset creator’s private key corresponding to the <code>issuer</code> Public Key Hash (PKH).</td></tr>
<tr><td>commitment_sig</td><td><code>u256</code></td><td>A signature proving the issuer is able to spend the commitment to the asset fee.</td></tr>
</tbody></table>
</div>
<h4 id="committee-parameters"><a class="header" href="#committee-parameters">Committee Parameters</a></h4>
<p>If <code>committee_mode</code> is <code>CREATOR_NOMINATION</code>, the <code>committee_parameters</code> object is:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">trusted_node_set</td><td style="text-align: left">Array of PKH</td><td style="text-align: left">See below.</td></tr>
</tbody></table>
</div>
<p>Only the nodes in the trusted node set will be allowed to execute instructions for this asset.</p>
<p>If <code>committee_mode</code> is <code>PUBLIC_NOMINATION</code>, the <code>committee_parameters</code> object is:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">node_threshold</td><td style="text-align: left"><code>u32</code></td><td style="text-align: left">The required number of Validator Nodes (VNs) that must register to execute instructions for this asset.</td></tr>
<tr><td style="text-align: left">minimum_collateral</td><td style="text-align: left"><code>u64</code></td><td style="text-align: left">The minimum amount of Tari a VN must put up in collateral in order to execute instructions for this asset.</td></tr>
<tr><td style="text-align: left">node_selection_strategy</td><td style="text-align: left"><code>u32</code></td><td style="text-align: left">The selection strategy to employ allowing nodes to register to manage this asset.</td></tr>
</tbody></table>
</div>
<h4 id="issuer-1"><a class="header" href="#issuer-1">Issuer</a></h4>
<p>Anyone can create new assets on the Tari network from their Tari Collections client. The client will provide the Public Key Hash (PKH) and
sign the instruction. The client needn’t use the same private key each time.</p>
<h4 id="name-and-description"><a class="header" href="#name-and-description">Name and Description</a></h4>
<p>These fields are purely for information purposes. They do not need to be unique and do not act as an asset ID.</p>
<h4 id="raid-id"><a class="header" href="#raid-id">RAID ID</a></h4>
<p>The RAID_ID is a 15-character string that associates the asset issuer with a registered Internet domain name on the Domain Name System (DNS).</p>
<p>If it is likely that a digital asset issuer will be issuing many assets on the Tari Network (hundreds or thousands),
the issuer should strongly consider using a registered domain (e.g. <code>acme.com</code>). This is
done via OpenAlias on the domain owner's DNS record, as described in <a href="RFC-0301_NamespaceRegistration.html">RFC-0301</a>. A RAID prevents spoofing of assets from 
copycats or other malicious actors. It also simplifies asset discovery.</p>
<p>Assets from issuers that do not have a RAID are all grouped under the default RAID.</p>
<p>RAID owners must provide a valid signature proving that they own the given domain when creating assets.</p>
<h4 id="fully-qualified-domain-name"><a class="header" href="#fully-qualified-domain-name">Fully Qualified Domain Name</a></h4>
<p>The Fully Qualified Domain Name (FQDN) that corresponds to the <code>raid_id</code> or the string <code>&quot;NO FQDN&quot;</code> to use the default RAID ID.
Validator Nodes (VNs) will calculate and check that the RAID ID is valid when
<a href="RFCD-0311_AssetTemplates.html#signature-validation">validating the instruction signature</a>.</p>
<h4 id="public-nonce"><a class="header" href="#public-nonce">Public Nonce</a></h4>
<p>A single-use public nonce to be used in the asset signature.</p>
<h4 id="asset-identification"><a class="header" href="#asset-identification">Asset Identification</a></h4>
<p>Assets are identified by a 64-character string that uniquely identifies an asset on the network:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Bytes</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">8</td><td style="text-align: left">Template type (hex)</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">Template version (hex)</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">Feature flags (hex)</td></tr>
<tr><td style="text-align: left">15</td><td style="text-align: left">RAID identifier (Base58)</td></tr>
<tr><td style="text-align: left">1</td><td style="text-align: left">A period character, <code>.</code></td></tr>
<tr><td style="text-align: left">32</td><td style="text-align: left">Hex representation of the <code>metadata_hash</code> field</td></tr>
</tbody></table>
</div>
<p>This allows assets to be deterministically identified from their initial state. Two different creation instructions
leading to the same hash refer to the same single asset, by definition. VNs maintain an index of assets and
their committees, and so can determine whether a given asset already exists; and MUST reject any <code>create_asset</code>
instruction for an existing asset.</p>
<h4 id="template-id"><a class="header" href="#template-id">Template ID</a></h4>
<p>Tari uses templates to define the behaviour for its smart contracts. The template ID refers to the type of digital asset
being created.</p>
<p><strong>Note:</strong> Integer values are given in <em>little-endian</em> format, i.e. the least significant bit is <em>first</em>.</p>
<p>The template number is a 64-bit unsigned integer and has the following format, with 0 representing
the least significant bit:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Bit Range</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">0 - 31</td><td style="text-align: left">Template type (0 - 4,294,967,295)</td></tr>
<tr><td style="text-align: left">32 - 47</td><td style="text-align: left">Template version (0 - 65,535)</td></tr>
<tr><td style="text-align: left">48</td><td style="text-align: left">Beta Mode flag</td></tr>
<tr><td style="text-align: left">49</td><td style="text-align: left">Confidentiality flag</td></tr>
<tr><td style="text-align: left">50 - 63</td><td style="text-align: left">Reserved (must be 0)</td></tr>
</tbody></table>
</div>
<p>The lowest 32 bits refer to the canonical smart contract type, i.e. the qualitative types of contracts the network supports.
Many assets can be issued from a single template.</p>
<p>Template types below 65,536 (2<sup>16</sup>) are public, community-developed templates.
All VNs MUST implement and be able to interpret instructions related to these templates.</p>
<p>Template types 65,536 and above are opt-in or proprietary templates. There is no guarantee that any given VN
will be able to manage assets on these templates. Part of the committee selection and confirmation process for new
assets will be an attestation by VNs that they are willing and able to manage the asset under the designated
template rules.</p>
<p>A global registry of opt-in template types will be necessary to prevent collisions (public templates existence will be
evident from the Validator Node source code), possibly implemented as a special transaction type on the base layer, 
which is perfectly suited for hosting such a registry. The details of this will be covered in a separate
proposal.</p>
<p>Examples of template types may be:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Template Type</th><th style="text-align: left">Asset</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left">Simple single-use tokens</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">Simple coupons</td></tr>
<tr><td style="text-align: left">20</td><td style="text-align: left">ERC-20-compatible</td></tr>
<tr><td style="text-align: left">...</td><td style="text-align: left">...</td></tr>
<tr><td style="text-align: left">120</td><td style="text-align: left">Collectible cards</td></tr>
<tr><td style="text-align: left">144</td><td style="text-align: left">In-game items</td></tr>
<tr><td style="text-align: left">721</td><td style="text-align: left">ERC-721-compatible</td></tr>
<tr><td style="text-align: left">...</td><td style="text-align: left">...</td></tr>
<tr><td style="text-align: left">65,537</td><td style="text-align: left">Acme In game items</td></tr>
<tr><td style="text-align: left">723,342</td><td style="text-align: left">CryptoKitties v8</td></tr>
</tbody></table>
</div>
<p>The template ID may also set one or more feature flags to indicate that the contract is:</p>
<ul>
<li>Experimental, or in testing phase (bit 48).</li>
<li>Confidential. The definition of confidential assets and their implementation had not been finalized at the time of writing.</li>
</ul>
<p>Wallets/client apps SHOULD have settings to allow, or otherwise completely ignore, asset types on the network that have
certain feature flags enabled. For instance, most consumer wallets should never interact with templates that have the
“Beta mode” bit set. Only developers' wallets should ever even see that such assets exist.</p>
<h4 id="asset-expiry"><a class="header" href="#asset-expiry">Asset Expiry</a></h4>
<p>Asset issuers can set a future expiry date or block height, after which the asset will expire and nodes will be free to
expunge any/all state relating to the asset from memory after a fixed grace period. The grace period is to allow
interested parties (e.g. the issuer) to take a snapshot of the final state of the contract if they wish (e.g. proving
that you had a ticket for that epic World Cup final game, even after the asset no longer exists on the DAN).</p>
<p>Nodes will publish a final checkpoint on the base layer soon after expiry and before purging an asset.</p>
<p>The expiry_date is a Unix epoch, representing the number of seconds since 1 January 1970 00:00:00 UTC if the value is
greater than 1,500,000,000; or a block height if it is less than that value (with 1 min blocks this scheme is valid
until the year 4870).</p>
<p>Expiry times should not be considered exact, since nodes don’t share the same clocks and block heights, and time proxies
become more inaccurate the further out you go (since height in the future is dependent on hash rate).</p>
<h3 id="signature-validation"><a class="header" href="#signature-validation">Signature Validation</a></h3>
<p>Validator nodes will verify the <code>creator_sig</code> for every <code>create_asset</code> instruction before propagating the instruction to
the network. The process is as follows:</p>
<ol>
<li>
<p>The VN MUST calculate the metadata hash by hashing the canonical representation of all the data in the first three
sections of the <code>create_asset</code> instruction.</p>
</li>
<li>
<p>The VN MUST compare this calculated value to the value given in the <code>metadata_hash</code> field. If they do not match, the 
VN MUST drop
the instruction and STOP.</p>
</li>
<li>
<p>The VN MUST calculate the RAID ID from the <code>fqdn</code> and <code>issuer</code> fields as specified in <a href="RFC-0301_NamespaceRegistration.html">RFC-0301</a>.</p>
</li>
<li>
<p>The VN MUST compare the calculated RAID ID with the value given in the <code>raid_id</code> field. If they do not match, the VN 
MUST drop
the instruction and STOP.</p>
</li>
<li>
<p>If the <code>fqdn</code> is `&quot;No FQDN&quot;, then skip to step 9.</p>
</li>
<li>
<p>The VN MUST Look up the OpenAlias TXT record at the domain given in <code>fqdn</code>. If the record  does not exist, then the 
VN MUST
drop the instruction and STOP.</p>
</li>
<li>
<p>The VN MUST check that each of the public key and RAID ID in the TXT record match the values in the <code>create_asset</code>
instruction. If any values do not match, the VN MUST then drop the instruction and STOP.</p>
</li>
<li>
<p>The VN MUST validate the registration signature in the TXT record, using the TXT record's nonce, the issuer's public
key and the RAID ID. If the signature does not verify, the VN MUST drop the instruction and STOP.</p>
</li>
<li>
<p>The VN MUST validate the signature in the <code>creator_sig</code> field against the challenge built up from the issuer's public
key, the nonce given in <code>public_nonce</code> field, the <code>raid_id</code> field and the <code>metadata_hash</code> field.</p>
</li>
</ol>
<p>If step 9 passes, then the VN has proven that the <code>create_asset</code> contains a valid RAID ID, and that if a non-default
FQDN was provided, the owner of that domain provided the <code>create_asset</code> instruction. In this case, the VN SHOULD
propagate the instruction to the network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0312danspecification"><a class="header" href="#rfc-0312danspecification">RFC-0312/DANSpecification</a></h1>
<h2 id="high-level-digital-asset-network-specification"><a class="header" href="#high-level-digital-asset-network-specification">High level Digital Asset Network Specification</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-56"><a class="header" href="#licence-56">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1 id="language-59"><a class="header" href="#language-59">Language</a></h1>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h1 id="disclaimer-59"><a class="header" href="#disclaimer-59">Disclaimer</a></h1>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h1 id="goals-58"><a class="header" href="#goals-58">Goals</a></h1>
<p>This document describes the high-level, or informal specification for how digital assets are created, managed, secured,
and wound- down on the Tari digital asset network (DAN).</p>
<p>The document covers, among other things:</p>
<ul>
<li>The relationship of side-chains to digital assets and contract,</li>
<li>Required characteristics of side-chains,</li>
<li>Peg-in and peg-out mechanisms,</li>
<li>Digital asset template minimum requirements,</li>
<li>Validator node requirements,</li>
<li>Checkpoint and refund mechanisms,</li>
<li>Failure mode strategies.</li>
</ul>
<p>This RFC covers a lot of ground. Therefore the intent is not to provide a detailed, code-ready specification for the
entire DAN infrastructure; those are left to other RFCs; but to establish a foundation onto which the rest of the DAN
specifications can be built.</p>
<p>This RFC supersedes and deprecates several older RFCs:</p>
<ul>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: Digital Assets Network</a></li>
<li><a href="RFCD-0301_NamespaceRegistration.html">RFCD-0301: Namespace Registration</a></li>
<li><a href="RFCD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
<li><a href="RFCD-0304_VNCommittees.html">RFCD-0304: Validator Node committee selection</a></li>
<li><a href="RFCD-0345_AssetLifeCycle.html">RFCD-0345: Asset Life cycle</a></li>
</ul>
<p>Several RFC documents are in the process of being revised in order to fit into this proposed framework:</p>
<ul>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: The Digital Assets Network</a></li>
<li><a href="RFCD-0340_VNConsensusOverview.html">RFCD-0340: Validator Node Consensus</a></li>
</ul>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>There are many ways to skin a cat. The philosophy guiding the approach in the RFC is one that permits scaling of the
network to handle in the region of <strong>1 billion messages per day</strong> (network-wide) and
<strong>1 million digital assets</strong> with <strong>near real-time user experience</strong> on asset state retrieval, updating and transfer, on
a sufficiently decentralised and private basis.</p>
<p>The definition of <em>sufficient</em> here is subjective, and part of the design philosophy of Tari is that we leave it up to
the user to determine what that means, keeping in mind that there is always a trade-off between decentralisation,
performance, and cost.</p>
<p>For some assets, decentralisation and censorship resistance will be paramount, and users will be willing to live with a
more laggy experience. Gamers in a Web 3.0-MMORPG on the other hand, want cheap, fast transactions with verifiable
ownership, and therefore will generally need to sacrifice decentralisation for that.</p>
<p>The goal of the DAN is for asset issuers to be able to configure the side-chain for their project to suit their
particular needs.</p>
<h1 id="description-38"><a class="header" href="#description-38">Description</a></h1>
<p>There are several key actors that participate in Tari Digital Asset Network:</p>
<ul>
<li>A tari [contract] is a piece of code that establishes the relationship and rules of engagement between one or more
digital assets. This includes ownership rules, transfer rules and state change rules.</li>
<li>The <a href="RFCD-0312_DANHighLevelSpecification.html#asset_issuer">Asset issuer</a> is the entity that defines a contract and brings it into existence.</li>
<li><a href="RFCD-0312_DANHighLevelSpecification.html#the-role-of-validator-nodes">Validator node</a>s manage the contract on behalf of the asset issuer by executing instructions on a Tari <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a>.</li>
<li>[Users] interact with contracts and may own, transfer or execute state change instructions against the contract by
submitting instructions via the Tari <a href="RFC-0172_PeerToPeerMessagingProtocol.html">comms network</a> to the relevant validator node committee.</li>
</ul>
<h2 id="the-role-of-the-layer-1-base-chain"><a class="header" href="#the-role-of-the-layer-1-base-chain">The role of the Layer 1 base chain</a></h2>
<p>The Tari Overview RFC describes <a href="RFC-0001_overview.html#the-role-of-the-base-layer">the role of the base layer</a>. In summary, the base layer</p>
<ul>
<li>maintains the integrity of the Tari cryptocurrency token, and</li>
<li>maintains registers of the side-chains,</li>
<li>and facilitates the version control and reproducible execution environments for contract templates.</li>
</ul>
<p>It does not know about or care about what happens in the side chains as long as the Tari consensus, side-chain and
validator node rules are kept.</p>
<p>It is helpful to view the base layer blocks and transactions as an immutable, append-only document which allows us to
model the tables and foreign relationships of a traditional database. The rows are represented by the UTXOs and we can
infer which table the row belongs to by inspecting the output features of the UTXO.</p>
<p>Whereas a standard RDMS manages access control and permissions via policy, we must also take care to ensure proper
access control via consensus rules, lock scripts, covenants, signatures and kernels.</p>
<h2 id="top-level-requirements-for-side-chains"><a class="header" href="#top-level-requirements-for-side-chains">Top-level requirements for side-chains</a></h2>
<p>The guiding principle of Tari contracts are that they are managed on a dedicated side-chain. One side-chain, one
contract. Other RFCs will discuss ways to overcome the apparent limitations this rule implies, including inter-contract
interactions and asset hibernation.</p>
<h3 id="asset-issuer---validator-node-agreements"><a class="header" href="#asset-issuer---validator-node-agreements">Asset issuer &lt;-&gt; Validator node agreements</a></h3>
<p>The fundamental relationship of Tari contracts is between the asset issuer and the validator node(s) that manage the
contract's side-chain. This relationship is somewhat adversarial by nature: Issuers want high quality service at the
lowest possible price; Validators want to be compensated for their services and under some circumstances may want to
cheat on contracts for their own gain.</p>
<p>Tari seeks to address this in the lightest way possible by requiring the absolute minimum in terms of base layer
governance while providing options for side-chain governance that suits the needs of the parties involved.</p>
<p>For example, an asset issuer that wants to issue a highly decentralised, censorship-resistant <em>high-value</em> contract on a
side-chain would likely seek to recruit dozens of validator nodes and run a proof-of-stake consensus model with a
confidential asset specification.</p>
<p>In contrast, an asset issuer that wants to participate in the Tari ecosystem, but is not interested in decentralisation
could run their own validator node; with no consensus, or staking, or validator node compensation contracts -- these
would be unnecessary; and provide a high performance, real-time contract. Games with realistic embedded economics would
follow this model, as well as early on in the transition from tradFi to deFi.</p>
<p>A set of Validator nodes that manage the same contract is called the <em>validator node committee</em> for the contract.</p>
<h3 id="the-asset-issuer"><a class="header" href="#the-asset-issuer">The Asset issuer</a></h3>
<p>The asset issuer, otherwise known as the contract owner, is the entity that publishes
a <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-definition-transaction">contract definition transaction</a>.</p>
<p>The <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-definition-transaction">contract definition transaction</a> defines the &quot;what&quot; of the contract. It specifies the complete specification of the
code that will run, the execution environment it must be run under, as well as the initialisation parameters for all the
contract template constructors.</p>
<p>The contract definition allows validator nodes to be confident that they are running a byte-for-byte equivalent code
base with the exact same interpretation of that code as its peers without having to collaborate with any other nodes to
confirm this.</p>
<p>In most cases, a contract definition will comprise several well-reviewed and secure <em>templates</em> to define the operation
of the contract.</p>
<p>The asset issuer will also draft and publish the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a>. The constitution defines <em>how</em> a contract is
run, and defines the conditions under which the terms of the constitution can be changed.</p>
<h3 id="the-constitution-committee"><a class="header" href="#the-constitution-committee">The Constitution Committee</a></h3>
<p>The <a href="RFCD-0312_DANHighLevelSpecification.html#asset_issuer">asset issuer</a> will in the creation of the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a> nominate a key or set of keys to &quot;own&quot; the asset
and control all things related to <em>how</em> the contract is run. They are known as the <a href="RFCD-0312_DANHighLevelSpecification.html#constitution_committee">constitution committee</a> (CC)</p>
<p>The CC has the power to change anything inside of the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a>. In many cases, the CC will simply be the <a href="RFCD-0312_DANHighLevelSpecification.html#asset_issuer">asset issuer</a>.
However, allowing the CC to differ from the asset issuer enables a number of other use-cases 
such as a DAO, a nominated list of keys, etc.</p>
<h3 id="the-role-of-validator-nodes"><a class="header" href="#the-role-of-validator-nodes">The role of validator nodes</a></h3>
<ul>
<li>Validator nodes SHOULD diligently and accurately <a href="RFCD-0312_DANHighLevelSpecification.html#validator-node-instructions">process all instructions</a> related to the contract.</li>
<li>The committee SHOULD reach consensus on every instruction related to the contract. This specification does NOT dictate
how this consensus is reached. If the committee contains one member, then consensus is trivial, and does not require
any complicated consensus algorithms. A standard web-based application stack will suffice in most cases. Larger
committees can choose from any manner of consensus algorithms, including PBFT, HotStuff, proof-of-stake or
proof-of-work.</li>
</ul>
<p><strong>OPEN QUESTION</strong>: The asset issuer has no in-band way to know how the VNs are reaching consensus. Even out-of-band,
there could be one server and a bunch of proxies that merely relay messages. Only proof of work (because it is
permissionless) and proof of stake (maybe?) work around this problem.</p>
<ul>
<li>TODO - research how Polygon and other multichain networks solve this problem.</li>
</ul>
<p>The Tari base layer does not get involved in governance issues beyond those mechanics that are defined in contract
constitutions. However, many asset issuers may want to include mechanisms that, for example, require a Tari stake to act
as a validator node. Validator nodes may also desire a compensation mechanism so that they get paid for managing the
contract. These mechanisms form part of the contract itself, and are opaque to the machinery of the base layer,
side-chain and associated peg transactions.</p>
<p>Validator nodes MAY have to stake Tari for each contract they validate. Asset issuers will determine the nature and
amount of stake required as part of the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a>. The contract stake is variable on a
contract-to-contract basis so that an efficient market between asset issuers and validator nodes can develop. This
market is not defined on the Tari blockchain at all and would be best implemented as a DAO on the DAN itself.</p>
<p>Similarly, it has been suggested in the past that Validator Nodes should post hardware benchmarks when registering. The
problem with this requirement is that it is fairly trivial to game. We cannot enforce that the machine that posted the
benchmark is the same as the one that is running validations.</p>
<p>A better approach is to leave this to the market. A reputation contract can be built, on Tari, of course, that
periodically and randomly asks Validator Nodes to perform cryptographically signed benchmarks in exchange for
performance certificates. Nodes can voluntarily sign up for such a service and use the certificates as a form of
credential. Nodes that do not sign up may have trouble finding contracts to validate and might have to lower their price
to get work.</p>
<p>Tari contracts are template-based, and so many contracts may wish to include <a href="RFCD-0312_DANHighLevelSpecification.html#contract-templates">contract template</a>s that add any or all of
the following governance functions to the side-chain contract:</p>
<ul>
<li>Validator node staking.</li>
<li>Validator node slashing.</li>
<li>A Validator node proof-of-participation certificate template. Poorly performing validator nodes may receive reduced
compensation, be fined, or even ejected from the committee at a checkpoint.</li>
<li>A fee model template. The asset issuer could provide a guaranteed pool of funds from which the committee will be paid
at every checkpoint.</li>
</ul>
<p>This list is far from complete, but should convey the idea that:</p>
<ul>
<li>Tari contracts SHOULD be highly modular and composable, with each template performing exactly ONE highly specific
task, and doing it very well.</li>
<li>The base layer and peg transactions know the absolute minimum about the assets on the chain. However, they provide all
the information necessary for the contract templates and side-chains to function efficiently.</li>
</ul>
<h2 id="the-contract-lifecycle"><a class="header" href="#the-contract-lifecycle">The contract lifecycle</a></h2>
<p>Every contract MUST be governed by one, and only one, Tari <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a>. A contract MAY define one or more digital
assets. This contract can be very simple or highly complex.</p>
<p>The lifecycle of a contract proceeds via these steps:</p>
<ol>
<li>The asset issuer publishes a <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-definition-transaction">contract definition transaction</a>.</li>
<li>The asset issuer publishes a <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a> transaction.</li>
<li>Once this transaction is published, we enter the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a>.</li>
<li>Each validator node that will be managing the contract publishes a <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction">contract acceptance transaction</a>. The group of
validator nodes that manages the contract is called the Validator Node Committee (VNC).</li>
<li>Once the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> has expired, the <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> begins.</li>
<li>The VNC jointly publishes a <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> transaction.</li>
<li>At this point, the contract is considered live, and users can safely interact with the contract on the side-chain.
Technically, users do not have to wait until this point. The VNC COULD start processing transactions
<em>optimistically</em> as soon as the constitution is published, and print the zero-th and first checkpoints once they are
mined on the base layer. However, this is not generally recommended.</li>
<li>The VNC periodically publishes a <a href="RFCD-0312_DANHighLevelSpecification.html#checkpoint-transactions">checkpoint</a> transaction.</li>
<li>Failure to do so can lead to the contract being <a href="RFCD-0312_DANHighLevelSpecification.html#contract-abandonment" title="Contract abandonment">abandoned</a>.</li>
<li>The CC MAY shut the contract down by publishing a <a href="RFCD-0312_DANHighLevelSpecification.html#contract-dissolution" title="Contract dissolution">dissolution</a> transaction.</li>
</ol>
<p>The following sections will discuss each of these steps in more detail.</p>
<h2 id="contract-instantiation"><a class="header" href="#contract-instantiation">Contract instantiation</a></h2>
<p>Steps 1 - 6 in the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-lifecycle" title="The contract lifecycle">contract lifecycle</a> are part of the <a href="RFCD-0312_DANHighLevelSpecification.html#contract-instantiation">contract instantiation</a> process. Instantiation is a multi-step
process and is ideally represented as a finite-state machine that reacts to transactions published on chain that contain
outputs containing specific output features. The combination of output features and FSM allows nodes to accurately track
the progress of potentially thousands of contracts in a safe and decentralised manner.</p>
<h3 id="the-contract-definition-transaction"><a class="header" href="#the-contract-definition-transaction">The contract definition transaction</a></h3>
<p>It bears repeating that every contract is governed by one, and only one, Tari <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a>. A contract MAY define one or
more digital assets. These assets' behaviour is captured in templates and are highly composable. This allows the
contract to be very simple or highly complex, and be handled with the same contract handling machinery.</p>
<note :tip>
The contract definition transaction defines the "what" of the digital asset set that will be created.
</note>
<ul>
<li>Every contract MUST be registered on the base layer.</li>
<li>Contracts MUST be registered by publishing a <code>contract definition</code> transaction.</li>
<li>Asset issuers MUST stake a small amount of Tari in order to publish a new contract.</li>
<li>Exactly ONE output MUST have a <code>ContractSpecification</code> output feature.</li>
<li>The contract specification UTXO MUST include a covenant that only permits it to be spent to a
new <code>ContractSpecification</code> UTXO or as an unencumbered UTXO in
a <code>ContractDeregistration</code> transaction.</li>
</ul>
<p>Note: The latter is desirable because it tidies up the UTXO set. But this transaction MUST NOT be published before
contract has been dissolved (see [contract dissolution]).</p>
<ul>
<li>The  <code>ContractSpecification</code> UTXO MUST hold at least the <code>MINIMUM_OWNER_COLLATERAL</code> in Tari. The amount is hard-coded
into consensus rules and is a nominal amount to prevent spam, and encourages asset owners to tidy up after themselves
if a contract winds down. Initially, <code>MINIMUM_OWNER_COLLATERAL</code> is set at 200 Tari, but MAY be changed across network
upgrades.</li>
</ul>
<p><strong>Implementation note:</strong>
Assuming the collateral is represented by the UTXO commitment $C = kG + vH$, the minimum requirement is verified by
having the range-proof commit to $(k, v - v_\mathrm{min})$ rather than the usual $(k, v)$. Note that this change
requires us to modify the
<code>TransactionOutput</code> definition to include a <code>minimum_value_commitment</code> field, defaulting to zero, to capture this extra
information.</p>
<ul>
<li>The <code>ContractSpecification</code>UTXO MUST also include:
<ul>
<li>The contract description,</li>
<li>the asset issuer record</li>
<li>the contract definition, as described below.</li>
</ul>
</li>
</ul>
<h4 id="contract-description"><a class="header" href="#contract-description">Contract description</a></h4>
<p>The contract description is a simple metadata record that provides context for the contract. The record includes:</p>
<ul>
<li>The contract id -- <code>&lt;u256 hash&gt;</code>. This is immutable for the life of the contract and is calculated as
<code>H(contract_name || contract specification hash || Initial data hash || Runtime data hash)</code>.</li>
<li>A contract name -- <code>utf-8 char[32]</code>(UTF-8 string) 32 bytes. This is for informational purposes only, so it shouldn't
be too long, but not too short that it's not useful (this isn't DOS 3.1 after all). 32 bytes is the same length as a
public key or hash, so feels like a reasonable compromise.</li>
</ul>
<h4 id="asset-issuer-record"><a class="header" href="#asset-issuer-record">Asset issuer record</a></h4>
<p>The asset issuer record identifies the <a href="RFCD-0312_DANHighLevelSpecification.html#asset_issuer">asset issuer</a> as the initial owner and publisher of the contract. The following
fields are required:</p>
<ul>
<li>the asset issuer's public key, also known as the owner public key, <code>&lt;PublicKey&gt;</code>.</li>
</ul>
<h4 id="contract-definition"><a class="header" href="#contract-definition">Contract definition</a></h4>
<p>The following information must be captured as part of the <code>contract definition</code> in the <code>ContractSpecification</code>UTXO of
the contract definition transaction:</p>
<ul>
<li>the full contract specification in a compact serialised format,</li>
<li>the initialisation arguments for the contract, in a compact serialisation format,</li>
<li>the runtime specification.</li>
</ul>
<p>This data tells validator nodes <em>exactly</em> what code will be running, and the data needed to initialise that code.</p>
<p>Asset templates will have a strictly defined interface that includes a constructor, or initialisation method. The
parameters that these constructors accept is what determines the initial data.</p>
<p>The runtime specification includes, for example, the version of the runtime and any meta-parameters that the runtime
accepts.</p>
<p>These three pieces of data are <em>necessary</em> AND <em>sufficient</em> to enable <em>any</em> validator node to start running the contract
and execute instructions on it, knowing that any other validator node running the same contract will determine <em>exactly</em>
the same state changes for every instruction it receives.</p>
<h3 id="the-contract-constitution"><a class="header" href="#the-contract-constitution">The contract constitution</a></h3>
<p>Following the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-definition-transaction">contract definition transaction</a>,the asset issuer MUST publish a <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a> transaction in
order for the contract initialisation process to proceed.</p>
<p>This transaction defines the &quot;how&quot; and &quot;who&quot; of the digital asset's management.</p>
<p>It contains the &quot;contract terms&quot; for the management of the contract.</p>
<p>Exactly ONE UTXO MUST include the <code>ContractConstitution</code> output feature flag. The contract constitution UTXO contains
the following:</p>
<ul>
<li>It MUST include the contract id. The contract definition transaction SHOULD be mined prior to publication of the
constitution transaction, but it strictly is not necessary if VNs are able to access the contract specification in
some other way.</li>
<li>It MUST include a list of public keys of the proposed <a href="RFCD-0312_DANHighLevelSpecification.html#cc">CC</a>;</li>
<li>It MUST include a list of public keys of the proposed VNC;</li>
<li>It MUST include an expiry timestamp before which all VNs must sign and agree to these terms (the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a>);</li>
<li>It MAY include quorum conditions for acceptance of this proposal (default to 100% of VN signatures required);</li>
<li>If the conditions will unequivocally pass, the acceptance period MAY be shortcut.</li>
<li>The UTXO MUST only be spendable by a multisig of the quorum of VNs performing <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a> initialisation. (e.g. a 3
of 5 threshold signature).</li>
<li>It MUST include the side-chain metadata record:
<ul>
<li>The consensus algorithm to be used</li>
<li>checkpoint quorum requirements</li>
</ul>
</li>
<li>It MUST include the following Checkpoint Parameters Record
<ul>
<li>minimum checkpoint frequency,</li>
<li>minimum quarantine period.</li>
</ul>
</li>
<li>It MAY include a <code>RequirementsForConstitutionChange</code> record. It omitted, the checkpoint parameters and side-chain
metadata records are immutable via covenant.
<ul>
<li>How and when the Constitution UTXO can change.</li>
<li>Quorum required by the <a href="RFCD-0312_DANHighLevelSpecification.html#cc">CC</a>,</li>
<li>Proposal period.</li>
<li>How and when the Checkpoint Parameters record can change.</li>
<li>How and when the side-chain metadata record can change.</li>
</ul>
</li>
<li>It SHOULD include a list of emergency public keys that have signing power if the contract is <a href="RFCD-0312_DANHighLevelSpecification.html#contract-abandonment" title="Contract abandonment">abandoned</a>.</li>
</ul>
<p>If both the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> and <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> elapses without quorum, the CC MAY spend
the<code>ContractConstitution</code> UTXO back to himself to recover his funds.</p>
<p>In this case, the asset issuer MAY try and publish a new contract constitution.</p>
<h4 id="contract-constitutions-for-proof-of-work-side-chains"><a class="header" href="#contract-constitutions-for-proof-of-work-side-chains">Contract constitutions for proof-of-work side-chains</a></h4>
<p>Miners are joining and leaving PoW chains all the time. It is impractical to require a full constitution change cycle to
execute every time this happens, the chain would never make progress!</p>
<p>To work around this, the constitution actually defines a set of proxy- or observer-nodes that perform the role of
running a full node on the side chain and publishing the required [checkpoint transaction]s onto the Tari base chain.
The observer node(s) are then technically the VNC. Issuers could place additional safeguards in the contract definition
and constitution to keep the VNC honest. Conceivably, even Monero or Bitcoin itself could be attached as a side-chain to
Tari in this manner.</p>
<h3 id="the-contract-acceptance-transaction"><a class="header" href="#the-contract-acceptance-transaction">The contract acceptance transaction</a></h3>
<p>The entities that are nominated as members of a VNC for a new contract MUST cryptographically [acknowledge and agree] to
manage the contract. This happens by virtue of the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction">contract acceptance transaction</a>s.</p>
<ul>
<li>Each potential VNC member MUST publish a <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction">contract acceptance transaction</a> committing the required stake. The UTXO is
also an explicit agreement to manage the contract.</li>
<li>Exactly ONE UTXO MUST have the output feature <code>ContractAcceptance</code>.</li>
<li>The UTXO MUST contain a time lock, that prevents the VN spending the UTXO before the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a>
<ul>
<li><a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> has lapsed.</li>
</ul>
</li>
<li>The output MUST include the contract id.</li>
</ul>
<p>A contract acceptance transaction MUST be rejected if</p>
<ul>
<li>contract id does not exist (the contract definition has not been mined)</li>
<li>the signing public key was not nominated in the relevant contract constitution</li>
<li>the deposit is insufficient</li>
</ul>
<h3 id="the-side-chain-initialization-period"><a class="header" href="#the-side-chain-initialization-period">The side-chain initialization period</a></h3>
<p>Once the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> has expired, <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> begins.</p>
<p>At this point, VNs that have accepted the contract must</p>
<ul>
<li>allocate resources</li>
<li>Setup whatever is needed to run the contract</li>
<li>Set up consensus with their peer VNs (e.g. hotstuff)</li>
<li>Initialise the contract and run the constructors</li>
<li>Reach consensus on the initial state.</li>
<li>Prepare the <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> transaction.</li>
</ul>
<p>all before the <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> period expires.</p>
<h3 id="the-side-chain-initialization-transaction"><a class="header" href="#the-side-chain-initialization-transaction">The side-chain initialization transaction</a></h3>
<p>Side-chains MUST be marked as initiated by virtue of a <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> transaction.</p>
<ul>
<li>Once the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> has expired, <a href="RFCD-0312_DANHighLevelSpecification.html#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> begins.</li>
<li>At this point, there MUST be a quorum of acceptance transactions from validator nodes.</li>
<li>The validator node committee MUST collaborate to produce, sign and broadcast the initialisation transaction by
spending the initial Contract Constitution transaction into the zero-th <a href="RFCD-0312_DANHighLevelSpecification.html#checkpoint-transactions">checkpoint</a> transaction.</li>
<li>The initialisation transaction MUST spend all the [contract acceptance transactions] for the contract.</li>
<li>Base layer consensus MUST confirm that the spending rules and covenants have been observed, and that the checkpoint
contains the correct covenants and output flags.</li>
<li>There is a minimum [side-chain deposit] that MUST be included in the peg-in UTXO. A single aggregated UTXO containing
at least $$ m D $$ Tari, where <em>m</em> is the number of VNs and <em>D</em> is the deposit required.</li>
<li>This transaction also acts as the zero-th checkpoint for the contract. As such, it requires all the checkpoint
information.</li>
<li>The state commitment is the merklish root of the state after running the code initialisation using the [initial data]
provided in the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-definition-transaction">contract definition transaction</a>.</li>
</ul>
<h2 id="contract-execution"><a class="header" href="#contract-execution">Contract execution</a></h2>
<p>The goal of the DAN is to allow many, if not millions, of instructions to be processed on the side-chain with little or
no impact on the size of the base layer.</p>
<p>The only requirements that the base layer will enforce during contract execution are those specified in the contract
constitution.</p>
<p>The base layer will check and enforce these requirements at <a href="RFCD-0312_DANHighLevelSpecification.html#checkpoint-transactions">checkpoint</a>s.</p>
<h3 id="checkpoint-transactions"><a class="header" href="#checkpoint-transactions">Checkpoint transactions</a></h3>
<p>The roles of the checkpoint transaction:</p>
<ul>
<li>Present proof of liveness</li>
<li>Allows authorised entities to make changes to the committee</li>
<li>Summarise contract state</li>
<li>Summarise contract logs / events</li>
</ul>
<p><strong>Implementation Note:</strong> In the discussion of Tari account contract templates below, we need a mechanism for proving
that the side-chain state corresponds to what someone is claiming with respect to a valid base layer transaction. But
since our policy is one that the base layer never knows anything about what goes on in side-chains, this poses a
challenge. One possible solution to this would be to add a <code>MERKLE_PROOF</code> opcode to TariScript that could validate a
base layer transaction based on a checkpoint merkle root combined with a merkle proof that a VNC has given to a user.</p>
<p>Validator node committees MUST periodically sign and broadcast a <a href="RFCD-0312_DANHighLevelSpecification.html#checkpoint-transactions">checkpoint</a> transaction.</p>
<p>The transaction signature MUST satisfy the requirements laid out for checkpoint transactions defined in
the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a>.</p>
<ul>
<li>The checkpoint transaction MUST spend the previous checkpoint transaction for this contract. Consensus will guarantee
that only one checkpoint UTXO exists for every contract on the base layer. This is guaranteed by virtue of a covenant.
The contract id must equal the contract id of the checkpoint being spent.</li>
<li>The checkpoint transaction MUST contain exactly ONE UTXO with the <code>Checkpoint</code> output feature.</li>
</ul>
<p>The <code>Checkpoint</code>output feature adheres to the following:</p>
<ul>
<li>It MUST reference the contract id.</li>
<li>It MUST contain a commitment to the current contract state. This is typically some sort of Merklish root.</li>
<li>It MAY have a URI to off-chain state or merkle tree</li>
<li>It MUST contain a checkpoint number, strictly increasing by 1 from the previous checkpoint.</li>
<li>It MUST strictly copy over the constitution rules from the previous checkpoint, OR</li>
<li>It MUST contain valid signatures according to the constitution allowing the rules to be changed, along with the
relevant parts of the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a> change pipeline.</li>
</ul>
<p>If a valid checkpoint is not posted within the maximum allowed timeframe, the contract is <a href="RFCD-0312_DANHighLevelSpecification.html#contract-abandonment" title="Contract abandonment">abandoned</a>. This COULD lead
to penalties and stake slashing if enabled within the contract specification.</p>
<h3 id="changes-to-the-constitution"><a class="header" href="#changes-to-the-constitution">Changes to the constitution</a></h3>
<p>Changes to the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a> can happen at any time through the [constitution amendment] process. This also applies to changes to the VNC. Only the <a href="RFCD-0312_DANHighLevelSpecification.html#cc">CC</a> may 
make changes to the<a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a>.</p>
<ul>
<li>The rules over how members are added or removed are defined in the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a>.</li>
<li>At the minimum, there's a proposal step, a validation step, an acceptance step, and an activation step. Therefore
changes take place over at least a 4-checkpoint time span.</li>
<li>If a VN leaves a committee their [side-chain deposit] MAY be refunded to them.</li>
<li>If a new VN joins the committee they must provide the [side-chain deposit] at their activation step.</li>
<li>In the proposal step, any authorised <a href="RFCD-0312_DANHighLevelSpecification.html#cc">CC</a> may make a change proposal, within the limits defined by the change rules in the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a></li>
<li>Before activation, VNC members MAY submit an acceptance transaction that registers their willingness to validate the contract. If no acceptance is submitted within the <code>acceptance_period</code> the validator is assumed to be uninterested in running the contract and will not form part of the finalized contract committee. </li>
</ul>
<h3 id="contract-abandonment"><a class="header" href="#contract-abandonment">Contract abandonment</a></h3>
<p>This is the state where VNC and the Asset Owner(s) have abandoned the contract.</p>
<p>If a contract misses one or more checkpoints, nodes can mark it as <code>VNC abandoned</code>. This is not formally marked on the
blockchain, (since something was NOT done on-chain), but nodes will be able to test for abandoned state.</p>
<p>If a contract has not seen any new constitution amendment for a checkpoint period after it has been marked as <code>VNC abandoned</code>, 
it is marked as <code>abandoned</code>. </p>
<p>The <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a> SHOULD provide a set of emergency pubkeys that are able to</p>
<ul>
<li>perform a peg-out</li>
<li>do all governancy things</li>
<li>rescue funds and state</li>
</ul>
<p>Implementation note: We could add an <code>IS_ABANDONED</code> opcode (sugar for height since last checkpoint) to test for
abandonment.</p>
<p>If a contract is abandoned, the emergency key MAY spend the last checkpoint into a <code>QUARANTINED</code> state. A contract MUST
stay in <code>QUARANTINED</code> state for at least one month.</p>
<p>The contract can leave the quarantined state in one of two ways:</p>
<ul>
<li>
<p>The current VNC MAY reinstate the contract operation by publishing the missing checkpoint(s), and committing to any
remedial actions as specified in the <a href="RFCD-0312_DANHighLevelSpecification.html#the-contract-constitution">contract constitution</a>, e.g. paying a fine, etc.</p>
</li>
<li>
<p>The quarantine period lapses, at which point the emergency key holder(s) have full administrative power over the
contract. This means that they have to issue a new constitution to assign a new VNC, peg-out and shut down the contract, or whatever.</p>
<p><strong>OPEN QUESTION</strong>:  Do we want to allow an additional fall back of everyone spend after years in <code>abandoned</code> state?</p>
</li>
</ul>
<h2 id="contract-dissolution"><a class="header" href="#contract-dissolution">Contract dissolution</a></h2>
<h2 id="contract-templates"><a class="header" href="#contract-templates">Contract templates</a></h2>
<h3 id="template-code-registration-and-versioning"><a class="header" href="#template-code-registration-and-versioning">Template code registration and versioning</a></h3>
<p>The code template implementations MUST be registered on the base layer.</p>
<p>The reason for this is that it allows Validator Nodes to know unequivocally that they are all running the same code and
can expect the same output for the same input.</p>
<p>Template registration also allows us to implement a secure and trust-minimised upgrade mechanism for templates.</p>
<p>Potentially, we could even introduce a mechanism wherein template developers get paid for people using their template.</p>
<p>Template registration UTXO would contain:</p>
<ul>
<li>A link to the code (git commit or IPFS)</li>
<li>The type of code (source or binary blob)</li>
<li>A hash of the source code / blob</li>
<li>Version info.</li>
<li>[Execution engine] requirements (similar to solc pragma)</li>
</ul>
<p>There's a clear upgrade path, since there's a code-chain from one version of a contract template to the next.</p>
<h2 id="user-account-balance-representation-in-side-chains"><a class="header" href="#user-account-balance-representation-in-side-chains">User account balance representation in side-chains</a></h2>
<p>Tari uses the UTXO model in its ledger accounting. On the other hand Tari side-chains SHOULD use an account-based system
to track balances and state.</p>
<p>The reasons for this are:</p>
<ul>
<li>An account-based approach leads to fewer outputs on peg-out transactions. There is roughly a 1:1 ratio of users to
balances in an account-based system. On the other hand there are O(n) UTXOs in an output-based system where <code>n</code> are
the number of transactions carried out on the side-chain. When a side-chain wants to shut down, they must record a new
output on the base layer for every account or output (as the case may be) that they track in the peg-out transaction(
s). It should be self-evident that account-based systems are far more scalable in the vast majority of use-cases.</li>
<li>Following on from this, Accounts scale better for micro-payment applications, where hundreds or thousands of tiny
payments flow between the same two parties.</li>
<li>Many DAN applications will want to track state (such as NFTs) as well as currency balances. Account-based ledgers make
this type of application far simpler.</li>
</ul>
<h3 id="pedersen-commitments-and-account-based-ledgers"><a class="header" href="#pedersen-commitments-and-account-based-ledgers">Pedersen commitments and account-based ledgers</a></h3>
<p>Standard Pedersen commitments are essentially useless in account-based ledgers.</p>
<p>The reason being that since the spending keys would be common to all transactions involving a given account, it is
trivial to use the accounting rules to cancel out the <code>k.G</code> terms from transactions and to use a pre-image attack to
unblind all the values.</p>
<p>The specific protocol of user accounts in the side-chain is decided by the asset issuer.</p>
<p>Options include:</p>
<h4 id="fully-trusted"><a class="header" href="#fully-trusted">Fully trusted</a></h4>
<p>In this configuration, the side-chain is controlled by a single validator node, perhaps a server running an RDMS. The
validator node has full visibility into the state of the side chain at all times. It may or may not share this state
with the public. If it does not, then the situation is analogous to current Web 2.0 server applications.</p>
<h4 id="decentralised-and-federated"><a class="header" href="#decentralised-and-federated">Decentralised and federated</a></h4>
<p>In this configuration, a distributed set of validator nodes maintain the side-chain state. The set of nodes are fixed.
If consensus between nodes is achieved using a mechanism such as HotStuff BFT, very high throughputs can be achieved.</p>
<h4 id="decentralised-and-censorship-resistant"><a class="header" href="#decentralised-and-censorship-resistant">Decentralised and censorship resistant</a></h4>
<p>In this configuration, the side-chain could itself be a proof-of-work blockchain. This offers maximum decentralisation
and censorship resistance. However, throughput will be lower.</p>
<h4 id="confidentiality"><a class="header" href="#confidentiality">Confidentiality</a></h4>
<p>As mentioned above, Pedersen commitments are not suitable for account-based ledgers. However, the <a href="https://eprint.iacr.org/2019/191.pdf">Zether</a> protocol was
expressly designed to provide confidentiality in a smart-contract context. It can be combined with any of the above
schemes. Zether can also be <a href="https://github.com/ConsenSys/anonymous-zether">extended</a> to provide privacy by including a
ring-signature scheme for transfers.</p>
<h2 id="key-template-discussions"><a class="header" href="#key-template-discussions">Key template discussions</a></h2>
<p>A majority of contracts will want to implement on or more of the following features:</p>
<ul>
<li>A financial bridge from the base layer and user accounts,</li>
<li>A fee or compensation mechanism for the VNC,</li>
<li>Inter-contract communications</li>
</ul>
<p>These are complex topics and there are entire blockchain systems where this functionality is built into the fabric of
the design. Tari’s modular approach naturally means that the functionality will be delegated into templates and
instantiated where necessary and desired by <a href="RFCD-0312_DANHighLevelSpecification.html#asset_issuer">asset issuer</a>s.</p>
<p>This also means that Tari offers additional flexibility for issuers and users while the ecosystem is better positioned
to respond to changes in demand and new smart contract patterns.</p>
<p>For this RFC, we limit the conversation to a very broad description of how the templates could be implemented, but will
leave specifics to RFCs that are more focussed on the topic.</p>
<h3 id="funding-withdrawals-and-deposits"><a class="header" href="#funding-withdrawals-and-deposits">Funding, withdrawals and deposits</a></h3>
<p>Deposits and withdrawals go via a smart contract template using the bridge model.</p>
<h4 id="very-high-level-flow"><a class="header" href="#very-high-level-flow">Very high level flow</a></h4>
<ol>
<li>Send Tari via One-sided payment to an address defined by the template. (Could have a <code>DEPOSIT</code> output feature if
required)</li>
<li>The VNC sees this, and then issues / prints / mints the equivalent value on side-chain according to the side-chain
protocol.</li>
<li>Equivalent coins change hands many times. The account template maintains an accurate balance of all users’ accounts,
with the VNC reaching consensus on value transfer instructions according to the consensus algorithm in force.</li>
<li>A User requests a withdrawal.</li>
<li>The VNC debits the user’s account and &quot;burns&quot; equivalent coins on the side chain.</li>
<li>The VNC broadcasts a standard one-side Tari transaction to the user’s benefit.</li>
<li>Optionally, the template functionality facilitating proofs of reserve, i.e. that locked funds are of equivalent value
to minted funds.</li>
</ol>
<p>Note that this model is not trustless from a base-layer point of view. Users are trusting the side chain, and VNC to not
steal their funds. Therefore one may want to encourage the deployment of PoW or PoS side-chains when executing contracts
that handle large amounts of value.</p>
<h5 id="possible-variants"><a class="header" href="#possible-variants">Possible variants</a></h5>
<ul>
<li>Users deposit and get a refund transaction to hold onto.</li>
<li>The refund tx gets updated every time the balance changes. ala Lightning.</li>
<li>Proof of burn tied to proof of spend.</li>
<li>Atomic swaps to force issue of token on side-chain in (1.) above.</li>
</ul>
<p>We could implement any/all of these variants in different templates.</p>
<h3 id="validator-node-fees"><a class="header" href="#validator-node-fees">Validator node fees</a></h3>
<p>2 Template models:</p>
<ul>
<li>Model A - Centrally funded</li>
<li>Fees are drawn from a single account (typically funded by asset issuer)</li>
<li>Eligible instructions are defined in the template constructor.</li>
<li>Model B - User funded</li>
<li>Requires an account template</li>
<li>Fees are supplied with an instruction</li>
<li>Eligible instructions are defined in the template constructor.</li>
<li>Instructions that are not covered by the model MAY be rejected by the VNC</li>
</ul>
<h3 id="validator-node-instructions"><a class="header" href="#validator-node-instructions">Validator Node Instructions</a></h3>
<p>What does an instruction look like? Note: Solana instructions contain</p>
<ul>
<li>ProgramId</li>
<li>Vec of accounts that the instruction will interact with (plus whether they're mutable and have signer auth)</li>
<li>a blob that the program will deserialise. So, no inherently accessible API</li>
</ul>
<p>Requires:</p>
<ul>
<li>Contract ID</li>
<li>Vec of method calls: (this is different to how Solana does it/ Maybe some discussion on pros&amp;cons is worthwhile. If we
go WASM, the API is available via reflection)
<ul>
<li>Method ID (template::method)</li>
<li>Method arguments</li>
</ul>
</li>
<li>Authorization
<ul>
<li>signed token-based (Macaroons / JWTish)</li>
</ul>
</li>
</ul>
<p>Now the VNs have everything they need to execute the Instruction. They execute the instruction. The update the state
tree. Return of the call is a &quot;diff&quot; of some sort, which gets appended to the &quot;OP Log&quot; document, and the new state root
hash.</p>
<p>The VNC SHOULD reach consensus on this result.</p>
<p>Then you move onto the next instruction.</p>
<ul>
<li>
<p>Where do instructions get submitted?</p>
<ul>
<li>The [peg-in transaction] contains the pubkeys of each member of the VNC; or a checkpoint transaction.</li>
<li>ergo, a client app knows the pubkeys of the VNC at all times.</li>
<li>A client can send an Instruction to ANY VNC member via comms</li>
</ul>
</li>
<li>
<p>VNs MUST maintain a mempool of instructions</p>
</li>
<li>
<p>VNs SHOULD share instructions with its peer committee members</p>
</li>
<li>
<p>Ordering of instructions.</p>
<ul>
<li>(In Hotstuff) The leader selects the next instruction(s) to run.</li>
<li>The leader MAY batch instructions in a single consensus round.</li>
<li>For account-based side-chains, Instructions SHOULD contain a nonce??? (Might not be workable)</li>
<li>For account-based side-chains, Instructions COULD have a dependency field that forces ordering of selected
instructions.
<ul>
<li>Potentially, an accumulator is a way to do this. An instruction provides a list of instruction hashes, and the
instruction can be included ONLY IF ALL hashes have been recorded.</li>
</ul>
</li>
<li>Instructions MUST not be executed more than once, even if resubmitted. Suggests some sort of salt/entropy/nonce so
that the same execution steps could be run without being interpreted as the <em>same</em> instruction. (e.g.
micro-transactions).</li>
</ul>
</li>
</ul>
<h3 id="inter-contract-interactions"><a class="header" href="#inter-contract-interactions">Inter-contract interactions</a></h3>
<p>Possible routes for this:</p>
<h4 id="atomic-transactions"><a class="header" href="#atomic-transactions">Atomic transactions</a></h4>
<ul>
<li>Provide a proof that a conditional instruction on one chain has been executed,</li>
<li>Execute on this chain, which reveals some fact that the other chain can use to finalise the instruction on the other
chain.</li>
<li>Rolls back if 2nd party does not follow through.</li>
</ul>
<p>Advantages:</p>
<ul>
<li>Does work.</li>
</ul>
<p>Disadvantages</p>
<ul>
<li>Slow</li>
<li>Need to get data from other chain.</li>
<li>Might hold up entire chain for extended periods.</li>
</ul>
<h4 id="observer-protocol"><a class="header" href="#observer-protocol">Observer protocol</a></h4>
<p>Implement a set of APIs in a template for reading the event log from the VNC directly or query the &quot;read-only&quot; contract.</p>
<p>Pros:</p>
<ul>
<li>Fast</li>
<li>Permissionless in one-way applications</li>
<li>Can check that results are signed by the VNC quorum</li>
</ul>
<p>Cons:</p>
<ul>
<li>Rely on contracts implementing the protocol</li>
<li>Instructions that require both chains' state to update is harder using this method.</li>
</ul>
<h4 id="micro-payments"><a class="header" href="#micro-payments">Micro-payments</a></h4>
<h5 id="bundle-accounts-template-into-smart-contract"><a class="header" href="#bundle-accounts-template-into-smart-contract">Bundle accounts template into smart contract</a></h5>
<ul>
<li>The bundled &quot;wrapped&quot; Tari is used in micropayments.</li>
<li>Users top up or withdraw Tari into the micropayment accounts using a bride or one of the methods described above.</li>
</ul>
<h5 id="async-await-analogue"><a class="header" href="#async-await-analogue">Async-await analogue</a></h5>
<ul>
<li>Contract A is a digital assets contract.</li>
<li>Contract B is a payments contract.</li>
<li>A and Bob have a monetary account on B, and Bob wants access to the assets on A.</li>
<li>Bob authorises A to debit his account on B for a certain amount / under certain conditions OR</li>
<li>Bob authorises the invoice produced by A for a discrete payment.</li>
<li>A submits a payment instruction to B to withdraw the amount, co-signed by Bob (or he did a pre-auth).</li>
<li>A &quot;awaits&quot; the result of the payment, and once successful, releases the asset OR</li>
<li>the instruction times out and Bob does not receive the asset and the instruction concludes.</li>
</ul>
<p>Pros:</p>
<ul>
<li>Can work in general, not just micro-payments</li>
<li>Can be fast.</li>
<li>Doesn't block progress in the face of obstructive agents.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Complex (handling collusion, &quot;proof-of-delivery&quot;)</li>
<li>time-outs can lock up funds for long periods.</li>
<li>Relies on chains publishing events.</li>
<li>Contract B is a trusted party from the PoV of Bob / A (e.g. Bob &amp; B collude to lie about account updates in order to
defraud A)</li>
</ul>
<h1 id="change-log-38"><a class="header" href="#change-log-38">Change Log</a></h1>
<ul>
<li><strong>06-04-2022</strong>: First draft</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0322vnregistration"><a class="header" href="#rfc-0322vnregistration">RFC-0322/VNRegistration</a></h1>
<h2 id="validator-node-registration"><a class="header" href="#validator-node-registration">Validator Node Registration</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-57"><a class="header" href="#licence-57">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-60"><a class="header" href="#language-60">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-60"><a class="header" href="#disclaimer-60">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-59"><a class="header" href="#goals-59">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe Validator Node (VN) registration. Registration accomplishes two goals:</p>
<ol>
<li>Provides a register of Validator Nodes with an authority (the Tari base layer).</li>
<li>Offers Sybil resistance against gaining probabilistic majority of any given publicly nominated VN committee.</li>
</ol>
<h2 id="related-requests-for-comment-51"><a class="header" href="#related-requests-for-comment-51">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
<li><a href="RFCD-0304_VNCommittees.html">RFCD-0304: Validator Node Committee Selection</a></li>
<li><a href="RFCD-0170_NetworkCommunicationProtocol.html">RFCD-0170: The Tari Communication Network and Network Communication Protocol</a></li>
<li><a href="RFC-0341D_AssetRegistration.html">RFCD-0341: Asset Registration</a></li>
<li><a href="BaseLayerExtensions.html">RFC-0200: Base Layer Extensions</a></li>
</ul>
<h2 id="description-39"><a class="header" href="#description-39">Description</a></h2>
<p>VNs register themselves on the <a href="Glossary.html#base-layer">Base layer</a> using a special <a href="Glossary.html#transaction">transaction</a> type. The registration
<a href="Glossary.html#transaction">transaction</a> type requires the spending of a certain minimum amount of <a href="Glossary.html#tari-coin">Tari coin</a>, the (<a href="Glossary.html#registration-deposit">Registration Deposit</a>),
which has a time lock on the output for a minimum amount of time (<a href="Glossary.html#registration-term">Registration Term</a>), as well as some metadata, such as
the VN's public key.</p>
<p>The Node ID is calculated after registration to prevent mining of VN public keys that can be used to manipulate routing
on the Distributed Hash Table (DHT).</p>
<p>Once a VN's <a href="Glossary.html#registration-term">Registration Term</a> has expired, so will this specific VN registration. The Unspent Transaction Output (UTXO)
time lock will have elapsed so
the <a href="Glossary.html#registration-deposit">Registration Deposit</a> can be reclaimed and a new VN registration needs to be performed. This automatic
registration expiry will ensure that the VN registry stays up to date with active VN registrations, and inactive
registrations will naturally be removed.</p>
<p>Requiring nodes to register themselves serves two purposes:</p>
<ul>
<li>makes VN Sybil attacks expensive; and</li>
<li>provides an authoritative &quot;central-but-not-centralized&quot; registry of VNs from the base layer.</li>
</ul>
<h3 id="node-id"><a class="header" href="#node-id">Node ID</a></h3>
<p>The VN ID can be calculated deterministically after the VN registration transaction is mined. This ensures
that VNs are randomly distributed over the DHT network.</p>
<p>VN IDs MUST be calculated as follows:</p>
<pre><code class="language-text"> NodeId = Hash( pk || h || kh )
</code></pre>
<p>Where</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Field</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">pk</td><td style="text-align: left">The VN's DHT public key</td></tr>
<tr><td style="text-align: left">h</td><td style="text-align: left">The block height of the block in which the registration transaction was mined</td></tr>
<tr><td style="text-align: left">kh</td><td style="text-align: left">The hash of the registration transaction's kernel</td></tr>
</tbody></table>
</div>
<p>Base Nodes SHOULD maintain a cached list of VNs and MUST return the Node ID in response to a
<code>get_validator_node_id</code> request.</p>
<h3 id="validator-node-registration-1"><a class="header" href="#validator-node-registration-1">Validator Node Registration</a></h3>
<p>A VN MUST register on the base layer before it can join any Distributed Area Network (DAN) <a href="Glossary.html#committee">committee</a>s. Registration 
happens by virtue
of a VN registration <a href="Glossary.html#transaction">transaction</a>.</p>
<p>VN registrations are valid for the <a href="Glossary.html#registration-term">Registration Term</a>.</p>
<p>The registration term is set at SIX months.</p>
<p>A VN registration transaction is a special transaction.</p>
<ul>
<li>The transaction MUST have EXACTLY ONE UTXO with the <code>VN_Deposit</code> flag set.</li>
<li>This UTXO MUST also:
<ul>
<li>set a time lock for AT LEAST the <a href="Glossary.html#registration-term">Registration Term</a> (or equivalent block periods);</li>
<li>provide the <em>value</em> of the UTXO in the signature metadata; and</li>
<li>provide the <em>public key</em> for the spending key for the output in the signature metadata.</li>
</ul>
</li>
<li>The value of this output MUST be equal to or greater than the <a href="Glossary.html#registration-deposit">Registration Deposit</a>.</li>
<li>The UTXO MUST store:
<ul>
<li>the value of the VN deposit UTXO as a u64; and</li>
<li>the value of the <em>public key</em> for the spending key for the output as 32 bytes in little-endian order.</li>
</ul>
</li>
<li>The <code>KernelFeatures</code> bit flag MUST have the <code>VN_Registration</code> flag set.</li>
<li>The kernel MUST also store the VN's DHT public key as 32 bytes in little-endian order.</li>
</ul>
<h3 id="validator-node-registration-renewal"><a class="header" href="#validator-node-registration-renewal">Validator Node Registration Renewal</a></h3>
<p>If a VN owner does not <em>renew</em> the registration before the <a href="Glossary.html#registration-term">Registration Term</a> has expired, the registration will lapse
and the VN will no longer be allowed to participate in any <a href="Glossary.html#committee">committee</a>s.</p>
<p>The number of consecutive renewals MAY increase the VN's reputation score.</p>
<p>A VN may only renew a registration in the TWO-WEEK period prior to the current term expiring.</p>
<p>A VN renewal transaction is a special transaction:</p>
<ul>
<li>The transaction MUST have EXACTLY ONE UTXO with the <code>VN_Deposit</code> flag set.</li>
<li>The transaction MUST spend the previous VN deposit UTXO for this VN.</li>
<li>This UTXO MUST also:
<ul>
<li>set a time lock for AT LEAST six months (or equivalent block periods);</li>
<li>provide the <em>value</em> of the transaction in the signature metadata; and</li>
<li>provide the <em>public key</em> for the spending key for the output in the signature metadata.</li>
</ul>
</li>
<li>This UTXO MUST also store:
<ul>
<li>The value of the VN deposit UTXO as a u64.</li>
<li>The value of the <em>public key</em> for the spending key for the output as 32 bytes in little-endian order;</li>
<li>The VN's Node ID. This can be validated by following the Renewal transaction kernel chain.</li>
<li>The kernel hash of this transaction's kernel.</li>
<li>A counter indicating that this is the n-th consecutive renewal. This counter will be confirmed by nodes and miners.
The first renewal will have a counter value of one.</li>
</ul>
</li>
<li>The previous VN deposit UTXO MUST NOT be spendable in a standard transaction (i.e. its time lock has not expired).</li>
<li>The previous VN deposit UTXO MUST expire within the next TWO WEEKS.</li>
<li>The transaction MAY provide additional inputs to cover transaction fees and increases in the <a href="Glossary.html#registration-deposit">Registration Deposit</a>.</li>
<li>The transaction kernel MUST have the <code>VN_Renewal</code> bit flag set.</li>
<li>The transaction kernel MUST also store the hash of the previous renewal transaction kernel, or the registration kernel, 
if this is the first renewal.</li>
</ul>
<p>One will notice that a VN's Node ID does not change as a result of a renewal transaction. Rather, every
renewal adds to a chain linking back to the original registration transaction. It may be desirable to establish a long
chain of renewals, in order to offer evidence of longevity and improve a VN's reputation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0340vnconsensusoverview"><a class="header" href="#rfc-0340vnconsensusoverview">RFC-0340/VNConsensusOverview</a></h1>
<h2 id="validator-node-consensus-algorithm"><a class="header" href="#validator-node-consensus-algorithm">Validator node consensus algorithm</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: Cayle Sharrock <CjS77></p>
<h1 id="license-3"><a class="header" href="#license-3">License</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD License</a>.</p>
<p>Copyright 2019. The Tari Development Community</p>
<h2 id="validator-node-consensus-algorithm-1"><a class="header" href="#validator-node-consensus-algorithm-1">Validator node consensus algorithm</a></h2>
<p><img src="theme/images/status-draft.svg" alt="status: draft" /></p>
<p><strong>Maintainer(s)</strong>: Cayle Sharrock <CjS77></p>
<h1 id="license-4"><a class="header" href="#license-4">License</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD License</a>.</p>
<p>Copyright 2019. The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-61"><a class="header" href="#language-61">Language</a></h2>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-61"><a class="header" href="#disclaimer-61">Disclaimer</a></h2>
<p>The purpose of this document and its content is for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-60"><a class="header" href="#goals-60">Goals</a></h2>
<p>This document describes at a high level how smart contract state is managed on the Tari Digital Assets Network.</p>
<h2 id="related-rfcs-3"><a class="header" href="#related-rfcs-3">Related RFCs</a></h2>
<ul>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: The Tari Digital Assets Network</a></li>
<li><a href="RFCD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
<li><a href="RFCD-0304_VNCommittees.html">RFCD-0304: Validator Node committee selection</a></li>
<li><a href="RFC-0341D_AssetRegistration.html">RFCD-0341: Asset Registration</a></li>
</ul>
<h2 id="description-40"><a class="header" href="#description-40">Description</a></h2>
<h3 id="overview-4"><a class="header" href="#overview-4">Overview</a></h3>
<p>The primary problem under consideration here is for multiple machines running the same program (in the form of a Tari
smart contract) to maintain agreement on what the state of the program is, often under adverse conditions, including
unreliable network communication, malicious third parties, or even malicious peers running the smart contract.</p>
<p>In computer science terms, the problem is referred to as
<a href="https://en.wikipedia.org/wiki/State_machine_replication">State Machine Replication</a>, or SMR. If we want our honest
machines (referred to as <em>replicas</em> in SMR parlance) to reach agreement in the face of arbitrary failures, then we talk
about our system being
<a href="https://tlu.tarilabs.com/consensus-mechanisms/BFT-consensusmechanisms/sources/PITCHME.link.html">Byzantine Fault Tolerant</a>.</p>
<p>Tari Asset <a href="Glossary.html#committee">committees</a> are chosen by the asset issuer according to <a href="RFC-0304_VNCommittees.html">RFC-0304</a>. The committees
form a fixed set of replicas, at the very least from checkpoint to checkpoint, and will typically be limited in size,
usually less than ten, and almost always under 100. <em>Note</em>: These numbers are highly speculative based on an intuitive
guess about the main use cases for Tari DAs, where we have</p>
<ul>
<li>many 1-3-sized committees where the asset issuer and the VN committee are the same entity,</li>
<li>semi-decentralised assets of ±4-10 where speed trumps censorship-resistance,</li>
<li>a small number of 50-100 VNs where censorship-resistance trumps speed.</li>
</ul>
<p>Because nodes cannot join and leave the committees at will, robust yet slow and expensive consensus approaches such as
Nakamoto consensus can be dropped in favour of something more performant.</p>
<p>There is a good survey of consensus mechanisms on
<a href="https://tlu.tarilabs.com/consensus-mechanisms/consensus-mechanisms.html">Tari Labs University</a>.</p>
<p>From the point of view of a DAN committee, the ideal consensus algorithm is one that</p>
<ol>
<li>Allows a high number of transactions per second, and doesn't have unnecessary pauses (i.e. a partially synchronous or
asynchronous model).</li>
<li>Is Byzantine Fault tolerant.</li>
<li>Is relatively efficient from a network communication point of view (number of messages passed per state agreement).</li>
<li>Is relatively simple to implement (to reduce the bug and vulnerability surface in implementations).</li>
</ol>
<p>A summary of some of the most well-known BFT algorithms is presented in
<a href="https://tlu.tarilabs.com/consensus-mechanisms/BFT-consensus-mechanisms-applications/MainReport.html#summary-of-findings">this table</a>.</p>
<p>A close reading of the algorithms presented suggest that <a href="https://arxiv.org/pdf/1807.01829.pdf">LinBFT</a>, which is based
on <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a> BFT provide the best trade-offs for the goals that a DAN committee is trying to achieve:</p>
<ol>
<li>The algorithm is optimistic, i.e. as soon as quorum is reached on a particular state, the committee can move onto the
next one. There is no need to wait for the &quot;timeout&quot; period as we do in e.g. Tendermint. This allows instructions to
be executed almost as quickly as they are received.</li>
<li>The algorithm is efficient in communication, requiring O(n) messages per state agreement in most practical cases.
This is compared to e.g. PBFT which requires O(n<sup>4</sup>) messages.</li>
<li>The algorithm is modular and relatively simple to implement.</li>
</ol>
<p>Potential drawbacks to using HotStuff include:</p>
<ol>
<li>Each round required the election of a <em>leader</em>. Having a leader dramatically simplifies the consensus algorithm; it
allows a linear number of messages to be sent between the leader and the other replicas in order to agree on the
current state; and it allows a strict ordering to be established on instructions without having to resort to e.g.
proof of work. However, if the choice of leader is deterministic, attackers can identify and potentially DDOS the
leader for a given round, causing the algorithm to time out. There are ways to mitigate this attack for a <em>specific
round</em>, as suggested in the LinBFT paper, such as using Verifiable Random Functions, but DDOSing a single replica
means that, on average, the algorithm will time out every 1/n rounds.</li>
<li>The attack described above only pauses progress in Hotstuff for the timeout period. In similar protocols, e.g.
Tendermint it can be shown to <a href="https://arxiv.org/pdf/1803.05069">delay progress indefinitely</a>.</li>
</ol>
<p>Given these trade-offs, there is strong evidence to suggest that <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a> BFT, when implemented on the Tari DAN will
provide BFT security guarantees with liveness performance in the sub-second scale and throughput on the order of
thousands of instructions per second, if the benchmarks presented in the <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a> paper are representative.</p>
<h3 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h3>
<p>The <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a> BFT algorithm provides a detailed description of the consensus algorithm. Only a summary of it is
presented here. To reduce confusion, we adopt the HotStuff nomenclature to describe state changes, rounds and function
names where appropriate.</p>
<p>Every proposed state change, as a result of replicas receiving instructions from clients is called a <em>view</em>. There is a
<a href="RFCD-0340_VNConsensusOverview.html#leader-selection">function that every node can call</a> that will tell it which replica will be the <em>leader</em> for a given
view. Every view goes through three phases (<code>Prepare</code>, <code>PreCommit</code>, <code>Commit</code>) before final consensus is reached. Once a
view reaches the <code>Commit</code> phase, it is finalised and will never be reversed.</p>
<p>As part of their normal operation, every replica broadcasts <a href="Glossary.html#instructions">instructions</a> it receives for its contract to its peers.
These instructions are stored in a replica's instruction mempool.</p>
<p>When the <a href="RFCD-0340_VNConsensusOverview.html#leader-selection">leader selection</a> function designates a replica as leader for the next view, it will try
and execute <em>all</em> the instructions it currently has in its mempool to update the state for the next view. Following this
it compiles a tuple of &lt;<em>valid-instructions</em>, <em>rejected-instructions</em>, <em>new-state</em>&gt;. This tuple represents the <code>CMD</code>
structure described in <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a>.</p>
<p>In parallel with this, the leader expects a set of <code>NewView</code> messages from the other replicas, indicating that the other
replicas know that this replica is the leader for the next view.</p>
<p>Once a super-majority of these messages have been received, the leader composes a proposal for the next state by adding
a new node to the state history graph (I'm calling it a state history graph to avoid naming confusion, but it's really a
blockchain). It composes a message containing the new proposal, and broadcasts it to the other replicas.</p>
<p>Replicas, on receipt of the proposal, decide whether the proposal is valid, both from a protocol point of view (i.e. did
the leader provide a well-formed proposal) as well as whether they agree on the new state (e.g. by executing the
instructions as given and comparing the resulting state with that of the proposal). If there is agreement, they vote on
the proposal by signing it, and sending their partial signature back to the leader.</p>
<p>When the leader has received a super-majority of votes, it sends a message back to the replicas with the (aggregated)
set of signatures.</p>
<p>Replicas can validate this signature and provide another partial signature indicating that they've received the first
aggregated signature for the proposal.</p>
<p>At this point, all replicas know that enough other replicas have received the proposal and are in agreement that it is
valid.</p>
<p>In Tendermint, replicas would now wait for the timeout period to make sure that the proposal wasn't going to be
superseded before finalising the proposal. But there is an attack described in the <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a> paper that could stall
progress at this point.</p>
<p>The HotStuff protocol prevents this by having a final round of confirmations with the leader. This prevents the stalling
attack and <em>also</em> lets replicas finalise the proposal <em>immediately</em> on receipt of the final confirmation from the
leader. This lets HotStuff proceed at &quot;network&quot; speed, rather than with a heartbeat dictated by the BFT synchronicity
parameter.</p>
<p>Although there are 4 round trips of communication between replicas and the leader, the number of messages sent are O(n).
It's also possible to stagger and layer these rounds on top of each other, so that there are always four voting rounds
happening simultaneously, rather than waiting for one to complete in its entirety before moving onto the next one.
Further details are given in the <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a> paper.</p>
<h4 id="forks-and-byzantine-failures"><a class="header" href="#forks-and-byzantine-failures">Forks and byzantine failures</a></h4>
<p>The summary of the HotStuff protocol given above describes the &quot;Happy Path&quot;, when there are no breakdowns in
communication, or when the leader is an honest node. In cases where the leader is unavailable, the protocol will time
out, the current view will be abandoned, and all replicas will move onto the next view.</p>
<p>If a leader is not honest, replicas will reject its proposal, and move onto the next view.</p>
<p>If there is a temporary network partition, the chain may fork (up to a depth of three), but the protocol guarantees
safety via the voting mechanism, and the chain will reconcile once the partition resolves.</p>
<h4 id="leader-selection-1"><a class="header" href="#leader-selection-1">Leader selection</a></h4>
<p><a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a> leaves the leader selection algorithm to the application. Usually, a round-robin approach is suggested for
its simplicity. However, this requires the replicas to <em>reliably</em> self-order themselves before starting with SMR, which
is a non-trivial exercise in byzantine conditions.</p>
<p>For Tari DAN committees, the following algorithm is proposed:</p>
<ol>
<li>Every replica knows the <a href="Glossary.html#node-id">Node ID</a> of every other replica in the committee.</li>
<li>For a given <em>view number</em>, the Node ID with the closest XOR distance to the hash of the <em>view number</em> will be the
leader for that view, where the hash function provides a uniformly random value of the same length as the Node ID.</li>
</ol>
<h4 id="quorum-certificate"><a class="header" href="#quorum-certificate">Quorum Certificate</a></h4>
<p>A Quorum certificate, or QC is proof that a super-majority of replicas have agreed on a given state. In particular, a QC
consists of</p>
<ul>
<li>The type of QC (depending on the phase in which the HotStuff pipeline the QC was signed),</li>
<li>The <em>view number</em> for the QC</li>
<li>A reference to the node in the state tree being ratified,</li>
<li>A signature from a super-majority of replicas.</li>
</ul>
<h3 id="tari-specific-considerations"><a class="header" href="#tari-specific-considerations">Tari-specific considerations</a></h3>
<p>As soon as a state is finalised, replicas can inform clients as to the result of instructions they have submitted (in
the affirmative or negative). Given that HotStuff proceeds optimistically, and finalisation happens after 4 rounds of
communication, it's anticipated that clients can receive a final response from the validator committee in under 500 ms
for reasonably-sized committees (this value is speculation at present and will be updated once exploratory experiments
have been carried out).</p>
<p>The Tari communication platform was designed to handle peer-to-peer messaging of the type described in <a href="https://arxiv.org/pdf/1803.05069" title="Hotstuff BFT">HotStuff</a>, and
therefore the protocol implementation should be relatively straightforward.</p>
<p>The &quot;state&quot; agreed upon by the VN committee will not only include the smart-contract state, but instruction fee
allocations and periodic checkpoints onto the base layer.</p>
<p>Checkpoints onto the base layer achieve several goals:</p>
<ul>
<li>Offers a proof-of-work backstop against &quot;evil committees&quot;. Without proof of work, there's nothing stopping an evil
committee (one that controls a super-majority of replicas) from rewriting history. Proof-of-work is the only reliable
and practical method that currently exists to make it expensive to change the history of a chain of records. Tari
gives us a &quot;best of both worlds&quot; scenario wherein an evil committee would have to rewrite the base layer history
(which <em>does</em> use proof-of-work) before they could rewrite the digital asset history (which does not).</li>
<li>They allow the asset issuer to authorise changes in the VN committee replica set.</li>
<li>It allows asset owners to have an immutable proof of asset ownership long after the VN committee has dissolved after
the useful end-of-life of a smart contract.</li>
<li>Provides a means for an asset issuer to resurrect a smart contract long after the original contract has terminated.</li>
</ul>
<p>When Validator Nodes run smart contracts, they should be run in a separate thread so that if a smart contract crashes,
it does not bring the consensus algorithm down with it.</p>
<p>Furthermore, VNs should be able to quickly revert state to at least four views back in order to handle temporary forks.
Nodes should also be able to initialise/resume a smart contract (e.g. from a crash) given a state, view number, and view
history.</p>
<p>This implies that VNs, in addition to passing around HotStuff BFT messages, will expose additional APIs in order to</p>
<ul>
<li>allow lagging replicas to catch up in the execution state.</li>
<li>Provide information to (authorised) clients regarding the most recent finalised state of the smart contract via a
read-only API.</li>
<li>Accept smart-contract instructions from clients and forward these onto the other replicas in the VN committee.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0341-asset-registration"><a class="header" href="#rfc-0341-asset-registration">RFC-0341: Asset Registration</a></h1>
<h2 id="asset-registration-process"><a class="header" href="#asset-registration-process">Asset Registration Process</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-58"><a class="header" href="#licence-58">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-62"><a class="header" href="#language-62">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-62"><a class="header" href="#disclaimer-62">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-61"><a class="header" href="#goals-61">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to  describe the process in which an <a href="Glossary.html#asset-issuer">Asset Issuer</a> (AI) will need to engage to 
register a <a href="Glossary.html#digital-asset">Digital Asset</a> (DA) and commence its operation on the <a href="Glossary.html#digital-asset-network">Digital Asset Network</a> (DAN).</p>
<h2 id="related-requests-for-comment-52"><a class="header" href="#related-requests-for-comment-52">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0311_AssetTemplates.html">RFCD-0311: Digital Asset Templates</a></li>
<li><a href="RFCD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
<li><a href="RFCD-0304_VNCommittees.html">RFCD-0304: Validator Node Committee Selection</a></li>
</ul>
<h2 id="description-41"><a class="header" href="#description-41">Description</a></h2>
<h3 id="abstract-7"><a class="header" href="#abstract-7">Abstract</a></h3>
<p>This document will describe the process through which an AI will go in order to:</p>
<ul>
<li>register a DA on the <a href="Glossary.html#base-layer">base layer</a>;</li>
<li>assemble a <a href="Glossary.html#committee">committee</a> of <a href="Glossary.html#validator-node">Validator Node</a>s (VNs); and</li>
<li>commence operation of the DA on the DAN.</li>
</ul>
<h3 id="asset-creation-instruction"><a class="header" href="#asset-creation-instruction">Asset Creation Instruction</a></h3>
<p>The first step in registering and commencing the operation of an asset is that the AI MUST issue an asset creation 
transaction to the <a href="Glossary.html#base-layer">base layer</a>.</p>
<p>This transaction will be time-locked for the length of the desired nomination period. This ensures that this transaction 
cannot be spent until the nomination period has elapsed so that it is present during the entire nomination process. The 
value of the transaction will be the <code>asset_creation_fee</code> described in <a href="RFC-0311_AssetTemplates.html">RFC-0311</a>. The AI 
will spend the transaction back to themselves, but locking this fee up at this stage achieves two goals:</p>
<ul>
<li>
<p>Firstly, it makes 
it expensive to spam the network with asset creation transactions that a malicious AI does not intend to complete.</p>
</li>
<li>
<p>Secondly, it proves to the VNs that participate in the nomination process that the AI does indeed have the funds 
required to commence operation of the asset once the committee has been selected.</p>
</li>
</ul>
<p>If the asset registration process 
fails, e.g. if there are not enough available VNs for the committee, then the AI can refund the fee to themselves 
after the time lock expires.</p>
<p>The transaction will contain the following extra metadata to facilitate the registration process:</p>
<ol>
<li>
<p>The value of the transaction in clear text and the public spending key of the commitment so that it can be verified 
by third parties. A third party can verify the value of the commitment by using the information in (1) and (2) below, to calculate (3):</p>
<ol>
<li>The output commitment is $ C = k \cdot G + v \cdot H $.</li>
<li>$ v​ $ and $ k \cdot G ​$ are provided in the metadata.</li>
<li>A verifier can calculate $ C - k \cdot G = v \cdot H $ and verify this value by multiplying the clear text $ v $ by $ H $ themselves.</li>
</ol>
</li>
<li>
<p>A commitment (hash) to the asset parameters as defined by a <a href="Glossary.html#digitalassettemplate">DigitalAssetTemplate</a> described in 
<a href="RFC-0311_AssetTemplates.html">RFC-0311</a>. This template will define all the parameters of the asset that the AI intends to 
register, including information the VNs need to know, such as what  <a href="Glossary.html#assetcollateral">AssetCollateral</a> is required to be part of the committee.</p>
</li>
</ol>
<p>Once this transaction has been confirmed to the required depth on the blockchain, the nomination phase can begin.</p>
<h3 id="nomination-phase"><a class="header" href="#nomination-phase">Nomination Phase</a></h3>
<p>The next step in registering an asset is for the AI to select a committee of VNs to manage the asset. The process to do 
this is described in <a href="RFC-0304_VNCommittees.html">RFC-0304</a>. This process lasts as long as the time lock on the asset 
creation transaction described above. The VNs have until that time lock elapses to nominate themselves (in the case of 
an asset being registered using the <code>committee_mode::PUBLIC_NOMINATION</code> parameter in the <a href="Glossary.html#digitalassettemplate">DigitalAssetTemplate</a>).</p>
<h3 id="asset-commencement"><a class="header" href="#asset-commencement">Asset Commencement</a></h3>
<p>Once the nomination phase is complete and the AI has selected a committee as described in <a href="RFC-0304_VNCommittees.html">RFC-0304</a>, 
the chosen committee and AI are ready to commit their <code>asset_creation_fee</code> and <a href="Glossary.html#assetcollateral">AssetCollateral</a>s to commence the 
operation of the asset. This is done by the AI and the committee members collaborating to build the initial <a href="Glossary.html#checkpoint">Checkpoint</a> 
of the asset. When this <a href="Glossary.html#checkpoint">Checkpoint</a> transaction is published to the <a href="Glossary.html#base-layer">base layer</a>, the <a href="Glossary.html#digital-asset">digital asset</a> will be live on 
the DAN. The <a href="Glossary.html#checkpoint">Checkpoint</a> transaction is described in <a href="RFC-0220_AssetCheckpoints.html">RFC_0220</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0345assetlifecycle"><a class="header" href="#rfc-0345assetlifecycle">RFC-0345/AssetLifeCycle</a></h1>
<h2 id="asset-life-cycle"><a class="header" href="#asset-life-cycle">Asset Life Cycle</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence-59"><a class="header" href="#licence-59">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019. The Tari Development Community.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-63"><a class="header" href="#language-63">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-63"><a class="header" href="#disclaimer-63">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-62"><a class="header" href="#goals-62">Goals</a></h2>
<h2 id="related-requests-for-comment-53"><a class="header" href="#related-requests-for-comment-53">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: The Digital Assets Network</a></li>
<li><a href="RFCD-0301_NamespaceRegistration.html">RFCD-0301: Namespace Registration</a></li>
<li><a href="RFCD-0311_AssetTemplates.html">RFCD-0311 Asset templates</a></li>
<li><a href="RFCD-0340_VNConsensusOverview.html">RFCD-0340: Validator Node Consensus</a></li>
</ul>
<h2 id="description-42"><a class="header" href="#description-42">Description</a></h2>
<h3 id="introduction-12"><a class="header" href="#introduction-12">Introduction</a></h3>
<p>Tari digital assets are created on the <a href="RFCD-0300_DAN.html">Digital Assets Network</a>, managed by a Validator Node (VN)
committee, see <a href="RFC-0340_VNConsensusOverview.html">RFC-0340</a>, and are operated under the rules of the
<a href="RFC-0311_AssetTemplates.html">template</a> that governs the asset.</p>
<p>A <em>given version</em> of a template provides an immutable definition of the type of information (the state) that is managed
during the lifetime of the asset. <em>All</em> the rules that govern reading and updating of the asset state, and rules
regarding any transfers of tokens that may be defined as part of the asset are governed by the template code.</p>
<p>This immutability is what allows VN committees to reach rapid consensus about what an asset’s state looks<br />
like after <a href="Glossary.html#instructions">instructions</a> are executed.</p>
<p>However, immutability is a major problem when faced with typical software and business development challenges such as
software bugs, or changes in legal and operational requirements.</p>
<p>The Tari network is designed to accommodate these requirements by offering a migration path for assets from one version
of a template to another version of a template.</p>
<h3 id="asset-migration"><a class="header" href="#asset-migration">Asset migration</a></h3>
<p>To carry out a successful migration, the following requirements must be met:</p>
<ul>
<li>The validator node committee for the asset must support the migration path. This entails that <em>every</em> VN in the
committee has a <code>MigrateAsset</code> class from the <code>template_type.version</code> combination of the existing asset to the
<code>template_type.version</code> of the new asset.</li>
<li>The original asset issuer provides a valid <code>migrate_asset</code> instruction to the DAN.
<ul>
<li>The asset issuer MUST provide any additional state that exists in the new template version and not the original.</li>
<li>The original asset SHOULD be marked as <code>retired</code>. If so, the <code>superseded_by</code> field in the old asset will carry the
new asset id once the new asset has been confirmed. We recommend retiring the old asset because all the keys that
indicate ownership of tokens will be copied over; effectively re-using them; which can damage privacy.</li>
<li>A policy is provided to determine the course of action to follow if any state from the old asset is illegal under
the new template rules (e.g. If a new rule requires <code>token.age</code> to be &gt; 21; what happens to any tokens where this
condition fails?)</li>
</ul>
</li>
</ul>
<p>As part of the migration,</p>
<ol>
<li>An entirely new asset is created with the full state of the old asset copied over into the new asset; supplemented
with any additional state required in the new template.</li>
<li>A state validation run is performed; and any invalid state from the old asset is modified according to the migration
policy.</li>
<li>Step 2 is repeated until a valid initial state is produced.</li>
<li>If Step 2 has run <code>STATE_VALIDATION_LIMIT</code> times and the initial state is still not valid, the migration instruction
is rejected; the migrate_asset instruction will advise what should be done with the original asset in this case:
either allow the original asset to continue as before, or retire it.</li>
<li>Once a valid initial state is produced, a new <code>create_asset</code> instruction is generated from the initial
state and the <code>migrate_asset</code> instruction. Typically the same VN committee will be used for the new asset, but this
needn’t be the case.</li>
</ol>
<p>Once a successful migration has completed, any instructions to the old asset can return a simple <code>asset_migrated</code>
response with the new asset ID, which will allow clients and wallets to seamlessly update their records.</p>
<h3 id="retiring-assets"><a class="header" href="#retiring-assets">Retiring Assets</a></h3>
<p>Retiring an asset follows the same procedure as when as asset reaches its natural end-of-life: A final checkpoint is
posted to the base layer and a grace period is given to allow DAN nodes and clients to take a snapshot of the final
state if desired.</p>
<h3 id="resurrecting-assets"><a class="header" href="#resurrecting-assets">Resurrecting assets</a></h3>
<p>It’s unreasonable to expect VNs to hold onto large chunks of state for assets that are effectively dead (e.g. ticket
stubs long after the event is over). For this reason, assets are allowed to expire after which VNs can forget about the
state and use that storage for something else.</p>
<p>However, it may be that interest in an asset resurfaces long after the asset expires (nostalgia being the multi-billion
dollar industry it is today). The <code>resurrect_asset</code> instruction provides a mechanism to bring an asset back to life.</p>
<p>To resurrect an asset, the following conditions must be met:</p>
<ul>
<li>The asset must have expired.</li>
<li>It must not be currently active (i.e. it hasn’t already been resurrected).</li>
<li>An asset issuer (not necessarily the original asset issuer) must provide funding for the new lifetime of the asset.</li>
<li>The asset issuer needs to have a copy of the state corresponding to the final asset checkpoint of the original asset.</li>
<li>The new asset issuer transmits a <code>resurrect_asset</code> instruction to the network. This instruction is identical to the
original <code>create_asset</code> instruction with the following exceptions:
<ul>
<li>The “initial state” merkle root must be equal to the final state checkpoint merkle root.</li>
<li>The asset owner public key will be provided by the new asset issuer.</li>
</ul>
</li>
<li>Third parties can interrogate the new committee asking them to provide a Merkle Proof for pieces of state that the
third party (perhaps former asset owners) knows about. This can mitigate fraud attempts where parties can attempt to
resurrect assets without actually having a copy of the smart contract state. If enough random state proofs are
requested, or a single proof of enough random pieces of state, we can be confident that the asset resurrection is
legitimate.</li>
</ul>
<p>The VN committee for the resurrected asset need not bear any relation to the original VN committee.
Once confirmed, the resurrected asset operates exactly like any other asset.
An asset can expire and be resurrected multiple times (sequentially).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0360nftinvoices"><a class="header" href="#rfc-0360nftinvoices">RFC-0360/NFTInvoices</a></h1>
<h2 id="nft-sale-via-mimblwimble-invoice"><a class="header" href="#nft-sale-via-mimblwimble-invoice">NFT sale via Mimblwimble Invoice</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/stringhandler">Stringhandler</a></p>
<h1 id="licence-60"><a class="header" href="#licence-60">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2021 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-64"><a class="header" href="#language-64">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, 
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in 
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as 
shown here.</p>
<h2 id="disclaimer-64"><a class="header" href="#disclaimer-64">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-63"><a class="header" href="#goals-63">Goals</a></h2>
<p>The aim of this Request for Comment (RFC) is to describe a formulation of a <a href="Glossary.html#mimblewimble">Mimblewimble</a> <a href="Glossary.html#transaction">transaction</a> negotiation process
to allow for the sale of an <a href="Glossary.html#nft">Non Fungible Token</a> (NFT) by a Seller to a Buyer. The Seller will initiate the transaction negotiation by
specifying which [NFT] containing <a href="Glossary.html#unspent-transaction-outputs">UTXO</a> they are offering for sale and how much Tari they expect in return. Having the party
that will receive the funds specify the funds they wish to receive is termed an Invoice. The Buyer will then provide their payment 
input and resulting change output to the transaction and provide a partial signature. The final step will be the Seller 
completing the final signature to produce a complete transaction.</p>
<p>The process must be completely atomic. At no point should the data included in the negotiation be malleable by the other party
or allow for one party to change the elements provided by the counterparty without making the transaction invalid.</p>
<h2 id="related-requests-for-comment-54"><a class="header" href="#related-requests-for-comment-54">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: Digital Assets Network</a></li>
</ul>
<p>$$
\newcommand{\hash}[1]{\mathrm{H}\bigl({#1}\bigr)}
$$</p>
<h2 id="description-43"><a class="header" href="#description-43">Description</a></h2>
<p>The standard interactive <a href="Glossary.html#mimblewimble">Mimblewimble</a> transaction is usually initiated by a party, the Sender, that is going to send 
funds to a Receiver. The Sender selects a number of input UTXOs from which the sent funds and fees will come from, they
build a change UTXO to receive any remaining funds and calculate the excess of these inputs and change output. The 
Receiver is then told how many Tari they will receive and provides the aggregated public excess and public nonce of the 
Sender's portion of the transaction signature. The Receiver builds a commitment with the specified value and their 
private spending key and then provides their partial signature for their UTXO and the excess. This gets sent back to the 
Sender who then completes the transaction by providing their partial signature and aggregating it with the Receiver's 
partial signature.</p>
<p>In the standard Mimblewimble negotiation there are two main elements that make the process trustless for the Sender and
Receiver. Firstly, for the Sender, whose inputs are being spent, has the final say in whether to complete the transaction
by producing the final signature. For the Receiver there is little risk because they have not provided any inputs at all
and are just receiving funds, so they have nothing to lose if the process is compromised. Furthermore, their partial signature
means that the Sender cannot change anything about the Receiver's output in the final stage of negotiation.</p>
<p>When it comes to the sale of a token using a <a href="Glossary.html#mimblewimble">Mimblewimble</a> style transaction the risk profile for both the Seller and the
Buyer is a bit more complicated.</p>
<ol>
<li>The Seller has to prove that they own a given token UTXO and provide some partial signature committing to the terms of 
the sale without the Buyer being able to use that data to build a new transaction transferring ownership of the token
with different terms to what the Seller specified.</li>
<li>The Buyer has to provide inputs into the transaction before the finalization step in such a way that those inputs are 
committed but not at risk of the Seller being able to claim the inputs without completing the agreed upon transaction in full.</li>
</ol>
<p>So the ultimate goal must be a negotiation process where the Seller and Buyer can interact completely trustlessly to build
this transaction to the agreed terms. This must be done while each party's contributions to the negotiation are not 
malleable by the other party and the entire process must be atomic. It either results in a valid transaction built as both
parties expect or not at all.</p>
<h2 id="transaction-negotiation"><a class="header" href="#transaction-negotiation">Transaction Negotiation</a></h2>
<h3 id="assumptions-5"><a class="header" href="#assumptions-5">Assumptions:</a></h3>
<ul>
<li>The UTXOs containing the token data have a value of zero (This has not been decided yet in the RFCs regarding token UTXOs).</li>
<li>The Buyer is going to pay the fees.</li>
<li>The Buyer will select a single input for payment purposes whose value will cover the requested payment and fees.</li>
<li>In the following notation a Transaction Input/Output will be represented by \( C_x \) and when used in equations
will represent a Pederson Commitment but when sent to the counterparty will include all the addition metadata as described in
<a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a></li>
</ul>
<p>In the following equations the capital letter subscripts, <em>S</em> and <em>B</em> refer to a token <em>Seller</em> and <em>Buyer</em> respectively.</p>
<p>The transaction that is constructed by this process will need to produce an output <a href="Glossary.html#metadata-signature">metadata signature</a> for the Transaction Output
the Buyer will receive the token in and also the Transaction Output the Seller will receive their payment in. These signatures
will be aggregated <a href="https://eprint.iacr.org/2020/061.pdf">Commitment Signature</a>s that are described in detail in <a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a>.</p>
<p><a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a> is written from the perspective of a standard Mimblewimble transaction where
only the Sender has Transaction Inputs and the Receiver only has a single Transaction Output. The case this RFC discusses 
both parties receive a Transaction Output and both parties supply a Transaction Input. This results in the requirement of an
extra round of communication between the parties. However, the negotiation described below allows for a transaction to be 
built that can be validated exactly the same was as is described in <a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a>.</p>
<h3 id="negotiation-3"><a class="header" href="#negotiation-3">Negotiation</a></h3>
<h4 id="round-1"><a class="header" href="#round-1">Round 1</a></h4>
<p>The Seller initiates the negotiation by collecting and calculating the following:</p>
<div class="table-wrapper"><table><thead><tr><th>Terms</th><th>Description</th></tr></thead><tbody>
<tr><td>\( C_{St} = 0 \cdot H  + k_{St} \cdot G \)</td><td>Select the Seller's token Transaction Input to be offered</td></tr>
<tr><td>\( C_{Sp} = v_p \cdot H + k_{Sp} \cdot G \)</td><td>Choose a value to be requested from Buyer and select a spending key for the payment Transaction Output to be received</td></tr>
<tr><td>\( R_{Sk} = r_{Sk} \cdot G \)</td><td>Choose a excess signature nonce</td></tr>
<tr><td>\( R_{SMSt} = r_{SMSt_a} \cdot H + r_{SMSt_b} \cdot G \)</td><td>Choose a Seller commitment signature nonce for the Buyer's token output</td></tr>
<tr><td>\( K_{SO} = k_{SO} \cdot G \)</td><td>Choose a Seller Offset to be used in the Buyer's received token output <a href="Glossary.html#metadata-signature">metadata signature</a></td></tr>
<tr><td>\( x_S = k_{Sp} - k_{St} \)</td><td>Seller's private Excess</td></tr>
<tr><td>\( X_S = x_S \cdot G \)</td><td>Seller's public Excess</td></tr>
<tr><td>\( s_{St} \)</td><td>A <a href="https://eprint.iacr.org/2020/061.pdf">Commitment Signature</a> using \( C_{St} \) signing the message \( e = (X_S \Vert v_p \Vert R_S) \)</td></tr>
</tbody></table>
</div>
<p>The Seller now sends the following to the Buyer</p>
<div class="table-wrapper"><table><thead><tr><th>Items</th><th>Description</th></tr></thead><tbody>
<tr><td>\( C_{St} \)</td><td>The Seller's token Transaction Input to be offered</td></tr>
<tr><td>\( C_{Sp} \)</td><td>Seller's payment Transaction Output to be received</td></tr>
<tr><td>\( v_p \)</td><td>The value the Seller is requesting as part of this offer</td></tr>
<tr><td>\( R_{Sk} \)</td><td>Seller's public excess signature nonce</td></tr>
<tr><td>\( R_{SMSt}\)</td><td>Seller's public metadata signature nonce for the Buyer's token UTXO</td></tr>
<tr><td>\( K_{SO}\)</td><td>Seller Offset public key</td></tr>
<tr><td>\( s_{St} \)</td><td>A <a href="https://eprint.iacr.org/2020/061.pdf">Commitment Signature</a> using \( C_{St} \) signing the message \( e = (X_S \Vert v_p \Vert R_s) \)</td></tr>
</tbody></table>
</div>
<h4 id="round-2"><a class="header" href="#round-2">Round 2</a></h4>
<p>The commitment signature is provided to the Buyer to show that the Seller does indeed own the token UTXO \( C_{St} \). 
The Buyer's wallet should verify on the base layer that this UTXO is for the token they are being offered.</p>
<p>The Buyer will construct the Seller's public Excess, \( X_s \) from the provided components:
\( X_s = C_{Sp} - C_{St} - v_p \cdot H \)
This operation confirms that the only commitments that form part of the Seller's excess are the token input and a commitment 
with the value of the requested payment. To ensure that there is no malleability in the Seller's payment output the Buyer
will also provide the Seller with an offset public key so that the Seller can produce an output <a href="Glossary.html#metadata-signature">metadata signature</a>.</p>
<p>The Buyer will now calculate/choose the following:</p>
<div class="table-wrapper"><table><thead><tr><th>Terms</th><th>Description</th></tr></thead><tbody>
<tr><td>\( C_{Bp} = v_{Bp} \cdot H  + k_{Bp} \cdot G \)</td><td>Buyer's selected Transaction Input from which the payment is drawn</td></tr>
<tr><td>\( C_{Bc} = (v_{Bp} - v_p - \text{fees}) \cdot H + k_{Bc} \cdot G \)</td><td>Buyer's change Transaction Output accounting for the amount to pay to seller and the fees</td></tr>
<tr><td>\( C_{Bt} = 0 \cdot H + k_{Bt} \cdot G \)</td><td>Buyer's token Transaction Output that he will own if the transaction is completed</td></tr>
<tr><td>\( x_B = k_{Bt} + k_{Bc} - k_{Bp} \)</td><td>Buyers's private Excess</td></tr>
<tr><td>\( X_B = x_B \cdot G \)</td><td>Buyers's public Excess</td></tr>
<tr><td>\( R_B = r_B \cdot G \)</td><td>Choose an excess signature nonce</td></tr>
<tr><td>\( s_{B} = r_B + e_k x_B \)</td><td>A partial excess signature signing the message \( e_k = (R_S + R_B \Vert X_S + X_B \Vert \text{metadata} \Vert \text{fees} ) \)</td></tr>
<tr><td>\( R_{BMSt} = r_{BMSt_a} \cdot H + r_{BMSt_b} \cdot G \)</td><td>Choose a Buyer commitment signature nonce for the Buyer's token output</td></tr>
<tr><td>\( e_{Bt} = \hash{ (R_{SMSt} + R_{BMSt}) \Vert \alpha_{Bt} \Vert F_{Bt} \Vert K_{SO} \Vert C_{Bt}} \)</td><td>Buyer's token output metadata signature challenge where \( \alpha_{Bt} \) is the Buyer's token UTXO script and \( F_{Bt} \) is the Buyer's token UTXO output features</td></tr>
<tr><td>\( s_{BMSt} = (a_{BMSt}, b_{BMSt}, R_{BMSt} ) \)</td><td>A partial metadata commitment signature for \( C_{Bt} \) signing message \( e_{Bt} \)</td></tr>
<tr><td>\( R_{BMSp} = r_{BMSp_a} \cdot H + r_{BMSp_b} \cdot G \)</td><td>Buyer's public metadata signature nonce for use by the Seller to calculate their payment output <a href="Glossary.html#metadata-signature">metadata signature</a></td></tr>
<tr><td>\( K_{BO} = k_{BO} \cdot G \)</td><td>Choose a Buyer Offset to be used in the Sellers's received payment output <a href="Glossary.html#metadata-signature">metadata signature</a></td></tr>
</tbody></table>
</div>
<p>The Buyer will then return the following to the Seller:</p>
<div class="table-wrapper"><table><thead><tr><th>Items</th><th>Description</th></tr></thead><tbody>
<tr><td>\( C_{Bp} \)</td><td>Buyer's Transaction Input that the payment will come from</td></tr>
<tr><td>\( C_{Bc} \)</td><td>Buyer's change Transaction Output</td></tr>
<tr><td>\( C_{Bt} \)</td><td>Buyer's token Transaction Input that will be received if the sale is completed</td></tr>
<tr><td>\( R_B \)</td><td>Buyers's public Excess</td></tr>
<tr><td>\( \text{fees &amp; metadata} \)</td><td>The fees and Mimblewimble transaction metadata</td></tr>
<tr><td>\( s_{B} \)</td><td>The Buyer's partial excess signature</td></tr>
<tr><td>\( R_{SMSt}\)</td><td>Buyer's public metadata signature nonce for use in the Seller's payment output <a href="Glossary.html#metadata-signature">metadata signature</a></td></tr>
<tr><td>\( K_{BO}\)</td><td>Buyer Offset to be used in the Sellers's received payment output <a href="Glossary.html#metadata-signature">metadata signature</a></td></tr>
<tr><td>\( s_{BMSt} \)</td><td>A partial metadata commitment signature for \( C_{Bt} \)</td></tr>
</tbody></table>
</div>
<h4 id="round-3"><a class="header" href="#round-3">Round 3</a></h4>
<p>The Seller can calculate the Buyer's excess as follows:</p>
<p>\( X_B = C_{Bt} + C_{Bc} - C_{Bp} + (v_p + \text{fees}) \cdot H  \)</p>
<p>The Seller will now calculate/choose the following:</p>
<div class="table-wrapper"><table><thead><tr><th>Terms</th><th>Description</th></tr></thead><tbody>
<tr><td>\( s_{S} = r_S + e x_S \)</td><td>Sellers's partial excess signature</td></tr>
<tr><td>\( s = s_S + s_B, R = R_S + R_B \)</td><td>Seller's aggregates the excess signatures to produce the final excess signature</td></tr>
<tr><td>\( b_{SMSt} = r_{SMSt_b} + e_{Bt}(k_SO) \)</td><td>Seller's partial metadata signature for the Buyer's token output</td></tr>
<tr><td>\( s_{MSt} = (a_{BMSt}, b_{SMSt} + b_{BMSt}, R_{SMSt} + R_{BMSt} \)</td><td>Aggregated <a href="Glossary.html#metadata-signature">metadata signature</a> for Buyer's token Transaction Output</td></tr>
<tr><td>\( R_{SMS} = r_{SMSp_a} \cdot H + r_{SMSp_b} \cdot G \)</td><td>Choose a Seller commitment signature nonce for the Seller's payment output</td></tr>
<tr><td>\( e_{Sp} = \hash{ (R_{SMSpt} + R_{BMSp}) \Vert \alpha_{Sp} \Vert F_{Sp} \Vert K_{BO} \Vert C_{Sp}} \)</td><td>where \( \alpha_{Sp} \) is the Sellers's payment UTXO script and \( F_{Sp} \) is the Seller's payment UTXO output features</td></tr>
<tr><td>\( s_{SMSp} = (a_{SMSp}, b_{SMSp}, R_{SMSp} ) \)</td><td>A partial metadata commitment signature for \( C_{Sp} \) signing message \( e_{Sp} \)</td></tr>
<tr><td>\( \gamma_S = k_Sst - k_SO \)</td><td>The Seller's portion of the Script Offset constructed using the script key from \(C_St\), \( k_Sst \), and the private Seller Offset</td></tr>
</tbody></table>
</div>
<p>The Seller can almost fully complete the transaction construction now. However, while the Seller can complete their portion 
of the final <a href="Glossary.html#script-offset">script offset</a> they cannot complete the entire offset because the Buyer also has input's in the transaction. 
This means we need one extra round of communication where the Seller returns the almost complete transaction to the Buyer
who will complete there portion of the final <a href="Glossary.html#script-offset">script offset</a> to complete the transaction.</p>
<p>The Seller sends the following back to the Buyer:</p>
<div class="table-wrapper"><table><thead><tr><th>Items</th><th>Description</th></tr></thead><tbody>
<tr><td>\( C_{St} \)</td><td>Seller's token Transaction Input</td></tr>
<tr><td>\( C_{Sp} \)</td><td>Seller's payment Transaction Output</td></tr>
<tr><td>\( C_{Bp} \)</td><td>Buyer's Transaction Input that the payment will come from</td></tr>
<tr><td>\( C_{Bc} \)</td><td>Buyer's change Transaction Output</td></tr>
<tr><td>\( C_{Bt} \)</td><td>Buyer's token Transaction Output that will be received if the sale is completed</td></tr>
<tr><td>\( X_S + X_B \)</td><td>Public Excess</td></tr>
<tr><td>\( s \)</td><td>Aggregated Excess Signature</td></tr>
<tr><td>\( s_{MSt} \)</td><td>Aggregated <a href="Glossary.html#metadata-signature">metadata signature</a> for Buyer's token Transaction Output</td></tr>
<tr><td>\( s_{SMSp} \)</td><td>Partial metadata commitment signature for \( C_{Sp} \)</td></tr>
<tr><td>\( \gamma_S \)</td><td>The Seller's portion of the Script Offset</td></tr>
</tbody></table>
</div>
<h3 id="round-4"><a class="header" href="#round-4">Round 4</a></h3>
<p>The final step will be for the Buyer to complete their portion of the <a href="Glossary.html#metadata-signature">metadata signature</a> for the Seller's payment Transaction
Output and complete their portion of the Script Offset.</p>
<div class="table-wrapper"><table><thead><tr><th>Terms</th><th>Description</th></tr></thead><tbody>
<tr><td>\( b_{BMSp} = r_{BMSp_b} + e_{Sp}(k_BO) \)</td><td>Buyers's partial metadata signature for the Seller's payment output</td></tr>
<tr><td>\( s_{MSp} = (a_{SMSp}, b_{SMSp} + b_{BMSp}, R_{SMSp} + R_{BMSp} \)</td><td>Aggregated <a href="Glossary.html#metadata-signature">metadata signature</a> for Seller's payment Transaction Output</td></tr>
<tr><td>\( \gamma_B = k_Bsp - k_BO \)</td><td>The Seller's portion of the Script Offset constructed using the script key from \(C_Bp\), \( k_Bsp \), and the private Buyer Offset</td></tr>
<tr><td>\( \gamma = \gamma_B + \gamma_S \)</td><td>The final <a href="Glossary.html#script-offset">script offset</a> for the completed transaction.</td></tr>
</tbody></table>
</div>
<p>The Buyer's change Transaction Output will be constructed fully by them including the <a href="Glossary.html#metadata-signature">metadata signature</a> which will be included in the final \( \gamma \) value.</p>
<h3 id="validation-1"><a class="header" href="#validation-1">Validation</a></h3>
<p>A <a href="Glossary.html#base-node">Base Node</a> will validate this transaction in the exact same way as described in <a href="RFC-0201_TariScript.html">RFC-0201: TariScript</a>.</p>
<p>In addition to the standard Mimblewimble and TariScript validation operations the consensus rules required for assets and
tokens must also be applied. The most important is to confirm that the <code>unique_id</code> of the token being sold in this transaction
exists only once as an input and once as an output and the metadata is correctly transfered.</p>
<h3 id="security-concerns"><a class="header" href="#security-concerns">Security concerns</a></h3>
<p>For this negotiation to be secure it must not be possible for the following to occur:</p>
<ol>
<li>For the Buyer to use the information provided by the Seller during the first round to construct a valid transaction 
spending the Seller's token UTXO without the requested payment being fulfilled.</li>
<li>For the Seller to take the information provided by the Buyer in the second round and construct a valid transaction 
where the ownership of the token is not transferred even if the Mimblewimble arithmetic balances out.</li>
</ol>
<p>These points should both be taken care of by the aggregated excess signature and the respective output [metadata signatures]. 
These signatures prevent the counterparty from changing anything about the Transaction Outputs without the cooperation of the
other party.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-0500paymentchannels"><a class="header" href="#rfc-0500paymentchannels">RFC-0500/PaymentChannels</a></h1>
<h2 id="payment-channels"><a class="header" href="#payment-channels">Payment channels</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: Cayle Sharrock <CjS77></p>
<h1 id="licence-61"><a class="header" href="#licence-61">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2019. The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-65"><a class="header" href="#language-65">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-65"><a class="header" href="#disclaimer-65">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-64"><a class="header" href="#goals-64">Goals</a></h2>
<h2 id="related-requests-for-comment-55"><a class="header" href="#related-requests-for-comment-55">Related Requests for Comment</a></h2>
<ul>
<li><a href="RFC-0001_overview.html">RFC-0001: Overview</a></li>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: The Tari Digital Assets Network</a></li>
</ul>
<h2 id="description-44"><a class="header" href="#description-44">Description</a></h2>
<h3 id="introduction-13"><a class="header" href="#introduction-13">Introduction</a></h3>
<p>The base layer is slow. The DAN is fast. However, every DAN instruction that results in a state change has a fee (i.e.
base layer transaction) associated with it.<br />
To bridge the speed gap between the two layers, a payment channel solution is required.<br />
This document provides the high-level overview of how this is done.</p>
<h3 id="the-clacks"><a class="header" href="#the-clacks">The Clacks</a></h3>
<p>The Clacks is a multi-party side-channel off-chain scalability proposal for Tari. The essential idea behind the Clacks
is:</p>
<ul>
<li>Users give control of some Tari to a Clacks Committee.</li>
<li>The committee creates an off-chain UTXO for the user(s). This is called the peg-in transaction.</li>
<li>Users can transact amongst each other without those transactions touching the base layer. This allows a very high
throughput of transactions and instant finality. However, the locus of trust move significantly towards the Clacks
committee. In other words, base layer transactions are slow, but do not require users to trust anyone. Clacks
transactions are fast, but requires some level of trust in the entity or entities controlling the user's funds.</li>
<li>Users can send off-chain Tari to any other users, including users that have not made deposits into the Clacks
committee.</li>
<li>Users can request a withdrawal for their Tari at any time. At predefined intervals, the Clacks committee will process
those withdrawal requests and give the Tari UTXO control back to the user.</li>
</ul>
<p>Users also have a pre-signed, time-locked transaction that returns the user's fund back to them. This refund transaction
can be used in case the Clacks committee stops processing withdrawals and provides insurance for users against having
their funds locked up forever.</p>
<p>The peg-in, peg-out cycle are represented by standard Tari transactions. This means that full nodes verify that no funds
have been created or destroyed over the course of the cycle. They do not check that the &quot;balances&quot; associated with users
are what those users would expect in an honestly run side-chain.</p>
<p>However, if the side-chain is run as a standard mimblewimble process, any third party running a full node and that
access to the opening and closing channel balances, can in fact verify that the committee has operated honestly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-"><a class="header" href="#-"><RFC-Number>-<Short Title></a></h1>
<h2 id=""><a class="header" href="#"><Long title></a></h2>
<p><img src="theme/images/status-raw.svg" alt="status: raw" /></p>
<p>Tracking issue: <a href="">assigned during WIP phase</a></p>
<p><strong>Maintainer(s)</strong>: <Maintainer name> <github username></p>
<h1 id="licence-62"><a class="header" href="#licence-62">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause"> The 3-Clause BSD Licence</a>.</p>
<p>Copyright <YEAR> &lt;COPYRIGHT HOLDER | The Tari Development Community&gt;</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h2 id="language-66"><a class="header" href="#language-66">Language</a></h2>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all capitals, as
shown here.</p>
<h2 id="disclaimer-66"><a class="header" href="#disclaimer-66">Disclaimer</a></h2>
<p>This document and its content are intended for information purposes only and may be subject to change or update
without notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community regarding the
technological merits of the potential system outlined herein.</p>
<h2 id="goals-65"><a class="header" href="#goals-65">Goals</a></h2>
<h2 id="related-requests-for-comment-56"><a class="header" href="#related-requests-for-comment-56">Related Requests for Comment</a></h2>
<h2 id="description-45"><a class="header" href="#description-45">Description</a></h2>
<h1 id="change-log-39"><a class="header" href="#change-log-39">Change Log</a></h1>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Date</th><th style="text-align: left">Change</th><th style="text-align: left">Author</th></tr></thead><tbody>
<tr><td style="text-align: left">dd mmm YYYY</td><td style="text-align: left">Short desc</td><td style="text-align: left">Author</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="tari-network-terminology"><a class="header" href="#tari-network-terminology">Tari Network Terminology</a></h1>
<p>Below are a list of terms and their definitions that are used throughout the Tari code and documentation. Let's use this
glossary to disambiguate ideas, and work towards a
<a href="https://blog.carbonfive.com/2016/10/04/ubiquitous-language-the-joy-of-naming/">ubiquitous language</a> for this project.</p>
<h2 id="archive-node"><a class="header" href="#archive-node">Archive node</a></h2>
<p>This is a full history <a href="Glossary.html#base-node" title="A full Tari node running on the base layer, validating and propagating Tari coin transactions
and blocks">base node</a>. It will keep a complete history of every transaction ever received and it will not
implement pruning.</p>
<h2 id="assetcollateral"><a class="header" href="#assetcollateral">AssetCollateral</a></h2>
<p>The amount of tari coin that a <a href="Glossary.html#validator-node" title="A second-layer node that manages and validates digital asset state transitions">Validator Node</a> must put up on the <a href="Glossary.html#base-layer" title="The Tari layer handling payments and secured by proof of work">base layer</a> in order to become part of an asset
<a href="Glossary.html#committee" title="A group of validator nodes that are responsible for managing a specific Digital Asset">committee</a>.</p>
<h2 id="asset-issuer"><a class="header" href="#asset-issuer">Asset Issuer</a></h2>
<p>An entity that creates digital assets on the Tari DAN. The Asset Issuer will specify the parameters of the contract
template that defines the rules that govern the asset and the number and nature of its constituent tokens on issuance.
The Asset Issuer will, generally, be the initial owner of the tokens.</p>
<h2 id="bad-actor"><a class="header" href="#bad-actor">Bad Actor</a></h2>
<p>A participant that acts maliciously or negligently to the detriment of the network or another participant.</p>
<h2 id="base-layer-1"><a class="header" href="#base-layer-1">Base layer</a></h2>
<p>The Tari Base layer is a merge-mined <a href="Glossary.html#blockchain" title="The linked sequence of Tari blocks on the Tari base layer">blockchain</a> secured by proof-of-work. The base layer is primarily responsible for
the emission of new Tari, for securing and managing <a href="Glossary.html#tari-coin" title="The base layer token">Tari coin</a> transfers.</p>
<h2 id="base-node"><a class="header" href="#base-node">Base Node</a></h2>
<p>A full Tari node running on the base layer. It's primary role is validating and propagating <a href="Glossary.html#tari-coin" title="The base layer token">Tari coin</a> transactions
and blocks to the rest of the network.</p>
<h2 id="block"><a class="header" href="#block">Block</a></h2>
<p>A collection of transactions and associated metadata recorded as a single entity in the Tari blockchain. The ordering of
Tari transactions is set purely by the block height of the block they are recorded in.</p>
<h2 id="block-header-2"><a class="header" href="#block-header-2">Block Header</a></h2>
<p>A data structure that validates the information contained in a <a href="Glossary.html#block" title="A collection of transactions and associated metadata recorded as a single entity in the Tari blockchain">block</a>.</p>
<h2 id="block-body-1"><a class="header" href="#block-body-1">Block Body</a></h2>
<p>A data structure containing the transaction inputs, outputs, and kernels that make up the block.</p>
<h2 id="block-reward"><a class="header" href="#block-reward">Block reward</a></h2>
<p>The amount of Tari created by the coinbase transaction in every block. The block reward is set by the
<a href="Glossary.html#emission-schedule">emission schedule</a>.</p>
<h2 id="blockchain"><a class="header" href="#blockchain">Blockchain</a></h2>
<p>A sequence of tari <a href="Glossary.html#block" title="A collection of transactions and associated metadata recorded as a single entity in the Tari blockchain">block</a>s. Each block contains a hash of the previous valid block. Thus the blocks form a chain
with the property that changing anything in a block other than the head block requires rewriting the entire
blockchain from that point on.</p>
<h2 id="blockchain-state"><a class="header" href="#blockchain-state">Blockchain state</a></h2>
<p>The complete state of the blockchain at a specific block height. This means a pruned <a href="Glossary.html#unspent-transaction-outputs">utxo</a> set, a complete set of
kernels and headers up to that block height from the genesis block.</p>
<h2 id="broadcaststrategy"><a class="header" href="#broadcaststrategy">BroadcastStrategy</a></h2>
<p>A strategy for propagating messages amongst nodes in a peer-to-peer network. Example implementations of
<code>BroadcastStrategy</code> include the Gossip protocol and flood fill.</p>
<h2 id="chain-reorganization"><a class="header" href="#chain-reorganization">Chain Reorganization</a></h2>
<p>A chain reorganization occurs after a chain split occurs on the network, which commonly occurs due to network latency
and connectivity issues. When a chain split occurs one chain will have the higher accumulated proof-of-work, this chain
is considered the best chain. Nodes on the poorer chain will need to rewind and resync their chains to best chain. In 
this process transaction in the mempool could become orphaned or invalid.</p>
<h2 id="checkpoint"><a class="header" href="#checkpoint">Checkpoint</a></h2>
<p>A hash of the state of a Digital Asset that is recorded on the base layer.</p>
<h2 id="coinbase-transaction"><a class="header" href="#coinbase-transaction">Coinbase transaction</a></h2>
<p>The first transaction in every Tari block yields a <a href="Glossary.html#block-reward" title="The amount of Tari created in every block">Block Reward</a> according to the Tari <a href="Glossary.html#emission-schedule">emission Schedule</a> and is
awarded to the miner that performed the Proof of Work for the block.</p>
<h2 id="coinbase-extra"><a class="header" href="#coinbase-extra">Coinbase extra</a></h2>
<p>An arbitrary 64 bytes can be included with the coinbase utxo that can be used to store any data. This can be used to identify the pool that mined the
block for example or a Merkle root used when merge mining with Tari as the parent chain.</p>
<h2 id="committee"><a class="header" href="#committee">Committee</a></h2>
<p>A group of <a href="Glossary.html#validator-node" title="A second-layer node that manages and validates digital asset state transitions">Validator Node</a>s that are responsible for managing the state of a specific <a href="Glossary.html#digital-asset" title="Sets of Native digital tokens, both fungible and non-fungible that are created by
asset issuers on the Tari 2nd layer">Digital Asset</a>. A committee is
selected during asset issuance and can be updated at <a href="Glossary.html#checkpoint" title="A summary of the state of a Digital Asset that is recorded on the base layer">Checkpoint</a>s.</p>
<h2 id="committeeselectionstrategy"><a class="header" href="#committeeselectionstrategy">CommitteeSelectionStrategy</a></h2>
<p>A strategy for an Asset Issuer to select candidates for the committee from the available registered Validator Nodes who
responded to the nomination call for that asset.</p>
<h2 id="consensusstrategy"><a class="header" href="#consensusstrategy">ConsensusStrategy</a></h2>
<p>The approach that will be taken for a committee to reach consensus on the validity of instructions that are performed
on a given Digital Asset.</p>
<h2 id="commitment-1"><a class="header" href="#commitment-1">Commitment</a></h2>
<p>A commitment is a cryptographic primitive that allows one to commit to a chosen value while keeping it hidden from
others, with the ability to reveal the committed value later. Commitments are designed so that one cannot change the
value or statement after they have committed to it.</p>
<h2 id="commitment-and-public-key-signature"><a class="header" href="#commitment-and-public-key-signature">Commitment and Public Key Signature</a></h2>
<p>A mathematical assertion of knowledge of the opening of a <a href="Glossary.html#commitment">commitment</a> and the private key corresponding to a public key, and
which is bound to a message to produce a signature. In the context of Tari protocols, it is used to construct a
<a href="Glossary.html#metadata-signature">metadata signature</a> and script signature for transactions.</p>
<p>Specifically, it is a Schnorr-type conjunction proof that uses the Fiat-Shamir technique for message binding.</p>
<h2 id="communication-node"><a class="header" href="#communication-node">Communication Node</a></h2>
<p>A Communication Node is either a Validator Node or Base Node that is part of the Tari communication network. It
maintains the network and is responsible for forwarding and propagating joining requests, discovery requests and data
messages on the communication network.</p>
<h2 id="communication-client"><a class="header" href="#communication-client">Communication Client</a></h2>
<p>A Communication Client is a Wallet or Asset Manager that makes use of the Tari communication network to send joining and
discovery requests. A Communication Client does not maintain the communication network and is not responsible for
forwarding or propagating any requests or data messages.</p>
<h2 id="creator-nomination-mode"><a class="header" href="#creator-nomination-mode">Creator Nomination Mode</a></h2>
<p>An asset runs in creator nomination mode when <em>every</em> validator node in a validator committee is a <a href="Glossary.html#trusted-node" title="A permissioned Validator Node nominated by an Asset Issuer">Trusted Node</a> that
was directly nominated by the <a href="Glossary.html#asset-issuer" title="An entity that creates digital assets on the Tari DAN">Asset Issuer</a>.</p>
<h2 id="current-head"><a class="header" href="#current-head">Current head</a></h2>
<p>The last <a href="Glossary.html#block" title="A collection of transactions and associated metadata recorded as a single entity in the Tari blockchain">block</a> of the base layer that represents the latest valid block. This <a href="Glossary.html#block" title="A collection of transactions and associated metadata recorded as a single entity in the Tari blockchain">block</a> must be from the longest
proof-of-work chain to be the current head.</p>
<h2 id="cut-through-1"><a class="header" href="#cut-through-1">Cut-Through</a></h2>
<p>Cut-through is the process where outputs spent within a single block may be removed without breaking the standard <a href="Glossary.html#mimblewimble">MimbleWimble</a>
validation rules. Simplistically, <code>Alice -&gt; Bob -&gt; Carol</code> may be &quot;cut-through&quot; to <code>Alice -&gt; Carol</code>. Bob's commitments may be removed.</p>
<p>On Tari, for reasons described in <a href="./RFC-0201_TariScript.html#utxo-data-commitments">RFC-0201_TariScript</a>, cut-through is prevented from ever happening.</p>
<h2 id="digital-asset"><a class="header" href="#digital-asset">Digital asset</a></h2>
<p>Digital assets (DAs) are the sets or collections of native digital tokens (both fungible and non-fungible) that are
created by <a href="Glossary.html#asset-issuer" title="An entity that creates digital assets on the Tari DAN">asset issuer</a>s on the Tari 2nd layer. For example, a promoter might create a DA for a music concert event.
The event is the digital asset, and the tickets for the event are digital asset <a href="Glossary.html#digital-asset-tokens" title="or just, &quot;tokens&quot;. The tokens associated with a given digital asset. Tokens are created
 by asset issuers">tokens</a>.</p>
<h2 id="digital-asset-network"><a class="header" href="#digital-asset-network">Digital Asset Network</a></h2>
<p>The Tari second layer. All digital asset interactions are managed on the Tari Digital Assets Network (DAN). These
interactions (defined in <a href="Glossary.html#instructions" title="Second-layer network commands for managing digital asset state">instruction</a>s) are processed and validated by <a href="Glossary.html#validator-node" title="A second-layer node that manages and validates digital asset state transitions">Validator Node</a>s.</p>
<h2 id="digitalassettemplate"><a class="header" href="#digitalassettemplate">DigitalAssetTemplate</a></h2>
<p>A DigitalAssetTemplate is one of a set of contract types supported by the DAN. These contracts are non-turing complete
and consist of rigid rule-sets with parameters that can be set by Asset Issuers.</p>
<h2 id="digital-asset-tokens"><a class="header" href="#digital-asset-tokens">Digital asset tokens</a></h2>
<p>Digital asset tokens (or often, just &quot;tokens&quot;) are the finite set of digital entities associated with a given digital
asset. Depending on the DA created, tokens can represent tickets, in-game items, collectibles or loyalty points. They
are bound to the <a href="Glossary.html#digital-asset" title="Sets of Native digital tokens, both fungible and non-fungible that are created by
asset issuers on the Tari 2nd layer">digital asset</a> that created them.</p>
<h2 id="hashed-time-locked-contract-1"><a class="header" href="#hashed-time-locked-contract-1">Hashed Time Locked Contract</a></h2>
<p>A time locked contract that only pays out after a certain criteria has been met or refunds the originator if a certain
period has expired.</p>
<h2 id="emission-schedule"><a class="header" href="#emission-schedule">Emission schedule</a></h2>
<p>An explicit formula as a function of the block height, <em>h</em>, that determines the block reward for the
<em>h</em><sup>th</sup> block.</p>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<p>Instructions are the <a href="Glossary.html#digital-asset-network" title="The Tari second layer. All digital asset interactions are managed here.">digital asset network</a> equivalent of <a href="Glossary.html#transaction" title="Base layer tari coin transfers.">transaction</a>s. Instructions are issued by asset issuers and
client applications and are relayed by the DAN to the <a href="Glossary.html#validator-node" title="A second-layer node that manages and validates digital asset state transitions">validator node</a>s that are managing the associated
<a href="Glossary.html#digital-asset" title="Sets of Native digital tokens, both fungible and non-fungible that are created by
asset issuers on the Tari 2nd layer">digital asset</a>.</p>
<h2 id="mempool-1"><a class="header" href="#mempool-1">Mempool</a></h2>
<p>The mempool consists of the unconfirmed pool and reorg pool, and is responsible for managing
unconfirmed transactions that have not yet been included in the longest proof-of-work chain. Miners usually draw
verified transactions from the mempool to build up transaction <a href="Glossary.html#block" title="A collection of transactions and associated metadata recorded as a single entity in the Tari blockchain">block</a>s.</p>
<h2 id="metadata-signature"><a class="header" href="#metadata-signature">Metadata Signature</a></h2>
<p>The metadata signature is a <a href="Glossary.html#commitment-and-public-key-signature">commitment and public key signature</a>, attached to a transaction output and
signed with a combination of the homomorphic commitment private values \( (v_i \, , \, k_i )\), the spending key
known only to the receiver, and sender offset private key \(k_{Oi}\) known only to the sender. This prevents
malleability of the UTXO metadata.</p>
<h2 id="script-signature"><a class="header" href="#script-signature">Script Signature</a></h2>
<p>The script signature is an aggregated Commitment Signature (&quot;ComSig&quot;) signature, attached to a transaction input and
signed with a combination of the homomorphic commitment private values \( (v_i \, , \, k_i )\), the spending key
known only to the sender, and script private key \(k_{Si}\) known only to the sender. This ensures that the script is valid
and that the input data has not changed.</p>
<h2 id="mimblewimble"><a class="header" href="#mimblewimble">Mimblewimble</a></h2>
<p>Mimblewimble is a privacy-centric cryptocurrency protocol. It was
<a href="https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.txt">dropped</a> in the Bitcoin Developers chatroom by an
anonymous author and has since been refined by several authors, including Andrew Poelstra.</p>
<h2 id="mining-server"><a class="header" href="#mining-server">Mining Server</a></h2>
<p>A Mining Server is responsible for constructing new blocks by bundling transactions from the <a href="Glossary.html#mempool" title="A memory pool for unconfirmed transactions on the base layer">mempool</a> of a connected
<a href="Glossary.html#base-node" title="A full Tari node running on the base layer, validating and propagating Tari coin transactions
and blocks">Base Node</a>. It also distributes Proof-of-Work tasks to Mining Workers and verifies PoW solutions.</p>
<h2 id="mining-worker"><a class="header" href="#mining-worker">Mining Worker</a></h2>
<p>A Mining Worker is responsible for performing Proof-of-Work tasks received from its parent <a href="Glossary.html#mining-server">Mining Server</a>.</p>
<h2 id="multisig"><a class="header" href="#multisig">Multisig</a></h2>
<p>Multi-signatures (Multisigs) are also known as N-of-M signatures, this means that a minimum of N number of the M peers
need to agree before a transaction can be spent. N and M can be equal; which is a special case and is often referred to
as an N-of-N Multisig.</p>
<p><a href="https://tlu.tarilabs.com/cryptography/musig-schnorr-sig-scheme/The_MuSig_Schnorr_Signature_Scheme.html">TLU musig</a></p>
<h2 id="node-id-1"><a class="header" href="#node-id-1">Node ID</a></h2>
<p>A node ID is a unique identifier that specifies the location of a <a href="Glossary.html#communication-node" title="A communication node that is responsible for maintaining the Tari
communication network">communication node</a> or <a href="Glossary.html#communication-client" title="A communication client that makes use of the Tari communication network,
but does not maintain it">communication client</a> in the
Tari communication network. The node ID can either be obtained from registration on the <a href="Glossary.html#base-layer" title="The Tari layer handling payments and secured by proof of work">Base Layer</a> or can be derived
from the public identification key of a <a href="Glossary.html#communication-node" title="A communication node that is responsible for maintaining the Tari
communication network">communication node</a> or <a href="Glossary.html#communication-client" title="A communication client that makes use of the Tari communication network,
but does not maintain it">communication client</a>.</p>
<h2 id="non-fungible-token-nft"><a class="header" href="#non-fungible-token-nft">Non-fungible Token (NFT)</a></h2>
<p>A Non-fungible token is a specific instance of a token issued as part of a <a href="Glossary.html#digital-asset" title="Sets of Native digital tokens, both fungible and non-fungible that are created by
asset issuers on the Tari 2nd layer">digital asset</a>. It is another name for a
[digital asset token]. NFTs are contained within specially marked <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s on the Tari Base Layer.</p>
<h2 id="orphan-pool"><a class="header" href="#orphan-pool">Orphan Pool</a></h2>
<p>The orphan pool is part of the <a href="Glossary.html#mempool" title="A memory pool for unconfirmed transactions on the base layer">mempool</a> and manages all <a href="Glossary.html#transaction" title="Base layer tari coin transfers.">transaction</a>s that have been verified but attempt to spend
<a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s that do not exist or haven't been created yet.</p>
<h2 id="pending-pool"><a class="header" href="#pending-pool">Pending Pool</a></h2>
<p>The pending pool is part of the <a href="Glossary.html#mempool" title="A memory pool for unconfirmed transactions on the base layer">mempool</a> and manages all <a href="Glossary.html#transaction" title="Base layer tari coin transfers.">transaction</a>s that have a time-lock restriction on when it
can be processed or attempts to spend <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s with time-locks.</p>
<h2 id="pruned-node"><a class="header" href="#pruned-node">Pruned Node</a></h2>
<p>This is a pruned history <a href="Glossary.html#base-node" title="A full Tari node running on the base layer, validating and propagating Tari coin transactions
and blocks">base node</a>. It uses cryptography of <a href="Glossary.html#mimblewimble" title="a privacy-centric cryptocurrency protocol">mimblewimble</a> to allow the removal of spent inputs and
outputs beyond the <a href="Glossary.html#pruning-horizon" title="Block height at which pruning will commence">pruninghorizon</a>.</p>
<p>It can still validate the integrity of the blockchain i.e. no coins were destroyed or created beyond what is allowed by
consensus rules. A sufficient number of blocks back from the tip should be configured because reorgs are no longer
possible beyond that horizon.</p>
<h2 id="pruning-horizon"><a class="header" href="#pruning-horizon">Pruning Horizon</a></h2>
<p>This is a local setting for each node to help reduce syncing time and bandwidth. This is the number of blocks from the
chain tip beyond which a chain will be pruned.</p>
<h2 id="public-nomination-mode"><a class="header" href="#public-nomination-mode">Public Nomination Mode</a></h2>
<p>An asset runs in public nomination mode when the <a href="Glossary.html#asset-issuer" title="An entity that creates digital assets on the Tari DAN">Asset Issuer</a> broadcasts a call for nominations to the network and VNs
from the network nominate themselves as candidates to become members of the <a href="Glossary.html#committee" title="A group of validator nodes that are responsible for managing a specific Digital Asset">committee</a> for the asset. The
<a href="Glossary.html#asset-issuer" title="An entity that creates digital assets on the Tari DAN">Asset Issuer</a> will then employ the <a href="Glossary.html#committeeselectionstrategy" title="A strategy for an Asset Issuer to select candidates for the
committee from the available registered Validator Nodes who responded to the nomination call for that asset">CommitteeSelectionStrategy</a> to select the committee from the list of available
candidates.</p>
<h2 id="range-proof"><a class="header" href="#range-proof">Range proof</a></h2>
<p>A mathematical demonstration that a value inside a <a href="Glossary.html#commitment">commitment</a> (i.e. it is hidden) lies within a certain range. For
<a href="Glossary.html#mimblewimble" title="a privacy-centric cryptocurrency protocol">Mimblewimble</a>, range proofs are used to prove that outputs are positive values.</p>
<h2 id="registration-deposit"><a class="header" href="#registration-deposit">Registration Deposit</a></h2>
<p>An amount of tari coin that is locked up on the base layer when a <a href="Glossary.html#validator-node" title="A second-layer node that manages and validates digital asset state transitions">Validator Node</a> is registered. In order to make Sybil
attacks expensive and to provide an authorative base layer registry of <a href="Glossary.html#validator-node" title="A second-layer node that manages and validates digital asset state transitions">validator node</a>s they will need to lock up a
amount of <a href="Glossary.html#tari-coin" title="The base layer token">Tari Coin</a> on the <a href="Glossary.html#base-layer" title="The Tari layer handling payments and secured by proof of work">Base Layer</a> using a registration transaction to begin acting as a VN on the DAN.</p>
<h2 id="registration-term"><a class="header" href="#registration-term">Registration Term</a></h2>
<p>The minimum amount of time that a VN registration lasts, the <a href="Glossary.html#registration-deposit" title="An amount of tari coin that is locked up on the base layer when a
[Validator Node] is registered">Registration Deposit</a> can only be released after this
minimum period has elapsed.</p>
<h2 id="reorg-pool-1"><a class="header" href="#reorg-pool-1">Reorg Pool</a></h2>
<p>The reorg pool is part of the <a href="Glossary.html#mempool" title="A memory pool for unconfirmed transactions on the base layer">mempool</a> and stores all <a href="Glossary.html#transaction" title="Base layer tari coin transfers.">transaction</a>s that have recently been included in blocks in case
a blockchain reorganization occurs and the transactions need to be restored to the <a href="Glossary.html#transaction-pool" title="A pool in the Mempool for valid and verified unconfirmed transactions">transaction pool</a>.</p>
<h2 id="script-keypair"><a class="header" href="#script-keypair">Script Keypair</a></h2>
<p>The script private - public keypair, \((k_{Si}\),\(K_{Si})\), is used in <a href="Glossary.html#tariscript" title="The Tari scripting system for transactions">TariScript</a> to unlock and execute the
script associated with an output. Afterwards the execution stack must contain exactly one value that must be equal to
the script public key.</p>
<h2 id="script-offset-1"><a class="header" href="#script-offset-1">Script Offset</a></h2>
<p>The script offset provides a proof that every script public key \( K_{Si} \) and sender offset public key
\( K_{Oi} \) provided for the a transaction's inputs and outputs are correct.</p>
<h2 id="sender-offset-keypair"><a class="header" href="#sender-offset-keypair">Sender Offset Keypair</a></h2>
<p>The sender offset private - public keypair, (\( k_{Oi} \),\( K_{Oi} \)), is used by the sender of an output to
lock all its metadata by virtue of a <a href="Glossary.html#metadata-signature">metadata signature</a>.</p>
<h2 id="spending-key"><a class="header" href="#spending-key">Spending Key</a></h2>
<p>A private spending key is a private key that permits spending of a <a href="Glossary.html#unspent-transaction-outputs">UTXO</a>. It is also sometimes referred to as a
Blinding Factor, since is Tari (and Mimblewimble) outputs, the value of a UTXO is <em>blinded</em> by the spending key:</p>
<p>$$ C = v.H + k.G $$</p>
<p>The public key, \(P = k.G\) is known as the <em>public</em> spending key.</p>
<h2 id="synchronisationstate"><a class="header" href="#synchronisationstate">SynchronisationState</a></h2>
<p>The current synchronisation state of a <a href="Glossary.html#base-node" title="A full Tari node running on the base layer, validating and propagating Tari coin transactions
and blocks">Base Node</a>. This can either be</p>
<ul>
<li><code>starting</code> - The node has freshly started up and is still waiting for first round of chain_metadata responses from its 
neighbours on which to base its next state change.</li>
<li><code>header_sync</code> - The node is in the process of synchronising headers with chosen sync peer.</li>
<li><code>horizon_sync</code> - The node is in the process of syncing blocks from the tip to its [pruning horizon]</li>
<li><code>block_sync</code> -   The node is in the process of syncing all blocks back to the genesis block</li>
<li><code>listening</code> - The node has completed its syncing strategy and will continue to listen for new blocks and monitor
its neighbours to detect if it falls behind.</li>
</ul>
<h2 id="synchronisationstrategy"><a class="header" href="#synchronisationstrategy">SynchronisationStrategy</a></h2>
<p>The generalised approach for a <a href="Glossary.html#base-node" title="A full Tari node running on the base layer, validating and propagating Tari coin transactions
and blocks">Base Node</a> to obtain the current state of the blockchain from the peer-to-peer network.
Specific implementations may differ based on different trade-offs and constraints with respect to bandwidth, local
network conditions etc.</p>
<h2 id="tari-coin"><a class="header" href="#tari-coin">Tari Coin</a></h2>
<p>The base layer token. Tari coins are released according to the <a href="Glossary.html#emission-schedule">emission schedule</a> on the Tari <a href="Glossary.html#base-layer" title="The Tari layer handling payments and secured by proof of work">base layer</a>
<a href="Glossary.html#blockchain" title="The linked sequence of Tari blocks on the Tari base layer">blockchain</a> in <a href="Glossary.html#coinbase-transaction">coinbase transaction</a>s.</p>
<h2 id="tariscript-4"><a class="header" href="#tariscript-4">TariScript</a></h2>
<p>Tari uses a scripting system for transactions, not unlike <a href="https://en.bitcoin.it/wiki/Script">Bitcoin's scripting system</a>,
called TariScript. It is also simple, stack-based, processed from left to right, not Turing-complete, with no loops. It
is a list of instructions linked in a non malleable way to each output, specifying its conditions of spending.</p>
<h2 id="total-accumulated-difficulty"><a class="header" href="#total-accumulated-difficulty">Total Accumulated difficulty</a></h2>
<p>The Accumulated difficulty of the chain is used to compare chain tips. Every block has a total accumulated difficulty that is calculated as 
the sum of all achieved difficulties of Sha3 blocks multiplied by he sum of all achieved difficulties of RandomX blocks. This is represented as an u128.</p>
<h2 id="transaction"><a class="header" href="#transaction">Transaction</a></h2>
<p>Transactions are activities recorded on the Tari <a href="Glossary.html#blockchain" title="The linked sequence of Tari blocks on the Tari base layer">blockchain</a> running on the <a href="Glossary.html#base-layer" title="The Tari layer handling payments and secured by proof of work">base layer</a>. Transactions always involve a
transfer of <a href="Glossary.html#tari-coin" title="The base layer token">Tari coin</a>s. A <a href="Glossary.html#mimblewimble">mimblewimble</a> transaction body consists of one or more blinded inputs and outputs.</p>
<h2 id="transaction-pool"><a class="header" href="#transaction-pool">Transaction Pool</a></h2>
<p>The transaction pool is part of the <a href="Glossary.html#mempool" title="A memory pool for unconfirmed transactions on the base layer">mempool</a> and manages all <a href="Glossary.html#transaction" title="Base layer tari coin transfers.">transaction</a>s that have been verified, that spend valid
<a href="Glossary.html#unspent-transaction-outputs">UTXO</a>s and don't have any time-lock restrictions.</p>
<h2 id="trusted-node"><a class="header" href="#trusted-node">Trusted Node</a></h2>
<p>A permissioned Validator Node nominated by an Asset Issuer that will form part of the committee for that Digital Asset.</p>
<h2 id="token-wallet"><a class="header" href="#token-wallet">Token Wallet</a></h2>
<p>A Tari Token Wallet is responsible for managing <a href="Glossary.html#digital-asset" title="Sets of Native digital tokens, both fungible and non-fungible that are created by
asset issuers on the Tari 2nd layer">Digital asset</a>s and <a href="Glossary.html#digital-asset-tokens" title="or just, &quot;tokens&quot;. The tokens associated with a given digital asset. Tokens are created
 by asset issuers">Tokens</a>, and for constructing and negotiating
<a href="Glossary.html#instructions" title="Second-layer network commands for managing digital asset state">instruction</a>s for transferring and receiving Assets and Tokens on the <a href="Glossary.html#digital-asset-network" title="The Tari second layer. All digital asset interactions are managed here.">Digital Asset Network</a>.</p>
<h2 id="transaction-weight"><a class="header" href="#transaction-weight">Transaction Weight</a></h2>
<p>The weight of a transaction / block measured in &quot;grams&quot;. 
See <a href="./RFC-0110_BaseNodes.html#blocktransaction-weight">Block / Transaction weight</a> for more details.</p>
<h2 id="unspent-transaction-outputs"><a class="header" href="#unspent-transaction-outputs">Unspent transaction outputs</a></h2>
<p>An unspent transaction output (UTXO) is a discrete number of Tari that are available to be spent. The sum of all
UTXOs represents all the Tari currently in circulation. In addition, the sum of all UTXO values equals the sum of the
<a href="Glossary.html#block-reward" title="The amount of Tari created in every block">block reward</a>s for all blocks up to the current block height.</p>
<p>UTXO values are hidden by their <a href="Glossary.html#commitment">commitment</a>s. Only the owner of the UTXO and (presumably) the creator of the UTXO
(either a <a href="Glossary.html#coinbase-transaction">Coinbase transaction</a> or previous spender) know the value of the UTXO.</p>
<h2 id="transaction-kernel-1"><a class="header" href="#transaction-kernel-1">Transaction Kernel</a></h2>
<p>A piece of data that is always kept as part of the blockchain and never pruned away. This contains the excess signature and
serves as proof that the parties transacting know the blinding factors of their <a href="Glossary.html#commitment">commitment</a>s used in the transaction.</p>
<h2 id="validator-node"><a class="header" href="#validator-node">Validator Node</a></h2>
<p>Validator nodes (VNs) make up the Tari second layer, or <a href="Glossary.html#digital-asset-network" title="The Tari second layer. All digital asset interactions are managed here.">Digital Asset Network</a>. VNs are responsible for creating and
updating <a href="Glossary.html#digital-asset" title="Sets of Native digital tokens, both fungible and non-fungible that are created by
asset issuers on the Tari 2nd layer">digital asset</a>s living on the Tari network.</p>
<h2 id="validator-node-committee"><a class="header" href="#validator-node-committee">Validator Node committee</a></h2>
<p>Validator nodes (VNs) validate and execute instructions on the Digital Assets Network (DAN). They are also responsible for maintaining state in DAN assets.</p>
<h2 id="wallet"><a class="header" href="#wallet">Wallet</a></h2>
<p>A Tari Wallet is responsible for managing key pairs, and for constructing and negotiating <a href="Glossary.html#transaction" title="Base layer tari coin transfers.">transaction</a>s for
transferring and receiving <a href="Glossary.html#tari-coin" title="The base layer token">tari coin</a>s on the <a href="Glossary.html#base-layer" title="The Tari layer handling payments and secured by proof of work">Base Layer</a>.</p>
<h1 id="disclaimer-67"><a class="header" href="#disclaimer-67">Disclaimer</a></h1>
<p>This document is subject to the <a href="../DISCLAIMER.html">disclaimer</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <script src=" https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js "></script>
        <script>mermaid.initialize({startOnLoad:true});</script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
