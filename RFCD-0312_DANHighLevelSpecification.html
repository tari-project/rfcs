<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0312: High level Digital Asset Network Specification - The Tari Network: RFC library</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Tari network RFC library and documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
            }
          });
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-0Q69T0B1T4"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-0Q69T0B1T4');
        </script>

    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = 'light';
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <img src="theme/images/tari-splash.png" class="tlu">

            <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About the Tari RFC documents</a></li><li class="chapter-item expanded "><a href="RFC-0001_overview.html"><strong aria-hidden="true">1.</strong> RFC-0001: An overview of the Tari network</a></li><li class="chapter-item expanded "><a href="base_layer.html"><strong aria-hidden="true">2.</strong> The Tari Base Layer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0110_BaseNodes.html"><strong aria-hidden="true">2.1.</strong> RFC-0110: Base nodes</a></li><li class="chapter-item expanded "><a href="RFC-0111_BaseNodeArchitecture.html"><strong aria-hidden="true">2.2.</strong> RFC-0111: Base node architecture</a></li><li class="chapter-item expanded "><a href="RFC-0120_Consensus.html"><strong aria-hidden="true">2.3.</strong> RFC-0120: Consensus rules</a></li><li class="chapter-item expanded "><a href="RFC-0131_Mining.html"><strong aria-hidden="true">2.4.</strong> RFC-0131: Mining</a></li><li class="chapter-item expanded "><a href="RFC-0132_Merge_Mining_Monero.html"><strong aria-hidden="true">2.5.</strong> RFC-0132: Merge Mining Monero</a></li><li class="chapter-item expanded "><a href="RFC-0140_Syncing_and_seeding.html"><strong aria-hidden="true">2.6.</strong> RFC-0140: Synchronizing the Blockchain: Archival and Pruned modes</a></li><li class="chapter-item expanded "><a href="RFC-0150_Wallets.html"><strong aria-hidden="true">2.7.</strong> RFC-0150: Wallets</a></li><li class="chapter-item expanded "><a href="RFC-0152_EmojiId.html"><strong aria-hidden="true">2.8.</strong> RFC-0152: Emoji ID</a></li><li class="chapter-item expanded "><a href="RFC-0160_BlockSerialization.html"><strong aria-hidden="true">2.9.</strong> RFC-0160: Block Binary Serialization</a></li><li class="chapter-item expanded "><a href="RFC-0170_NetworkCommunicationProtocol.html"><strong aria-hidden="true">2.10.</strong> RFC-0170: Network Communication Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0171_MessageSerialisation.html"><strong aria-hidden="true">2.10.1.</strong> RFC-0171: Message Serialisation</a></li><li class="chapter-item expanded "><a href="RFC-0172_PeerToPeerMessagingProtocol.html"><strong aria-hidden="true">2.10.2.</strong> RFC-0172: Peer to Peer Messaging Protocol</a></li><li class="chapter-item expanded "><a href="RFC-0173_Versioning.html"><strong aria-hidden="true">2.10.3.</strong> RFC-0173: Versioning</a></li><li class="chapter-item expanded "><a href="RFC-0174_Chat_Metadata.html"><strong aria-hidden="true">2.10.4.</strong> RFC-0174: Chat Metadata</a></li></ol></li><li class="chapter-item expanded "><a href="RFC-0181_BulletproofsPlus.html"><strong aria-hidden="true">2.11.</strong> RFC-0181: Bulletproofs+ range proving</a></li><li class="chapter-item expanded "><a href="RFC-0182_CommitmentSignatures.html"><strong aria-hidden="true">2.12.</strong> RFC-0182: Commitment signatures</a></li><li class="chapter-item expanded "><a href="RFC-0190_Mempool.html"><strong aria-hidden="true">2.13.</strong> RFC-0190: Mempool</a></li><li class="chapter-item expanded "><a href="BaseLayerExtensions.html"><strong aria-hidden="true">2.14.</strong> Tari-specific extensions to Mimblewimble</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0201_TariScript.html"><strong aria-hidden="true">2.14.1.</strong> RFC-0201: TariScript</a></li><li class="chapter-item expanded "><a href="RFC-0202_TariScriptOpcodes.html"><strong aria-hidden="true">2.14.2.</strong> RFC-0202: TariScript Opcodes</a></li><li class="chapter-item expanded "><a href="RFC-0204_TariScriptExamples.html"><strong aria-hidden="true">2.14.3.</strong> RFC-0204: TariScript Examples</a></li><li class="chapter-item expanded "><a href="RFC-0203_StealthAddresses.html"><strong aria-hidden="true">2.14.4.</strong> RFC-0203: Stealth Addresses</a></li><li class="chapter-item expanded "><a href="RFC-0205_HardwareTransactions.html"><strong aria-hidden="true">2.14.5.</strong> RFC-0205: Hardware Transactions</a></li><li class="chapter-item expanded "><a href="RFC-0250_Covenants.html"><strong aria-hidden="true">2.14.6.</strong> RFC-0250: Covenants</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="RFC-0303_DanOverview.html"><strong aria-hidden="true">3.</strong> RFC-0303: The Tari Digital Assets Network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0313_VNRegistration.html"><strong aria-hidden="true">3.1.</strong> RFC-0313: Validator Node Registration</a></li><li class="chapter-item expanded "><a href="RFC-0320_TurbineModel.html"><strong aria-hidden="true">3.2.</strong> RFC-0320: The turbine model</a></li><li class="chapter-item expanded "><a href="RFC-0350_TariVM.html"><strong aria-hidden="true">3.3.</strong> RFC-0350: The Tari Virtual Machine</a></li></ol></li><li class="chapter-item expanded "><a href="RFC-0305_Consensus.html"><strong aria-hidden="true">4.</strong> RFC-0305: The Tari Network Consensus Layer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0314_VNCSelection.html"><strong aria-hidden="true">4.1.</strong> RFC-0314: Validator node committee selection</a></li><li class="chapter-item expanded "><a href="RFC-0321_ProcessingForeignProposals.html"><strong aria-hidden="true">4.2.</strong> RFC-0321: Processing foreign proposals</a></li><li class="chapter-item expanded "><a href="RFC-0325_DanTimeManagement.html"><strong aria-hidden="true">4.3.</strong> RFC-0325: Epochs and time management</a></li><li class="chapter-item expanded "><a href="RFC-0330_Cerberus.html"><strong aria-hidden="true">4.4.</strong> RFC-0330: The Cerberus-Hotstuff consensus algorithm</a></li><li class="chapter-item expanded "><a href="RFC-0331_Indexers.html"><strong aria-hidden="true">4.5.</strong> RFC-0331: Indexers</a></li></ol></li><li class="chapter-item expanded "><a href="proposals.html"><strong aria-hidden="true">5.</strong> Proposals and Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFC-0123_One_sided_replay_attacks.html"><strong aria-hidden="true">5.1.</strong> RFC-0123: Mitigating One-sided payment replay attacks</a></li><li class="chapter-item expanded "><a href="RFC-0141_Sparse_Merkle_Trees.html"><strong aria-hidden="true">5.2.</strong> RFC-0141: Sparse Merkle Tees</a></li><li class="chapter-item expanded "><a href="RFC-0153_StagedWalletSecurity.html"><strong aria-hidden="true">5.3.</strong> RFC-0153: Staged Wallet Security</a></li><li class="chapter-item expanded "><a href="RFC-0154_DeepLinksConvencion.html"><strong aria-hidden="true">5.4.</strong> RFC-0154: Deep links structure convention</a></li><li class="chapter-item expanded "><a href="RFC-0230_HTLC.html"><strong aria-hidden="true">5.5.</strong> RFC-0230: Hash time locked contracts</a></li><li class="chapter-item expanded "><a href="RFC-0240_AtomicSwap.html"><strong aria-hidden="true">5.6.</strong> RFC-0240: Atomic swap</a></li><li class="chapter-item expanded "><a href="RFC-0241_AtomicSwapXMR.html"><strong aria-hidden="true">5.7.</strong> RFC-0241: XMR Atomic swap</a></li><li class="chapter-item expanded "><a href="RFC-0310_SubmarineSwaps.html"><strong aria-hidden="true">5.8.</strong> RFC-0310: Submarine swaps</a></li><li class="chapter-item expanded "><a href="RFC-0388_BearerTokens.html"><strong aria-hidden="true">5.9.</strong> RFC-0388: Bearer tokens</a></li><li class="chapter-item expanded "><a href="RFC-8001_MultiPartyTransactions.html"><strong aria-hidden="true">5.10.</strong> RFC-8001: Multi-party transactions</a></li><li class="chapter-item expanded "><a href="RFC-8002_TransactionProtocol.html"><strong aria-hidden="true">5.11.</strong> RFC-8002: Transaction protocol</a></li><li class="chapter-item expanded "><a href="RFC-8003_TariUseCases.html"><strong aria-hidden="true">5.12.</strong> RFC-8003: Tari Use Cases</a></li><li class="chapter-item expanded "><a href="RFC-0385_StableCoins.html"><strong aria-hidden="true">5.13.</strong> RFC-0385: Privacy-enabled Stablecoin contract design</a></li><li class="chapter-item expanded "><a href="RFC-0323_TariThrottle.html"><strong aria-hidden="true">5.14.</strong> RFC-0323: Tari throttle exploratory analysis</a></li></ol></li><li class="chapter-item expanded "><a href="deprecated.html"><strong aria-hidden="true">6.</strong> Deprecated RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RFCD-0010_CodeStructure.html"><strong aria-hidden="true">6.1.</strong> RFC-0010: Tari code structure and organization</a></li><li class="chapter-item expanded "><a href="RFCD-0121_ConsensusEncoding.html"><strong aria-hidden="true">6.2.</strong> RFC-0121: Consensus encoding</a></li><li class="chapter-item expanded "><a href="RFCD-0130_Mining.html"><strong aria-hidden="true">6.3.</strong> RFC-0130: Mining</a></li><li class="chapter-item expanded "><a href="RFCD-0180_BulletproofRewinding.html"><strong aria-hidden="true">6.4.</strong> RFC-0180: Bulletproof range proof rewinding</a></li><li class="chapter-item expanded "><a href="RFCD-0300_DAN.html"><strong aria-hidden="true">6.5.</strong> RFC-0300: The Digital Assets Network</a></li><li class="chapter-item expanded "><a href="RFCD-0301_NamespaceRegistration.html"><strong aria-hidden="true">6.6.</strong> RFC-0301: Namespace Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0302_ValidatorNodes.html"><strong aria-hidden="true">6.7.</strong> RFC-0302: Validator Nodes</a></li><li class="chapter-item expanded "><a href="RFCD-0304_VNCommittees.html"><strong aria-hidden="true">6.8.</strong> RFC-0304: Validator Node committee selection</a></li><li class="chapter-item expanded "><a href="RFCD-0306_DANTemplateRegistration.html"><strong aria-hidden="true">6.9.</strong> RFC-0306: DAN Template Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0311_AssetTemplates.html"><strong aria-hidden="true">6.10.</strong> RFC-0311: Digital Asset templates</a></li><li class="chapter-item expanded "><a href="RFCD-0312_DANHighLevelSpecification.html" class="active"><strong aria-hidden="true">6.11.</strong> RFC-0312: High level Digital Asset Network Specification</a></li><li class="chapter-item expanded "><a href="RFCD-0322_VNRegistration.html"><strong aria-hidden="true">6.12.</strong> RFC-0322: Validator Node Registration</a></li><li class="chapter-item expanded "><a href="RFCD-0340_VNConsensusOverview.html"><strong aria-hidden="true">6.13.</strong> RFC-0340: Validator Node Consensus</a></li><li class="chapter-item expanded "><a href="RFCD-0341_AssetRegistration.html"><strong aria-hidden="true">6.14.</strong> RFC-0341: Asset registration</a></li><li class="chapter-item expanded "><a href="RFCD-0345_AssetLifeCycle.html"><strong aria-hidden="true">6.15.</strong> RFC-0345: Asset Life cycle</a></li><li class="chapter-item expanded "><a href="RFCD-0360_NFTInvoices.html"><strong aria-hidden="true">6.16.</strong> RFC-0360: NFT sale using MimbleWimble Invoice</a></li><li class="chapter-item expanded "><a href="RFCD-0500_PaymentChannels.html"><strong aria-hidden="true">6.17.</strong> RFC-0500: Tari payment channels</a></li></ol></li><li class="chapter-item expanded "><a href="RFC_template.html"><strong aria-hidden="true">7.</strong> RFC template</a></li><li class="chapter-item expanded "><a href="Glossary.html"><strong aria-hidden="true">8.</strong> Glossary</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                        </div>

                        <h1 class="menu-title"><img src="theme/images/tari-horizontal-logo.png"/> </h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rfc-0312danspecification"><a class="header" href="#rfc-0312danspecification">RFC-0312/DANSpecification</a></h1>
<h2 id="high-level-digital-asset-network-specification"><a class="header" href="#high-level-digital-asset-network-specification">High level Digital Asset Network Specification</a></h2>
<p><img src="theme/images/status-deprecated.svg" alt="status: deprecated" /></p>
<p><strong>Maintainer(s)</strong>: <a href="https://github.com/CjS77">Cayle Sharrock</a></p>
<h1 id="licence"><a class="header" href="#licence">Licence</a></h1>
<p><a href="https://opensource.org/licenses/BSD-3-Clause">The 3-Clause BSD Licence</a>.</p>
<p>Copyright 2022 The Tari Development Community</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>Redistributions of this document must retain the above copyright notice, this list of conditions and the following
disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.</li>
</ol>
<p>THIS DOCUMENT IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;, AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1 id="language"><a class="header" href="#language">Language</a></h1>
<p>The keywords &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,
&quot;NOT RECOMMENDED&quot;, &quot;MAY&quot; and &quot;OPTIONAL&quot; in this document are to be interpreted as described in
<a href="https://tools.ietf.org/html/bcp14">BCP 14</a> (covering RFC2119 and RFC8174) when, and only when, they appear in all
capitals, as shown here.</p>
<h1 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h1>
<p>This document and its content are intended for information purposes only and may be subject to change or update without
notice.</p>
<p>This document may include preliminary concepts that may or may not be in the process of being developed by the Tari
community. The release of this document is intended solely for review and discussion by the community of the
technological merits of the potential system outlined herein.</p>
<h1 id="goals"><a class="header" href="#goals">Goals</a></h1>
<p>This document describes the high-level, or informal specification for how digital assets are created, managed, secured,
and wound- down on the Tari digital asset network (DAN).</p>
<p>The document covers, among other things:</p>
<ul>
<li>The relationship of side-chains to digital assets and contract,</li>
<li>Required characteristics of side-chains,</li>
<li>Peg-in and peg-out mechanisms,</li>
<li>Digital asset template minimum requirements,</li>
<li>Validator node requirements,</li>
<li>Checkpoint and refund mechanisms,</li>
<li>Failure mode strategies.</li>
</ul>
<p>This RFC covers a lot of ground. Therefore the intent is not to provide a detailed, code-ready specification for the
entire DAN infrastructure; those are left to other RFCs; but to establish a foundation onto which the rest of the DAN
specifications can be built.</p>
<p>This RFC supersedes and deprecates several older RFCs:</p>
<ul>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: Digital Assets Network</a></li>
<li><a href="RFCD-0301_NamespaceRegistration.html">RFCD-0301: Namespace Registration</a></li>
<li><a href="RFCD-0302_ValidatorNodes.html">RFCD-0302: Validator Nodes</a></li>
<li><a href="RFCD-0304_VNCommittees.html">RFCD-0304: Validator Node committee selection</a></li>
<li><a href="RFCD-0345_AssetLifeCycle.html">RFCD-0345: Asset Life cycle</a></li>
</ul>
<p>Several RFC documents are in the process of being revised in order to fit into this proposed framework:</p>
<ul>
<li><a href="RFCD-0300_DAN.html">RFCD-0300: The Digital Assets Network</a></li>
<li><a href="RFCD-0340_VNConsensusOverview.html">RFCD-0340: Validator Node Consensus</a></li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>There are many ways to skin a cat. The philosophy guiding the approach in the RFC is one that permits scaling of the
network to handle in the region of <strong>1 billion messages per day</strong> (network-wide) and
<strong>1 million digital assets</strong> with <strong>near real-time user experience</strong> on asset state retrieval, updating and transfer, on
a sufficiently decentralised and private basis.</p>
<p>The definition of <em>sufficient</em> here is subjective, and part of the design philosophy of Tari is that we leave it up to
the user to determine what that means, keeping in mind that there is always a trade-off between decentralisation,
performance, and cost.</p>
<p>For some assets, decentralisation and censorship resistance will be paramount, and users will be willing to live with a
more laggy experience. Gamers in a Web 3.0-MMORPG on the other hand, want cheap, fast transactions with verifiable
ownership, and therefore will generally need to sacrifice decentralisation for that.</p>
<p>The goal of the DAN is for asset issuers to be able to configure the side-chain for their project to suit their
particular needs.</p>
<h1 id="description"><a class="header" href="#description">Description</a></h1>
<p>There are several key actors that participate in Tari Digital Asset Network:</p>
<ul>
<li>A tari [contract] is a piece of code that establishes the relationship and rules of engagement between one or more
digital assets. This includes ownership rules, transfer rules and state change rules.</li>
<li>The <a href="#asset_issuer">Asset issuer</a> is the entity that defines a contract and brings it into existence.</li>
<li><a href="#the-role-of-validator-nodes">Validator node</a>s manage the contract on behalf of the asset issuer by executing instructions on a Tari <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a>.</li>
<li>[Users] interact with contracts and may own, transfer or execute state change instructions against the contract by
submitting instructions via the Tari <a href="RFC-0172_PeerToPeerMessagingProtocol.html">comms network</a> to the relevant validator node committee.</li>
</ul>
<h2 id="the-role-of-the-layer-1-base-chain"><a class="header" href="#the-role-of-the-layer-1-base-chain">The role of the Layer 1 base chain</a></h2>
<p>The Tari Overview RFC describes <a href="RFC-0001_overview.html#the-role-of-the-base-layer">the role of the base layer</a>. In summary, the base layer</p>
<ul>
<li>maintains the integrity of the Tari cryptocurrency token, and</li>
<li>maintains registers of the side-chains,</li>
<li>and facilitates the version control and reproducible execution environments for contract templates.</li>
</ul>
<p>It does not know about or care about what happens in the side chains as long as the Tari consensus, side-chain and
validator node rules are kept.</p>
<p>It is helpful to view the base layer blocks and transactions as an immutable, append-only document which allows us to
model the tables and foreign relationships of a traditional database. The rows are represented by the UTXOs and we can
infer which table the row belongs to by inspecting the output features of the UTXO.</p>
<p>Whereas a standard RDMS manages access control and permissions via policy, we must also take care to ensure proper
access control via consensus rules, lock scripts, covenants, signatures and kernels.</p>
<h2 id="top-level-requirements-for-side-chains"><a class="header" href="#top-level-requirements-for-side-chains">Top-level requirements for side-chains</a></h2>
<p>The guiding principle of Tari contracts are that they are managed on a dedicated side-chain. One side-chain, one
contract. Other RFCs will discuss ways to overcome the apparent limitations this rule implies, including inter-contract
interactions and asset hibernation.</p>
<h3 id="asset-issuer---validator-node-agreements"><a class="header" href="#asset-issuer---validator-node-agreements">Asset issuer &lt;-&gt; Validator node agreements</a></h3>
<p>The fundamental relationship of Tari contracts is between the asset issuer and the validator node(s) that manage the
contract's side-chain. This relationship is somewhat adversarial by nature: Issuers want high quality service at the
lowest possible price; Validators want to be compensated for their services and under some circumstances may want to
cheat on contracts for their own gain.</p>
<p>Tari seeks to address this in the lightest way possible by requiring the absolute minimum in terms of base layer
governance while providing options for side-chain governance that suits the needs of the parties involved.</p>
<p>For example, an asset issuer that wants to issue a highly decentralised, censorship-resistant <em>high-value</em> contract on a
side-chain would likely seek to recruit dozens of validator nodes and run a proof-of-stake consensus model with a
confidential asset specification.</p>
<p>In contrast, an asset issuer that wants to participate in the Tari ecosystem, but is not interested in decentralisation
could run their own validator node; with no consensus, or staking, or validator node compensation contracts -- these
would be unnecessary; and provide a high performance, real-time contract. Games with realistic embedded economics would
follow this model, as well as early on in the transition from tradFi to deFi.</p>
<p>A set of Validator nodes that manage the same contract is called the <em>validator node committee</em> for the contract.</p>
<h3 id="the-asset-issuer"><a class="header" href="#the-asset-issuer">The Asset issuer</a></h3>
<p>The asset issuer, otherwise known as the contract owner, is the entity that publishes
a <a href="#the-contract-definition-transaction">contract definition transaction</a>.</p>
<p>The <a href="#the-contract-definition-transaction">contract definition transaction</a> defines the &quot;what&quot; of the contract. It specifies the complete specification of the
code that will run, the execution environment it must be run under, as well as the initialisation parameters for all the
contract template constructors.</p>
<p>The contract definition allows validator nodes to be confident that they are running a byte-for-byte equivalent code
base with the exact same interpretation of that code as its peers without having to collaborate with any other nodes to
confirm this.</p>
<p>In most cases, a contract definition will comprise several well-reviewed and secure <em>templates</em> to define the operation
of the contract.</p>
<p>The asset issuer will also draft and publish the <a href="#the-contract-constitution">contract constitution</a>. The constitution defines <em>how</em> a contract is
run, and defines the conditions under which the terms of the constitution can be changed.</p>
<h3 id="the-constitution-committee"><a class="header" href="#the-constitution-committee">The Constitution Committee</a></h3>
<p>The <a href="#asset_issuer">asset issuer</a> will in the creation of the <a href="#the-contract-constitution">contract constitution</a> nominate a key or set of keys to &quot;own&quot; the asset
and control all things related to <em>how</em> the contract is run. They are known as the <a href="#constitution_committee">constitution committee</a> (CC)</p>
<p>The CC has the power to change anything inside of the <a href="#the-contract-constitution">contract constitution</a>. In many cases, the CC will simply be the <a href="#asset_issuer">asset issuer</a>.
However, allowing the CC to differ from the asset issuer enables a number of other use-cases 
such as a DAO, a nominated list of keys, etc.</p>
<h3 id="the-role-of-validator-nodes"><a class="header" href="#the-role-of-validator-nodes">The role of validator nodes</a></h3>
<ul>
<li>Validator nodes SHOULD diligently and accurately <a href="#validator-node-instructions">process all instructions</a> related to the contract.</li>
<li>The committee SHOULD reach consensus on every instruction related to the contract. This specification does NOT dictate
how this consensus is reached. If the committee contains one member, then consensus is trivial, and does not require
any complicated consensus algorithms. A standard web-based application stack will suffice in most cases. Larger
committees can choose from any manner of consensus algorithms, including PBFT, HotStuff, proof-of-stake or
proof-of-work.</li>
</ul>
<p><strong>OPEN QUESTION</strong>: The asset issuer has no in-band way to know how the VNs are reaching consensus. Even out-of-band,
there could be one server and a bunch of proxies that merely relay messages. Only proof of work (because it is
permissionless) and proof of stake (maybe?) work around this problem.</p>
<ul>
<li>TODO - research how Polygon and other multichain networks solve this problem.</li>
</ul>
<p>The Tari base layer does not get involved in governance issues beyond those mechanics that are defined in contract
constitutions. However, many asset issuers may want to include mechanisms that, for example, require a Tari stake to act
as a validator node. Validator nodes may also desire a compensation mechanism so that they get paid for managing the
contract. These mechanisms form part of the contract itself, and are opaque to the machinery of the base layer,
side-chain and associated peg transactions.</p>
<p>Validator nodes MAY have to stake Tari for each contract they validate. Asset issuers will determine the nature and
amount of stake required as part of the <a href="#the-contract-constitution">contract constitution</a>. The contract stake is variable on a
contract-to-contract basis so that an efficient market between asset issuers and validator nodes can develop. This
market is not defined on the Tari blockchain at all and would be best implemented as a DAO on the DAN itself.</p>
<p>Similarly, it has been suggested in the past that Validator Nodes should post hardware benchmarks when registering. The
problem with this requirement is that it is fairly trivial to game. We cannot enforce that the machine that posted the
benchmark is the same as the one that is running validations.</p>
<p>A better approach is to leave this to the market. A reputation contract can be built, on Tari, of course, that
periodically and randomly asks Validator Nodes to perform cryptographically signed benchmarks in exchange for
performance certificates. Nodes can voluntarily sign up for such a service and use the certificates as a form of
credential. Nodes that do not sign up may have trouble finding contracts to validate and might have to lower their price
to get work.</p>
<p>Tari contracts are template-based, and so many contracts may wish to include <a href="#contract-templates">contract template</a>s that add any or all of
the following governance functions to the side-chain contract:</p>
<ul>
<li>Validator node staking.</li>
<li>Validator node slashing.</li>
<li>A Validator node proof-of-participation certificate template. Poorly performing validator nodes may receive reduced
compensation, be fined, or even ejected from the committee at a checkpoint.</li>
<li>A fee model template. The asset issuer could provide a guaranteed pool of funds from which the committee will be paid
at every checkpoint.</li>
</ul>
<p>This list is far from complete, but should convey the idea that:</p>
<ul>
<li>Tari contracts SHOULD be highly modular and composable, with each template performing exactly ONE highly specific
task, and doing it very well.</li>
<li>The base layer and peg transactions know the absolute minimum about the assets on the chain. However, they provide all
the information necessary for the contract templates and side-chains to function efficiently.</li>
</ul>
<h2 id="the-contract-lifecycle"><a class="header" href="#the-contract-lifecycle">The contract lifecycle</a></h2>
<p>Every contract MUST be governed by one, and only one, Tari <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a>. A contract MAY define one or more digital
assets. This contract can be very simple or highly complex.</p>
<p>The lifecycle of a contract proceeds via these steps:</p>
<ol>
<li>The asset issuer publishes a <a href="#the-contract-definition-transaction">contract definition transaction</a>.</li>
<li>The asset issuer publishes a <a href="#the-contract-constitution">contract constitution</a> transaction.</li>
<li>Once this transaction is published, we enter the <a href="#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a>.</li>
<li>Each validator node that will be managing the contract publishes a <a href="#the-contract-acceptance-transaction">contract acceptance transaction</a>. The group of
validator nodes that manages the contract is called the Validator Node Committee (VNC).</li>
<li>Once the <a href="#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> has expired, the <a href="#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> begins.</li>
<li>The VNC jointly publishes a <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> transaction.</li>
<li>At this point, the contract is considered live, and users can safely interact with the contract on the side-chain.
Technically, users do not have to wait until this point. The VNC COULD start processing transactions
<em>optimistically</em> as soon as the constitution is published, and print the zero-th and first checkpoints once they are
mined on the base layer. However, this is not generally recommended.</li>
<li>The VNC periodically publishes a <a href="#checkpoint-transactions">checkpoint</a> transaction.</li>
<li>Failure to do so can lead to the contract being <a href="#contract-abandonment" title="Contract abandonment">abandoned</a>.</li>
<li>The CC MAY shut the contract down by publishing a <a href="#contract-dissolution" title="Contract dissolution">dissolution</a> transaction.</li>
</ol>
<p>The following sections will discuss each of these steps in more detail.</p>
<h2 id="contract-instantiation"><a class="header" href="#contract-instantiation">Contract instantiation</a></h2>
<p>Steps 1 - 6 in the <a href="#the-contract-lifecycle" title="The contract lifecycle">contract lifecycle</a> are part of the <a href="#contract-instantiation">contract instantiation</a> process. Instantiation is a multi-step
process and is ideally represented as a finite-state machine that reacts to transactions published on chain that contain
outputs containing specific output features. The combination of output features and FSM allows nodes to accurately track
the progress of potentially thousands of contracts in a safe and decentralised manner.</p>
<h3 id="the-contract-definition-transaction"><a class="header" href="#the-contract-definition-transaction">The contract definition transaction</a></h3>
<p>It bears repeating that every contract is governed by one, and only one, Tari <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a>. A contract MAY define one or
more digital assets. These assets' behaviour is captured in templates and are highly composable. This allows the
contract to be very simple or highly complex, and be handled with the same contract handling machinery.</p>
<note :tip>
The contract definition transaction defines the "what" of the digital asset set that will be created.
</note>
<ul>
<li>Every contract MUST be registered on the base layer.</li>
<li>Contracts MUST be registered by publishing a <code>contract definition</code> transaction.</li>
<li>Asset issuers MUST stake a small amount of Tari in order to publish a new contract.</li>
<li>Exactly ONE output MUST have a <code>ContractSpecification</code> output feature.</li>
<li>The contract specification UTXO MUST include a covenant that only permits it to be spent to a
new <code>ContractSpecification</code> UTXO or as an unencumbered UTXO in
a <code>ContractDeregistration</code> transaction.</li>
</ul>
<p>Note: The latter is desirable because it tidies up the UTXO set. But this transaction MUST NOT be published before
contract has been dissolved (see [contract dissolution]).</p>
<ul>
<li>The  <code>ContractSpecification</code> UTXO MUST hold at least the <code>MINIMUM_OWNER_COLLATERAL</code> in Tari. The amount is hard-coded
into consensus rules and is a nominal amount to prevent spam, and encourages asset owners to tidy up after themselves
if a contract winds down. Initially, <code>MINIMUM_OWNER_COLLATERAL</code> is set at 200 Tari, but MAY be changed across network
upgrades.</li>
</ul>
<p><strong>Implementation note:</strong>
Assuming the collateral is represented by the UTXO commitment $C = kG + vH$, the minimum requirement is verified by
having the range-proof commit to $(k, v - v_\mathrm{min})$ rather than the usual $(k, v)$. Note that this change
requires us to modify the
<code>TransactionOutput</code> definition to include a <code>minimum_value_commitment</code> field, defaulting to zero, to capture this extra
information.</p>
<ul>
<li>The <code>ContractSpecification</code>UTXO MUST also include:
<ul>
<li>The contract description,</li>
<li>the asset issuer record</li>
<li>the contract definition, as described below.</li>
</ul>
</li>
</ul>
<h4 id="contract-description"><a class="header" href="#contract-description">Contract description</a></h4>
<p>The contract description is a simple metadata record that provides context for the contract. The record includes:</p>
<ul>
<li>The contract id -- <code>&lt;u256 hash&gt;</code>. This is immutable for the life of the contract and is calculated as
<code>H(contract_name || contract specification hash || Initial data hash || Runtime data hash)</code>.</li>
<li>A contract name -- <code>utf-8 char[32]</code>(UTF-8 string) 32 bytes. This is for informational purposes only, so it shouldn't
be too long, but not too short that it's not useful (this isn't DOS 3.1 after all). 32 bytes is the same length as a
public key or hash, so feels like a reasonable compromise.</li>
</ul>
<h4 id="asset-issuer-record"><a class="header" href="#asset-issuer-record">Asset issuer record</a></h4>
<p>The asset issuer record identifies the <a href="#asset_issuer">asset issuer</a> as the initial owner and publisher of the contract. The following
fields are required:</p>
<ul>
<li>the asset issuer's public key, also known as the owner public key, <code>&lt;PublicKey&gt;</code>.</li>
</ul>
<h4 id="contract-definition"><a class="header" href="#contract-definition">Contract definition</a></h4>
<p>The following information must be captured as part of the <code>contract definition</code> in the <code>ContractSpecification</code>UTXO of
the contract definition transaction:</p>
<ul>
<li>the full contract specification in a compact serialised format,</li>
<li>the initialisation arguments for the contract, in a compact serialisation format,</li>
<li>the runtime specification.</li>
</ul>
<p>This data tells validator nodes <em>exactly</em> what code will be running, and the data needed to initialise that code.</p>
<p>Asset templates will have a strictly defined interface that includes a constructor, or initialisation method. The
parameters that these constructors accept is what determines the initial data.</p>
<p>The runtime specification includes, for example, the version of the runtime and any meta-parameters that the runtime
accepts.</p>
<p>These three pieces of data are <em>necessary</em> AND <em>sufficient</em> to enable <em>any</em> validator node to start running the contract
and execute instructions on it, knowing that any other validator node running the same contract will determine <em>exactly</em>
the same state changes for every instruction it receives.</p>
<h3 id="the-contract-constitution"><a class="header" href="#the-contract-constitution">The contract constitution</a></h3>
<p>Following the <a href="#the-contract-definition-transaction">contract definition transaction</a>,the asset issuer MUST publish a <a href="#the-contract-constitution">contract constitution</a> transaction in
order for the contract initialisation process to proceed.</p>
<p>This transaction defines the &quot;how&quot; and &quot;who&quot; of the digital asset's management.</p>
<p>It contains the &quot;contract terms&quot; for the management of the contract.</p>
<p>Exactly ONE UTXO MUST include the <code>ContractConstitution</code> output feature flag. The contract constitution UTXO contains
the following:</p>
<ul>
<li>It MUST include the contract id. The contract definition transaction SHOULD be mined prior to publication of the
constitution transaction, but it strictly is not necessary if VNs are able to access the contract specification in
some other way.</li>
<li>It MUST include a list of public keys of the proposed <a href="#cc">CC</a>;</li>
<li>It MUST include a list of public keys of the proposed VNC;</li>
<li>It MUST include an expiry timestamp before which all VNs must sign and agree to these terms (the <a href="#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a>);</li>
<li>It MAY include quorum conditions for acceptance of this proposal (default to 100% of VN signatures required);</li>
<li>If the conditions will unequivocally pass, the acceptance period MAY be shortcut.</li>
<li>The UTXO MUST only be spendable by a multisig of the quorum of VNs performing <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain</a> initialisation. (e.g. a 3
of 5 threshold signature).</li>
<li>It MUST include the side-chain metadata record:
<ul>
<li>The consensus algorithm to be used</li>
<li>checkpoint quorum requirements</li>
</ul>
</li>
<li>It MUST include the following Checkpoint Parameters Record
<ul>
<li>minimum checkpoint frequency,</li>
<li>minimum quarantine period.</li>
</ul>
</li>
<li>It MAY include a <code>RequirementsForConstitutionChange</code> record. It omitted, the checkpoint parameters and side-chain
metadata records are immutable via covenant.
<ul>
<li>How and when the Constitution UTXO can change.</li>
<li>Quorum required by the <a href="#cc">CC</a>,</li>
<li>Proposal period.</li>
<li>How and when the Checkpoint Parameters record can change.</li>
<li>How and when the side-chain metadata record can change.</li>
</ul>
</li>
<li>It SHOULD include a list of emergency public keys that have signing power if the contract is <a href="#contract-abandonment" title="Contract abandonment">abandoned</a>.</li>
</ul>
<p>If both the <a href="#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> and <a href="#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> elapses without quorum, the CC MAY spend
the<code>ContractConstitution</code> UTXO back to himself to recover his funds.</p>
<p>In this case, the asset issuer MAY try and publish a new contract constitution.</p>
<h4 id="contract-constitutions-for-proof-of-work-side-chains"><a class="header" href="#contract-constitutions-for-proof-of-work-side-chains">Contract constitutions for proof-of-work side-chains</a></h4>
<p>Miners are joining and leaving PoW chains all the time. It is impractical to require a full constitution change cycle to
execute every time this happens, the chain would never make progress!</p>
<p>To work around this, the constitution actually defines a set of proxy- or observer-nodes that perform the role of
running a full node on the side chain and publishing the required [checkpoint transaction]s onto the Tari base chain.
The observer node(s) are then technically the VNC. Issuers could place additional safeguards in the contract definition
and constitution to keep the VNC honest. Conceivably, even Monero or Bitcoin itself could be attached as a side-chain to
Tari in this manner.</p>
<h3 id="the-contract-acceptance-transaction"><a class="header" href="#the-contract-acceptance-transaction">The contract acceptance transaction</a></h3>
<p>The entities that are nominated as members of a VNC for a new contract MUST cryptographically [acknowledge and agree] to
manage the contract. This happens by virtue of the <a href="#the-contract-acceptance-transaction">contract acceptance transaction</a>s.</p>
<ul>
<li>Each potential VNC member MUST publish a <a href="#the-contract-acceptance-transaction">contract acceptance transaction</a> committing the required stake. The UTXO is
also an explicit agreement to manage the contract.</li>
<li>Exactly ONE UTXO MUST have the output feature <code>ContractAcceptance</code>.</li>
<li>The UTXO MUST contain a time lock, that prevents the VN spending the UTXO before the <a href="#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a>
<ul>
<li><a href="#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> has lapsed.</li>
</ul>
</li>
<li>The output MUST include the contract id.</li>
</ul>
<p>A contract acceptance transaction MUST be rejected if</p>
<ul>
<li>contract id does not exist (the contract definition has not been mined)</li>
<li>the signing public key was not nominated in the relevant contract constitution</li>
<li>the deposit is insufficient</li>
</ul>
<h3 id="the-side-chain-initialization-period"><a class="header" href="#the-side-chain-initialization-period">The side-chain initialization period</a></h3>
<p>Once the <a href="#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> has expired, <a href="#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> begins.</p>
<p>At this point, VNs that have accepted the contract must</p>
<ul>
<li>allocate resources</li>
<li>Setup whatever is needed to run the contract</li>
<li>Set up consensus with their peer VNs (e.g. hotstuff)</li>
<li>Initialise the contract and run the constructors</li>
<li>Reach consensus on the initial state.</li>
<li>Prepare the <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> transaction.</li>
</ul>
<p>all before the <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> period expires.</p>
<h3 id="the-side-chain-initialization-transaction"><a class="header" href="#the-side-chain-initialization-transaction">The side-chain initialization transaction</a></h3>
<p>Side-chains MUST be marked as initiated by virtue of a <a href="#the-side-chain-initialization-transaction" title="The side-chain initialization transaction">side-chain initialization</a> transaction.</p>
<ul>
<li>Once the <a href="#the-contract-acceptance-transaction" title="The contract acceptance transaction">acceptance period</a> has expired, <a href="#the-side-chain-initialization-period" title="The side-chain initialization period">side-chain initialization period</a> begins.</li>
<li>At this point, there MUST be a quorum of acceptance transactions from validator nodes.</li>
<li>The validator node committee MUST collaborate to produce, sign and broadcast the initialisation transaction by
spending the initial Contract Constitution transaction into the zero-th <a href="#checkpoint-transactions">checkpoint</a> transaction.</li>
<li>The initialisation transaction MUST spend all the [contract acceptance transactions] for the contract.</li>
<li>Base layer consensus MUST confirm that the spending rules and covenants have been observed, and that the checkpoint
contains the correct covenants and output flags.</li>
<li>There is a minimum [side-chain deposit] that MUST be included in the peg-in UTXO. A single aggregated UTXO containing
at least $$ m D $$ Tari, where <em>m</em> is the number of VNs and <em>D</em> is the deposit required.</li>
<li>This transaction also acts as the zero-th checkpoint for the contract. As such, it requires all the checkpoint
information.</li>
<li>The state commitment is the merklish root of the state after running the code initialisation using the [initial data]
provided in the <a href="#the-contract-definition-transaction">contract definition transaction</a>.</li>
</ul>
<h2 id="contract-execution"><a class="header" href="#contract-execution">Contract execution</a></h2>
<p>The goal of the DAN is to allow many, if not millions, of instructions to be processed on the side-chain with little or
no impact on the size of the base layer.</p>
<p>The only requirements that the base layer will enforce during contract execution are those specified in the contract
constitution.</p>
<p>The base layer will check and enforce these requirements at <a href="#checkpoint-transactions">checkpoint</a>s.</p>
<h3 id="checkpoint-transactions"><a class="header" href="#checkpoint-transactions">Checkpoint transactions</a></h3>
<p>The roles of the checkpoint transaction:</p>
<ul>
<li>Present proof of liveness</li>
<li>Allows authorised entities to make changes to the committee</li>
<li>Summarise contract state</li>
<li>Summarise contract logs / events</li>
</ul>
<p><strong>Implementation Note:</strong> In the discussion of Tari account contract templates below, we need a mechanism for proving
that the side-chain state corresponds to what someone is claiming with respect to a valid base layer transaction. But
since our policy is one that the base layer never knows anything about what goes on in side-chains, this poses a
challenge. One possible solution to this would be to add a <code>MERKLE_PROOF</code> opcode to TariScript that could validate a
base layer transaction based on a checkpoint merkle root combined with a merkle proof that a VNC has given to a user.</p>
<p>Validator node committees MUST periodically sign and broadcast a <a href="#checkpoint-transactions">checkpoint</a> transaction.</p>
<p>The transaction signature MUST satisfy the requirements laid out for checkpoint transactions defined in
the <a href="#the-contract-constitution">contract constitution</a>.</p>
<ul>
<li>The checkpoint transaction MUST spend the previous checkpoint transaction for this contract. Consensus will guarantee
that only one checkpoint UTXO exists for every contract on the base layer. This is guaranteed by virtue of a covenant.
The contract id must equal the contract id of the checkpoint being spent.</li>
<li>The checkpoint transaction MUST contain exactly ONE UTXO with the <code>Checkpoint</code> output feature.</li>
</ul>
<p>The <code>Checkpoint</code>output feature adheres to the following:</p>
<ul>
<li>It MUST reference the contract id.</li>
<li>It MUST contain a commitment to the current contract state. This is typically some sort of Merklish root.</li>
<li>It MAY have a URI to off-chain state or merkle tree</li>
<li>It MUST contain a checkpoint number, strictly increasing by 1 from the previous checkpoint.</li>
<li>It MUST strictly copy over the constitution rules from the previous checkpoint, OR</li>
<li>It MUST contain valid signatures according to the constitution allowing the rules to be changed, along with the
relevant parts of the <a href="#the-contract-constitution">contract constitution</a> change pipeline.</li>
</ul>
<p>If a valid checkpoint is not posted within the maximum allowed timeframe, the contract is <a href="#contract-abandonment" title="Contract abandonment">abandoned</a>. This COULD lead
to penalties and stake slashing if enabled within the contract specification.</p>
<h3 id="changes-to-the-constitution"><a class="header" href="#changes-to-the-constitution">Changes to the constitution</a></h3>
<p>Changes to the <a href="#the-contract-constitution">contract constitution</a> can happen at any time through the [constitution amendment] process. This also applies to changes to the VNC. Only the <a href="#cc">CC</a> may 
make changes to the<a href="#the-contract-constitution">contract constitution</a>.</p>
<ul>
<li>The rules over how members are added or removed are defined in the <a href="#the-contract-constitution">contract constitution</a>.</li>
<li>At the minimum, there's a proposal step, a validation step, an acceptance step, and an activation step. Therefore
changes take place over at least a 4-checkpoint time span.</li>
<li>If a VN leaves a committee their [side-chain deposit] MAY be refunded to them.</li>
<li>If a new VN joins the committee they must provide the [side-chain deposit] at their activation step.</li>
<li>In the proposal step, any authorised <a href="#cc">CC</a> may make a change proposal, within the limits defined by the change rules in the <a href="#the-contract-constitution">contract constitution</a></li>
<li>Before activation, VNC members MAY submit an acceptance transaction that registers their willingness to validate the contract. If no acceptance is submitted within the <code>acceptance_period</code> the validator is assumed to be uninterested in running the contract and will not form part of the finalized contract committee. </li>
</ul>
<h3 id="contract-abandonment"><a class="header" href="#contract-abandonment">Contract abandonment</a></h3>
<p>This is the state where VNC and the Asset Owner(s) have abandoned the contract.</p>
<p>If a contract misses one or more checkpoints, nodes can mark it as <code>VNC abandoned</code>. This is not formally marked on the
blockchain, (since something was NOT done on-chain), but nodes will be able to test for abandoned state.</p>
<p>If a contract has not seen any new constitution amendment for a checkpoint period after it has been marked as <code>VNC abandoned</code>, 
it is marked as <code>abandoned</code>. </p>
<p>The <a href="#the-contract-constitution">contract constitution</a> SHOULD provide a set of emergency pubkeys that are able to</p>
<ul>
<li>perform a peg-out</li>
<li>do all governancy things</li>
<li>rescue funds and state</li>
</ul>
<p>Implementation note: We could add an <code>IS_ABANDONED</code> opcode (sugar for height since last checkpoint) to test for
abandonment.</p>
<p>If a contract is abandoned, the emergency key MAY spend the last checkpoint into a <code>QUARANTINED</code> state. A contract MUST
stay in <code>QUARANTINED</code> state for at least one month.</p>
<p>The contract can leave the quarantined state in one of two ways:</p>
<ul>
<li>
<p>The current VNC MAY reinstate the contract operation by publishing the missing checkpoint(s), and committing to any
remedial actions as specified in the <a href="#the-contract-constitution">contract constitution</a>, e.g. paying a fine, etc.</p>
</li>
<li>
<p>The quarantine period lapses, at which point the emergency key holder(s) have full administrative power over the
contract. This means that they have to issue a new constitution to assign a new VNC, peg-out and shut down the contract, or whatever.</p>
<p><strong>OPEN QUESTION</strong>:  Do we want to allow an additional fall back of everyone spend after years in <code>abandoned</code> state?</p>
</li>
</ul>
<h2 id="contract-dissolution"><a class="header" href="#contract-dissolution">Contract dissolution</a></h2>
<h2 id="contract-templates"><a class="header" href="#contract-templates">Contract templates</a></h2>
<h3 id="template-code-registration-and-versioning"><a class="header" href="#template-code-registration-and-versioning">Template code registration and versioning</a></h3>
<p>The code template implementations MUST be registered on the base layer.</p>
<p>The reason for this is that it allows Validator Nodes to know unequivocally that they are all running the same code and
can expect the same output for the same input.</p>
<p>Template registration also allows us to implement a secure and trust-minimised upgrade mechanism for templates.</p>
<p>Potentially, we could even introduce a mechanism wherein template developers get paid for people using their template.</p>
<p>Template registration UTXO would contain:</p>
<ul>
<li>A link to the code (git commit or IPFS)</li>
<li>The type of code (source or binary blob)</li>
<li>A hash of the source code / blob</li>
<li>Version info.</li>
<li>[Execution engine] requirements (similar to solc pragma)</li>
</ul>
<p>There's a clear upgrade path, since there's a code-chain from one version of a contract template to the next.</p>
<h2 id="user-account-balance-representation-in-side-chains"><a class="header" href="#user-account-balance-representation-in-side-chains">User account balance representation in side-chains</a></h2>
<p>Tari uses the UTXO model in its ledger accounting. On the other hand Tari side-chains SHOULD use an account-based system
to track balances and state.</p>
<p>The reasons for this are:</p>
<ul>
<li>An account-based approach leads to fewer outputs on peg-out transactions. There is roughly a 1:1 ratio of users to
balances in an account-based system. On the other hand there are O(n) UTXOs in an output-based system where <code>n</code> are
the number of transactions carried out on the side-chain. When a side-chain wants to shut down, they must record a new
output on the base layer for every account or output (as the case may be) that they track in the peg-out transaction(
s). It should be self-evident that account-based systems are far more scalable in the vast majority of use-cases.</li>
<li>Following on from this, Accounts scale better for micro-payment applications, where hundreds or thousands of tiny
payments flow between the same two parties.</li>
<li>Many DAN applications will want to track state (such as NFTs) as well as currency balances. Account-based ledgers make
this type of application far simpler.</li>
</ul>
<h3 id="pedersen-commitments-and-account-based-ledgers"><a class="header" href="#pedersen-commitments-and-account-based-ledgers">Pedersen commitments and account-based ledgers</a></h3>
<p>Standard Pedersen commitments are essentially useless in account-based ledgers.</p>
<p>The reason being that since the spending keys would be common to all transactions involving a given account, it is
trivial to use the accounting rules to cancel out the <code>k.G</code> terms from transactions and to use a pre-image attack to
unblind all the values.</p>
<p>The specific protocol of user accounts in the side-chain is decided by the asset issuer.</p>
<p>Options include:</p>
<h4 id="fully-trusted"><a class="header" href="#fully-trusted">Fully trusted</a></h4>
<p>In this configuration, the side-chain is controlled by a single validator node, perhaps a server running an RDMS. The
validator node has full visibility into the state of the side chain at all times. It may or may not share this state
with the public. If it does not, then the situation is analogous to current Web 2.0 server applications.</p>
<h4 id="decentralised-and-federated"><a class="header" href="#decentralised-and-federated">Decentralised and federated</a></h4>
<p>In this configuration, a distributed set of validator nodes maintain the side-chain state. The set of nodes are fixed.
If consensus between nodes is achieved using a mechanism such as HotStuff BFT, very high throughputs can be achieved.</p>
<h4 id="decentralised-and-censorship-resistant"><a class="header" href="#decentralised-and-censorship-resistant">Decentralised and censorship resistant</a></h4>
<p>In this configuration, the side-chain could itself be a proof-of-work blockchain. This offers maximum decentralisation
and censorship resistance. However, throughput will be lower.</p>
<h4 id="confidentiality"><a class="header" href="#confidentiality">Confidentiality</a></h4>
<p>As mentioned above, Pedersen commitments are not suitable for account-based ledgers. However, the <a href="https://eprint.iacr.org/2019/191.pdf">Zether</a> protocol was
expressly designed to provide confidentiality in a smart-contract context. It can be combined with any of the above
schemes. Zether can also be <a href="https://github.com/ConsenSys/anonymous-zether">extended</a> to provide privacy by including a
ring-signature scheme for transfers.</p>
<h2 id="key-template-discussions"><a class="header" href="#key-template-discussions">Key template discussions</a></h2>
<p>A majority of contracts will want to implement on or more of the following features:</p>
<ul>
<li>A financial bridge from the base layer and user accounts,</li>
<li>A fee or compensation mechanism for the VNC,</li>
<li>Inter-contract communications</li>
</ul>
<p>These are complex topics and there are entire blockchain systems where this functionality is built into the fabric of
the design. Tari’s modular approach naturally means that the functionality will be delegated into templates and
instantiated where necessary and desired by <a href="#asset_issuer">asset issuer</a>s.</p>
<p>This also means that Tari offers additional flexibility for issuers and users while the ecosystem is better positioned
to respond to changes in demand and new smart contract patterns.</p>
<p>For this RFC, we limit the conversation to a very broad description of how the templates could be implemented, but will
leave specifics to RFCs that are more focussed on the topic.</p>
<h3 id="funding-withdrawals-and-deposits"><a class="header" href="#funding-withdrawals-and-deposits">Funding, withdrawals and deposits</a></h3>
<p>Deposits and withdrawals go via a smart contract template using the bridge model.</p>
<h4 id="very-high-level-flow"><a class="header" href="#very-high-level-flow">Very high level flow</a></h4>
<ol>
<li>Send Tari via One-sided payment to an address defined by the template. (Could have a <code>DEPOSIT</code> output feature if
required)</li>
<li>The VNC sees this, and then issues / prints / mints the equivalent value on side-chain according to the side-chain
protocol.</li>
<li>Equivalent coins change hands many times. The account template maintains an accurate balance of all users’ accounts,
with the VNC reaching consensus on value transfer instructions according to the consensus algorithm in force.</li>
<li>A User requests a withdrawal.</li>
<li>The VNC debits the user’s account and &quot;burns&quot; equivalent coins on the side chain.</li>
<li>The VNC broadcasts a standard one-side Tari transaction to the user’s benefit.</li>
<li>Optionally, the template functionality facilitating proofs of reserve, i.e. that locked funds are of equivalent value
to minted funds.</li>
</ol>
<p>Note that this model is not trustless from a base-layer point of view. Users are trusting the side chain, and VNC to not
steal their funds. Therefore one may want to encourage the deployment of PoW or PoS side-chains when executing contracts
that handle large amounts of value.</p>
<h5 id="possible-variants"><a class="header" href="#possible-variants">Possible variants</a></h5>
<ul>
<li>Users deposit and get a refund transaction to hold onto.</li>
<li>The refund tx gets updated every time the balance changes. ala Lightning.</li>
<li>Proof of burn tied to proof of spend.</li>
<li>Atomic swaps to force issue of token on side-chain in (1.) above.</li>
</ul>
<p>We could implement any/all of these variants in different templates.</p>
<h3 id="validator-node-fees"><a class="header" href="#validator-node-fees">Validator node fees</a></h3>
<p>2 Template models:</p>
<ul>
<li>Model A - Centrally funded</li>
<li>Fees are drawn from a single account (typically funded by asset issuer)</li>
<li>Eligible instructions are defined in the template constructor.</li>
<li>Model B - User funded</li>
<li>Requires an account template</li>
<li>Fees are supplied with an instruction</li>
<li>Eligible instructions are defined in the template constructor.</li>
<li>Instructions that are not covered by the model MAY be rejected by the VNC</li>
</ul>
<h3 id="validator-node-instructions"><a class="header" href="#validator-node-instructions">Validator Node Instructions</a></h3>
<p>What does an instruction look like? Note: Solana instructions contain</p>
<ul>
<li>ProgramId</li>
<li>Vec of accounts that the instruction will interact with (plus whether they're mutable and have signer auth)</li>
<li>a blob that the program will deserialise. So, no inherently accessible API</li>
</ul>
<p>Requires:</p>
<ul>
<li>Contract ID</li>
<li>Vec of method calls: (this is different to how Solana does it/ Maybe some discussion on pros&amp;cons is worthwhile. If we
go WASM, the API is available via reflection)
<ul>
<li>Method ID (template::method)</li>
<li>Method arguments</li>
</ul>
</li>
<li>Authorization
<ul>
<li>signed token-based (Macaroons / JWTish)</li>
</ul>
</li>
</ul>
<p>Now the VNs have everything they need to execute the Instruction. They execute the instruction. The update the state
tree. Return of the call is a &quot;diff&quot; of some sort, which gets appended to the &quot;OP Log&quot; document, and the new state root
hash.</p>
<p>The VNC SHOULD reach consensus on this result.</p>
<p>Then you move onto the next instruction.</p>
<ul>
<li>
<p>Where do instructions get submitted?</p>
<ul>
<li>The [peg-in transaction] contains the pubkeys of each member of the VNC; or a checkpoint transaction.</li>
<li>ergo, a client app knows the pubkeys of the VNC at all times.</li>
<li>A client can send an Instruction to ANY VNC member via comms</li>
</ul>
</li>
<li>
<p>VNs MUST maintain a mempool of instructions</p>
</li>
<li>
<p>VNs SHOULD share instructions with its peer committee members</p>
</li>
<li>
<p>Ordering of instructions.</p>
<ul>
<li>(In Hotstuff) The leader selects the next instruction(s) to run.</li>
<li>The leader MAY batch instructions in a single consensus round.</li>
<li>For account-based side-chains, Instructions SHOULD contain a nonce??? (Might not be workable)</li>
<li>For account-based side-chains, Instructions COULD have a dependency field that forces ordering of selected
instructions.
<ul>
<li>Potentially, an accumulator is a way to do this. An instruction provides a list of instruction hashes, and the
instruction can be included ONLY IF ALL hashes have been recorded.</li>
</ul>
</li>
<li>Instructions MUST not be executed more than once, even if resubmitted. Suggests some sort of salt/entropy/nonce so
that the same execution steps could be run without being interpreted as the <em>same</em> instruction. (e.g.
micro-transactions).</li>
</ul>
</li>
</ul>
<h3 id="inter-contract-interactions"><a class="header" href="#inter-contract-interactions">Inter-contract interactions</a></h3>
<p>Possible routes for this:</p>
<h4 id="atomic-transactions"><a class="header" href="#atomic-transactions">Atomic transactions</a></h4>
<ul>
<li>Provide a proof that a conditional instruction on one chain has been executed,</li>
<li>Execute on this chain, which reveals some fact that the other chain can use to finalise the instruction on the other
chain.</li>
<li>Rolls back if 2nd party does not follow through.</li>
</ul>
<p>Advantages:</p>
<ul>
<li>Does work.</li>
</ul>
<p>Disadvantages</p>
<ul>
<li>Slow</li>
<li>Need to get data from other chain.</li>
<li>Might hold up entire chain for extended periods.</li>
</ul>
<h4 id="observer-protocol"><a class="header" href="#observer-protocol">Observer protocol</a></h4>
<p>Implement a set of APIs in a template for reading the event log from the VNC directly or query the &quot;read-only&quot; contract.</p>
<p>Pros:</p>
<ul>
<li>Fast</li>
<li>Permissionless in one-way applications</li>
<li>Can check that results are signed by the VNC quorum</li>
</ul>
<p>Cons:</p>
<ul>
<li>Rely on contracts implementing the protocol</li>
<li>Instructions that require both chains' state to update is harder using this method.</li>
</ul>
<h4 id="micro-payments"><a class="header" href="#micro-payments">Micro-payments</a></h4>
<h5 id="bundle-accounts-template-into-smart-contract"><a class="header" href="#bundle-accounts-template-into-smart-contract">Bundle accounts template into smart contract</a></h5>
<ul>
<li>The bundled &quot;wrapped&quot; Tari is used in micropayments.</li>
<li>Users top up or withdraw Tari into the micropayment accounts using a bride or one of the methods described above.</li>
</ul>
<h5 id="async-await-analogue"><a class="header" href="#async-await-analogue">Async-await analogue</a></h5>
<ul>
<li>Contract A is a digital assets contract.</li>
<li>Contract B is a payments contract.</li>
<li>A and Bob have a monetary account on B, and Bob wants access to the assets on A.</li>
<li>Bob authorises A to debit his account on B for a certain amount / under certain conditions OR</li>
<li>Bob authorises the invoice produced by A for a discrete payment.</li>
<li>A submits a payment instruction to B to withdraw the amount, co-signed by Bob (or he did a pre-auth).</li>
<li>A &quot;awaits&quot; the result of the payment, and once successful, releases the asset OR</li>
<li>the instruction times out and Bob does not receive the asset and the instruction concludes.</li>
</ul>
<p>Pros:</p>
<ul>
<li>Can work in general, not just micro-payments</li>
<li>Can be fast.</li>
<li>Doesn't block progress in the face of obstructive agents.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Complex (handling collusion, &quot;proof-of-delivery&quot;)</li>
<li>time-outs can lock up funds for long periods.</li>
<li>Relies on chains publishing events.</li>
<li>Contract B is a trusted party from the PoV of Bob / A (e.g. Bob &amp; B collude to lie about account updates in order to
defraud A)</li>
</ul>
<h1 id="change-log"><a class="header" href="#change-log">Change Log</a></h1>
<ul>
<li><strong>06-04-2022</strong>: First draft</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="RFCD-0311_AssetTemplates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="RFCD-0322_VNRegistration.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a href="RFCD-0311_AssetTemplates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a href="RFCD-0322_VNRegistration.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <script src=" https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js "></script>
        <script>mermaid.initialize({startOnLoad:true});</script>

        <!-- Custom JS scripts -->


    </body>
</html>
